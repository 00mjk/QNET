

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Symbolic Algebra &mdash; QNET 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/mycss.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/mathjax_cancel.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="QNET 1.0 documentation" href="index.html" />
    <link rel="next" title="Properties and Simplification of Circuit Algebraic Expressions" href="circuit_rules.html" />
    <link rel="prev" title="Installation/Setup" href="install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="circuit_rules.html" title="Properties and Simplification of Circuit Algebraic Expressions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Installation/Setup"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">QNET 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Symbolic Algebra</a><ul>
<li><a class="reference internal" href="#the-abstract-algebra-module">The Abstract Algebra module</a><ul>
<li><a class="reference internal" href="#defining-operation-subclasses">Defining <tt class="docutils literal"><span class="pre">Operation</span></tt> subclasses</a></li>
<li><a class="reference internal" href="#pattern-matching">Pattern matching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hilbert-space-algebra">Hilbert Space Algebra</a><ul>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-operator-algebra-module">The Operator Algebra module</a><ul>
<li><a class="reference internal" href="#all-operator-classes">All Operator classes</a></li>
<li><a class="reference internal" href="#id4">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-circuit-algebra-module">The Circuit Algebra module</a><ul>
<li><a class="reference internal" href="#fundamental-circuit-operations">Fundamental Circuit Operations</a></li>
<li><a class="reference internal" href="#representation-as-python-objects">Representation as Python objects</a></li>
<li><a class="reference internal" href="#id11">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-super-operator-algebra-module">The Super-Operator Algebra module</a></li>
<li><a class="reference internal" href="#the-state-ket-algebra-module">The State (Ket-) Algebra module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="install.html"
                        title="previous chapter">Installation/Setup</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="circuit_rules.html"
                        title="next chapter">Properties and Simplification of Circuit Algebraic Expressions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/symbolic_algebra.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="symbolic-algebra">
<span id="id1"></span><h1>Symbolic Algebra<a class="headerlink" href="#symbolic-algebra" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-abstract-algebra-module">
<span id="abstract-algebra"></span><h2>The Abstract Algebra module<a class="headerlink" href="#the-abstract-algebra-module" title="Permalink to this headline">¶</a></h2>
<p>The module features generic classes for encapsulating expressions and operations on expressions.
It also includes some basic pattern matching and expression rewriting capabilities.</p>
<p>The most important classes to derive from for implementing a custom &#8216;algebra&#8217; are <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.Expression" title="qnet.algebra.abstract_algebra.Expression"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Expression</span></tt></a> and <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a>,
where the second is actually a subclass of the first.</p>
<p>The <tt class="docutils literal"><span class="pre">Operation</span></tt> class should be subclassed to implement any structured expression type
that can be specified in terms of a <em>head</em> and a (finite) sequence of <em>operands</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Head</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">opN</span><span class="p">)</span>
</pre></div>
</div>
<p>An operation is assumed to have immutable operands, i.e., if one wishes to change the operands of an <tt class="docutils literal"><span class="pre">Operation</span></tt>,
one rather creates a new Operation with modified Operands.</p>
<div class="section" id="defining-operation-subclasses">
<h3>Defining <tt class="docutils literal"><span class="pre">Operation</span></tt> subclasses<a class="headerlink" href="#defining-operation-subclasses" title="Permalink to this headline">¶</a></h3>
<p>The single most important method of the <tt class="docutils literal"><span class="pre">Operation</span></tt> class is the <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.Operation.create" title="qnet.algebra.abstract_algebra.Operation.create"><tt class="xref py py-meth docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation.create()</span></tt></a> classmethod.</p>
<p><strong>Automatic expression rewriting by modifying/decorating the</strong> <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.Operation.create" title="qnet.algebra.abstract_algebra.Operation.create"><tt class="xref py py-meth docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation.create()</span></tt></a> <strong>method</strong></p>
<p>A list of class decorators:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.assoc" title="qnet.algebra.abstract_algebra.assoc"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.assoc()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.idem" title="qnet.algebra.abstract_algebra.idem"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.idem()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.orderby" title="qnet.algebra.abstract_algebra.orderby"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.orderby()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.filter_neutral" title="qnet.algebra.abstract_algebra.filter_neutral"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.filter_neutral()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.check_signature" title="qnet.algebra.abstract_algebra.check_signature"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.check_signature()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.match_replace" title="qnet.algebra.abstract_algebra.match_replace"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.match_replace()</span></tt></a></li>
<li><a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.match_replace_binary" title="qnet.algebra.abstract_algebra.match_replace_binary"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.match_replace_binary()</span></tt></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="pattern-matching">
<h3>Pattern matching<a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.Wildcard" title="qnet.algebra.abstract_algebra.Wildcard"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Wildcard</span></tt></a> class.</p>
<p>The <a class="reference internal" href="qnet.algebra.html#qnet.algebra.abstract_algebra.match" title="qnet.algebra.abstract_algebra.match"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.abstract_algebra.match()</span></tt></a> function.</p>
<p>For a relatively simple example of how an algebra can be defined, see the Hilbert space algebra defined in <a class="reference internal" href="qnet.algebra.html#module-qnet.algebra.hilbert_space_algebra" title="qnet.algebra.hilbert_space_algebra"><tt class="xref py py-mod docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra</span></tt></a>.</p>
</div>
</div>
<div class="section" id="hilbert-space-algebra">
<span id="id2"></span><h2>Hilbert Space Algebra<a class="headerlink" href="#hilbert-space-algebra" title="Permalink to this headline">¶</a></h2>
<p>This covers only finite dimensional or countably infinite dimensional Hilbert spaces.</p>
<p>The basic abstract class that features all properties of Hilbert space objects is given by: <a class="reference internal" href="qnet.algebra.html#qnet.algebra.hilbert_space_algebra.HilbertSpace" title="qnet.algebra.hilbert_space_algebra.HilbertSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.HilbertSpace</span></tt></a>.
Its most important subclasses are:</p>
<blockquote>
<div><ul class="simple">
<li>local/primitive degrees of freedom (e.g. a single multi-level atom or a cavity mode) are described by a <a class="reference internal" href="qnet.algebra.html#qnet.algebra.hilbert_space_algebra.LocalSpace" title="qnet.algebra.hilbert_space_algebra.LocalSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.LocalSpace</span></tt></a>. Every local space is identified by</li>
<li>composite tensor product spaces are given by instances of the <a class="reference internal" href="qnet.algebra.html#qnet.algebra.hilbert_space_algebra.ProductSpace" title="qnet.algebra.hilbert_space_algebra.ProductSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.ProductSpace</span></tt></a> class.</li>
<li>the <tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.TrivialSpace</span></tt> represents a <em>trivial</em> <a class="footnote-reference" href="#f1" id="id3">[1]</a> Hilbert space <span class="math">\(\mathcal{H}_0 \simeq \mathbb{C}\)</span></li>
<li>the <tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.FullSpace</span></tt> represents a Hilbert space that includes all possible degrees of freedom.</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><em>trivial</em> in the sense that <span class="math">\(\mathcal{H}_0 \simeq \mathbb{C}\)</span>,
i.e., all states are multiples of each other and thus equivalent.</td></tr>
</tbody>
</table>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>A single local space can be instantiated in several ways. It is most convenient to use the <a class="reference internal" href="qnet.algebra.html#qnet.algebra.hilbert_space_algebra.local_space" title="qnet.algebra.hilbert_space_algebra.local_space"><tt class="xref py py-func docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.local_space()</span></tt></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    LocalSpace(1, &#39;&#39;)</span>
</pre></div>
</div>
<p>This method also allows for the specification of the <tt class="docutils literal"><span class="pre">dimension</span></tt> of the local degree of freedom&#8217;s state space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">    LocalSpace(1, &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span>
<span class="go">    10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">basis</span>
<span class="go">    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
<p>Alternatively, one can pass a sequence of <tt class="docutils literal"><span class="pre">basis</span></tt> state labels instead of the <tt class="docutils literal"><span class="pre">dimension</span></tt> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lambda_atom_space</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;las&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lambda_atom_space</span>
<span class="go">    LocalSpace(&#39;las&#39;, &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lambda_atom_space</span><span class="o">.</span><span class="n">dimension</span>
<span class="go">    3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lambda_atom_space</span><span class="o">.</span><span class="n">basis</span>
<span class="go">    (&#39;e&#39;, &#39;h&#39;, &#39;g&#39;)</span>
</pre></div>
</div>
<p>Finally, one can pass a <tt class="docutils literal"><span class="pre">namespace</span></tt> argument, which is useful if one is working with multiple copies of identical systems, e.g. if one instantiates multiple copies of a particular circuit component with internal degrees of freedom:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s_q1</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;q1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_q2</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;q2&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_q1</span>
<span class="go">    LocalSpace(&#39;s&#39;, &#39;q1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_q2</span>
<span class="go">    LocalSpace(&#39;s&#39;, &#39;q2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_q1</span> <span class="o">*</span> <span class="n">s_q2</span>
<span class="go">    ProductSpace(LocalSpace(&#39;s&#39;, &#39;q1&#39;), LocalSpace(&#39;s&#39;, &#39;q2&#39;))</span>
</pre></div>
</div>
<p>The default <tt class="docutils literal"><span class="pre">namespace</span></tt> is the empty string <tt class="docutils literal"><span class="pre">''</span></tt>.
Here, we have already seen the simplest way to create a tensor product of spaces:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">    ProductSpace(LocalSpace(1, &#39;&#39;), LocalSpace(2, &#39;&#39;))</span>
</pre></div>
</div>
<p>Note that this tensor product is <em>commutative</em></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">local_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    ProductSpace(LocalSpace(1, &#39;&#39;), LocalSpace(2, &#39;&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>and <em>associative</em></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">local_space</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">local_space</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">    ProductSpace(LocalSpace(&#39;1&#39;, &#39;&#39;), LocalSpace(&#39;2&#39;, &#39;&#39;), LocalSpace(&#39;3&#39;, &#39;&#39;))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-operator-algebra-module">
<span id="operator-algebra"></span><h2>The Operator Algebra module<a class="headerlink" href="#the-operator-algebra-module" title="Permalink to this headline">¶</a></h2>
<p>This module features classes and functions to define and manipulate symbolic Operator expressions.
Operator expressions are constructed from sums (<a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorPlus" title="qnet.algebra.operator_algebra.OperatorPlus"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorPlus</span></tt></a>) and products (<a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes" title="qnet.algebra.operator_algebra.OperatorTimes"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorTimes</span></tt></a>)
of some basic elements, most importantly <em>local</em> operators,
such as the annihilation (<a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Destroy" title="qnet.algebra.operator_algebra.Destroy"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Destroy</span></tt></a>) and creation (<a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Create" title="qnet.algebra.operator_algebra.Create"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Create</span></tt></a>) operators <span class="math">\(a_s, a_s^\dagger\)</span>
of a quantum harmonic oscillator degree of freedom <span class="math">\(s\)</span>.
Further important elementary local operators are the switching operators
<span class="math">\(\sigma_{jk}^s := \left| j \right\rangle_s \left \langle k \right|_s\)</span> (<a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.LocalSigma" title="qnet.algebra.operator_algebra.LocalSigma"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalSigma</span></tt></a>).
Each operator has an associated <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Operator.space" title="qnet.algebra.operator_algebra.Operator.space"><tt class="xref py py-attr docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator.space</span></tt></a> property which gives the Hilbert space
(cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.hilbert_space_algebra.HilbertSpace" title="qnet.algebra.hilbert_space_algebra.HilbertSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.HilbertSpace</span></tt></a>) on which it acts <em>non-trivially</em>.
We don&#8217;t explicitly distinguish between <em>tensor</em>-products <span class="math">\(X_s\otimes Y_r\)</span> of operators on different degrees of freedom <span class="math">\(s,r\)</span>
(which we designate as <em>local</em> spaces) and <em>operator-composition</em>-products <span class="math">\(X_s \cdot Y_s\)</span> of operators acting on the same degree of freedom <span class="math">\(s\)</span>.
Conceptionally, we assume that each operator is always implicitly tensored with identity operators acting on all un-specified degrees of freedom.
This is typically done in the physics literature and only plays a role when tansforming to a numerical representation
of the problem for the purpose of simulation, diagonalization, etc.</p>
<div class="section" id="all-operator-classes">
<h3>All Operator classes<a class="headerlink" href="#all-operator-classes" title="Permalink to this headline">¶</a></h3>
<p>A complete list of all local operators is given below:</p>
<blockquote>
<div><ul class="simple">
<li>Harmonic oscillator mode operators <span class="math">\(a_s, a_s^\dagger\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Destroy" title="qnet.algebra.operator_algebra.Destroy"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Destroy</span></tt></a>, <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Create" title="qnet.algebra.operator_algebra.Create"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Create</span></tt></a>)</li>
<li><span class="math">\(\sigma\)</span>-switching operators  <span class="math">\(\sigma_{jk}^s := \left| j \right\rangle_s \left \langle k \right|_s\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.LocalSigma" title="qnet.algebra.operator_algebra.LocalSigma"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalSigma</span></tt></a>)</li>
<li>coherent displacement operators <span class="math">\(D_s(\alpha) := \exp{\left(\alpha a_s^\dagger - \alpha^* a_s\right)}\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Displace" title="qnet.algebra.operator_algebra.Displace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Displace</span></tt></a>)</li>
<li>phase operators <span class="math">\(P_s(\phi) := \exp {\left(i\phi a_s^\dagger a_s\right)}\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Phase" title="qnet.algebra.operator_algebra.Phase"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Phase</span></tt></a>)</li>
<li>squeezing operators <span class="math">\(S_s(\eta) := \exp {\left[{1\over 2}\left({\eta {a_s^\dagger}^2 - \eta^* a_s^2}\right)\right]}\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Squeeze" title="qnet.algebra.operator_algebra.Squeeze"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Squeeze</span></tt></a>)</li>
</ul>
</div></blockquote>
<p>Furthermore, there exist symbolic representations for constants and symbols:</p>
<blockquote>
<div><ul class="simple">
<li>the identity operator (cf <tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.IdentityOperator</span></tt>)</li>
<li>and the zero operator (cf <tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.ZeroOperator</span></tt>)</li>
<li>an arbitrary operator symbol (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorSymbol" title="qnet.algebra.operator_algebra.OperatorSymbol"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorSymbol</span></tt></a>)</li>
</ul>
</div></blockquote>
<p>Finally, we have the following Operator operations:</p>
<blockquote>
<div><ul>
<li><p class="first">sums of operators <span class="math">\(X_1 + X_2 + \dots + X_n\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorPlus" title="qnet.algebra.operator_algebra.OperatorPlus"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorPlus</span></tt></a>)</p>
</li>
<li><p class="first">products of operators <span class="math">\(X_1  X_2  \cdots  X_n\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes" title="qnet.algebra.operator_algebra.OperatorTimes"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorTimes</span></tt></a>)</p>
</li>
<li><p class="first">the Hilbert space adjoint operator <span class="math">\(X^\dagger\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Adjoint" title="qnet.algebra.operator_algebra.Adjoint"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Adjoint</span></tt></a>)</p>
</li>
<li><p class="first">scalar multiplication <span class="math">\(\lambda X\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.ScalarTimesOperator" title="qnet.algebra.operator_algebra.ScalarTimesOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.ScalarTimesOperator</span></tt></a>)</p>
</li>
<li><dl class="first docutils">
<dt>pseudo-inverse of operators <span class="math">\(X^+\)</span> satisfying <span class="math">\(X X^+ X = X\)</span> and <span class="math">\(X^+ X X^+ = X^+\)</span> as well</dt>
<dd><p class="first last">as <span class="math">\((X^+ X)^\dagger = X^+ X\)</span> and <span class="math">\((X X^+)^\dagger = X X^+\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.PseudoInverse" title="qnet.algebra.operator_algebra.PseudoInverse"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.PseudoInverse</span></tt></a>)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>the kernel projection operator <span class="math">\(\mathcal{P}_{{\rm Ker} X}\)</span> satisfying both <span class="math">\(X \mathcal{P}_{{\rm Ker} X} = 0\)</span></dt>
<dd><p class="first last">and <span class="math">\(X^+ X =  1 - \mathcal{P}_{{\rm Ker} X}\)</span>  (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.NullSpaceProjector" title="qnet.algebra.operator_algebra.NullSpaceProjector"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.NullSpaceProjector</span></tt></a>)</p>
</dd>
</dl>
</li>
<li><p class="first">Partial traces over Operators <span class="math">\({\rm Tr}_s X\)</span> (cf <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTrace" title="qnet.algebra.operator_algebra.OperatorTrace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorTrace</span></tt></a>)</p>
</li>
</ul>
</div></blockquote>
<p>For a list of all properties and methods of an operator object, see the documentation for the basic <a class="reference internal" href="qnet.algebra.html#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a> class.</p>
</div>
<div class="section" id="id4">
<h3>Examples<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Say we want to write a function that constructs a typical Jaynes-Cummings Hamiltonian</p>
<div class="math">
\[H = \Delta \sigma^\dagger \sigma + \Theta a^\dagger a + i g(\sigma a^\dagger - \sigma^\dagger a) + i\epsilon (a - a^\dagger)\]</div>
<p>for a given set of numerical parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">H_JaynesCummings</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">):</span>

    <span class="c"># create Fock- and Atom local spaces</span>
    <span class="n">fock</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;fock&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">)</span>
    <span class="n">tls</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;tls&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">))</span>

    <span class="c"># create representations of a and sigma</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">fock</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">tls</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">Delta</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma</span>                        <span class="c"># detuning from atomic resonance</span>
        <span class="o">+</span> <span class="n">Theta</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span>                               <span class="c"># detuning from cavity resonance</span>
        <span class="o">+</span> <span class="n">I</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>       <span class="c"># atom-mode coupling, I = sqrt(-1)</span>
        <span class="o">+</span> <span class="n">I</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()))</span>                      <span class="c"># external driving amplitude</span>
    <span class="k">return</span> <span class="n">H</span>
</pre></div>
</div>
<p>Here we have allowed for a variable namespace which would come in handy if we wanted to construct an overall model that features multiple Jaynes-Cummings-type subsystems.</p>
<p>By using the support for symbolic <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> expressions as scalar pre-factors to operators, one can instantiate a Jaynes-Cummings Hamiltonian with symbolic parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;Delta, Theta, epsilon, g&#39;</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">H_JaynesCummings</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="go">    &#39;Delta Pi_e^[tls] +  I*g ((a_fock)^* sigma_ge^[tls] - a_fock sigma_eg^[tls]) +  I*epsilon ( - (a_fock)^* + a_fock) +  Theta (a_fock)^* a_fock&#39;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">space</span>
<span class="go">    ProductSpace(LocalSpace(&#39;fock&#39;, &#39;&#39;), LocalSpace(&#39;tls&#39;, &#39;&#39;))</span>
</pre></div>
</div>
<p>or equivalently, represented in latex via <tt class="docutils literal"><span class="pre">H.tex()</span></tt> this yields:</p>
<div class="math">
\[\Delta {\Pi_{{\rm e}}^{{{\rm tls}}}} +  \mathbf{\imath} g \left({a_{{{\rm fock}}}^\dagger} {\sigma_{{\rm g},{\rm e}}^{{{\rm tls}}}} - {a_{{{\rm fock}}}} {\sigma_{{\rm e},{\rm g}}^{{{\rm tls}}}}\right) +  \mathbf{\imath} \epsilon \left( - {a_{{{\rm fock}}}^\dagger} + {a_{{{\rm fock}}}}\right) +  \Theta {a_{{{\rm fock}}}^\dagger} {a_{{{\rm fock}}}}\]</div>
<p>Operator products between commuting operators are automatically re-arranged such that they are ordered according to their Hilbert Space</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    OperatorTimes(Create(1), Create(2))</span>
</pre></div>
</div>
<p>There are quite a few built-in replacement rules, e.g., mode operators products are normally ordered:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1 + Create(1) * Destroy(1)</span>
</pre></div>
</div>
<p>Or for higher powers one can use the <tt class="docutils literal"><span class="pre">expand()</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">    (6 + Create(1) * Create(1) * Create(1) * Destroy(1) * Destroy(1) * Destroy(1) + 9 * Create(1) * Create(1) * Destroy(1) * Destroy(1) + 18 * Create(1) * Destroy(1))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-circuit-algebra-module">
<span id="circuit-algebra"></span><h2>The Circuit Algebra module<a class="headerlink" href="#the-circuit-algebra-module" title="Permalink to this headline">¶</a></h2>
<p>In their works on networks of open quantum systems <a class="reference internal" href="references.html#goughjames08">[GoughJames08]</a>, <a class="reference internal" href="references.html#goughjames09">[GoughJames09]</a> Gough and James have introduced an algebraic method to derive the Quantum Markov model for a full network of cascaded quantum systems from the reduced Markov models of its constituents.
A general system with an equal number <span class="math">\(n\)</span> of input and output channels is described by the parameter triplet <span class="math">\(\left(\mathbf{S}, \mathbf{L}, H\right)\)</span>, where <span class="math">\(H\)</span> is the effective internal <em>Hamilton operator</em> for the system, <span class="math">\(\mathbf{L} = (L_1, L_2, \dots, L_n)^T\)</span> the <em>coupling vector</em> and <span class="math">\(\mathbf{S} = (S_{jk})_{j,k=1}^n\)</span> is the <em>scattering matrix</em> (whose elements are themselves operators).
An element <span class="math">\(L_k\)</span> of the coupling vector is given by a system operator that describes the system&#8217;s coupling to the <span class="math">\(k\)</span>-th input channel. Similarly, the elements <span class="math">\(S_{jk}\)</span> of the scattering matrix are in general given by system operators describing the scattering between different field channels <span class="math">\(j\)</span> and <span class="math">\(k\)</span>.
The only conditions on the parameters are that the hamilton operator is self-adjoint and the scattering matrix is unitary:</p>
<div class="math">
\[H^* = H \text{ and } \mathbf{S}^\dagger \mathbf{S} = \mathbf{S} \mathbf{S}^\dagger = \mathbf{1}_n.\]</div>
<p>We adhere to the conventions used by Gough and James, i.e. we write the imaginary unit is given by <span class="math">\(i := \sqrt{-1}\)</span>, the adjoint of an operator <span class="math">\(A\)</span> is given by <span class="math">\(A^*\)</span>, the element-wise adjoint of an operator matrix <span class="math">\(\mathbf{M}\)</span> is given by <span class="math">\(\mathbf{M}^\sharp\)</span>. Its transpose is given by <span class="math">\(\mathbf{M}^T\)</span> and the combination of these two operations, i.e. the adjoint operator matrix is given by <span class="math">\(\mathbf{M}^\dagger = (\mathbf{M}^T)^\sharp = (\mathbf{M}^\sharp)^T\)</span>.</p>
<div class="section" id="fundamental-circuit-operations">
<h3>Fundamental Circuit Operations<a class="headerlink" href="#fundamental-circuit-operations" title="Permalink to this headline">¶</a></h3>
<p>The basic operations of the Gough-James circuit algebra are given by:</p>
<div class="figure">
<img alt="_images/concatenation.png" src="_images/concatenation.png" />
<p class="caption"><span class="math">\(Q_1 \boxplus Q_2\)</span></p>
</div>
<div class="figure">
<img alt="_images/series.png" src="_images/series.png" />
<p class="caption"><span class="math">\(Q_2 \lhd Q_1\)</span></p>
</div>
<div class="figure">
<img alt="_images/feedback.png" src="_images/feedback.png" />
<p class="caption"><span class="math">\([Q]_{1 \to 4}\)</span></p>
</div>
<p>In <a class="reference internal" href="references.html#goughjames09">[GoughJames09]</a>, Gough and James have introduced two operations that allow the construction of quantum optical &#8216;feedforward&#8217; networks:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The <em>concatenation</em> product describes the situation where two arbitrary systems are formally attached to each other without optical scattering between the two systems&#8217; in- and output channels</li>
</ol>
<div class="math">
\[\begin{split}\left(\mathbf{S}_1, \mathbf{L}_1, H_1\right) \boxplus \left(\mathbf{S}_2, \mathbf{L}_2, H_2\right) = \left(\begin{pmatrix} \mathbf{S}_1 &amp; 0 \\ 0 &amp; \mathbf{S}_2 \end{pmatrix}, \begin{pmatrix}\mathbf{L}_1 \\ \mathbf{L}_1 \end{pmatrix}, H_1 + H_2 \right)\end{split}\]</div>
<p>Note however, that even without optical scattering, the two subsystems may interact directly via shared quantum degrees of freedom.</p>
<ol class="arabic simple" start="2">
<li>The <em>series</em> product is to be used for two systems <span class="math">\(Q_j = \left(\mathbf{S}_j, \mathbf{L}_j, H_j \right)\)</span>, <span class="math">\(j=1,2\)</span> of equal channel number <span class="math">\(n\)</span> where all output channels of <span class="math">\(Q_1\)</span> are fed into the corresponding input channels of <span class="math">\(Q_2\)</span></li>
</ol>
<div class="math">
\[\left(\mathbf{S}_2, \mathbf{L}_2, H_2 \right) \lhd \left( \mathbf{S}_1, \mathbf{L}_1, H_1 \right) = \left(\mathbf{S}_2 \mathbf{S}_1,\mathbf{L}_2 + \mathbf{S}_2\mathbf{L}_1 , H_1 + H_2 + \Im\left\{\mathbf{L}_2^\dagger \mathbf{S}_2 \mathbf{L}_1\right\}\right)\]</div>
</div></blockquote>
<p>From their definition it can be seen that the results of applying both the series product and the concatenation product not only yield valid circuit component triplets that obey the constraints, but they are also associative operations.footnote{For the concatenation product this is immediately clear, for the series product in can be quickly verified by computing <span class="math">\((Q_1 \lhd Q_2) \lhd Q_3\)</span> and <span class="math">\(Q_1 \lhd (Q_2 \lhd Q_3)\)</span>.
To make the network operations complete in the sense that it can also be applied for situations with optical feedback, an additional rule is required: The <em>feedback</em> operation  describes the case where the <span class="math">\(k\)</span>-th output channel of a system with <span class="math">\(n\ge 2\)</span> is fed back into the <span class="math">\(l\)</span>-th input channel. The result is a component with <span class="math">\(n-1\)</span> channels:</p>
<div class="math">
\[\left[\;\left(\mathbf{S}, \mathbf{L}, H \right)\;\right]_{k \to l} = \left(\tilde{\mathbf{S}}, \tilde{\mathbf{L}}, \tilde{H}\right),\]</div>
<p>where the effective parameters are given by <a class="reference internal" href="references.html#goughjames08">[GoughJames08]</a></p>
<div class="math">
\[\begin{split}\tilde{\mathbf{S}} &amp; = \mathbf{S}_{\cancel{[k,l]}} +  \begin{pmatrix} S_{1l} \\ S_{2l} \\ \vdots \\ S_{k-1\, l} \\ S_{k+1\, l} \\ \vdots \\ S_{n l}\end{pmatrix}(1 - S_{kl})^{-1}  \begin{pmatrix} S_{k 1} &amp; S_{k2} &amp; \cdots &amp; S_{kl-1} &amp; S_{kl+1} &amp; \cdots &amp; S_{k n}\end{pmatrix}, \\
\tilde{\mathbf{L}} &amp; = \mathbf{L}_{\cancel{[k]}} + \begin{pmatrix} S_{1l} \\ S_{2l} \\ \vdots \\ S_{k-1\, l} \\ S_{k+1\, l} \\ \vdots \\ S_{n l}\end{pmatrix} (1 - S_{kl})^{-1} L_k, \\
\tilde{H} &amp; = H + \Im\left\{\ \left[\sum_{j=1}^n L_j^* S_{jl}\right] (1 - S_{kl})^{-1} L_k \right\}.\end{split}\]</div>
<p>Here we have written <span class="math">\(\mathbf{S}_{\cancel{[k,l]}}\)</span> as a shorthand notation for the matrix <span class="math">\(\mathbf{S}\)</span> with the <span class="math">\(k\)</span>-th row and <span class="math">\(l\)</span>-th column removed and similarly <span class="math">\(\mathbf{L}_{\cancel{[k]}}\)</span> is the vector <span class="math">\(\mathbf{L}\)</span> with its <span class="math">\(k\)</span>-th entry removed.
Moreover, it can be shown that in the case of multiple feedback loops, the result is independent of the order in which the feedback operation is applied. Note however that some care has to be taken with the indices of the feedback channels when permuting the feedback operation.</p>
<p>The possibility of treating the quantum circuits algebraically offers some valuable insights:
A given full-system triplet <span class="math">\((\mathbf{S}, \mathbf{L}, H )\)</span> may very well allow for different ways of decomposing it algebraically into networks of physically realistic subsystems. The algebraic treatment thus establishes a notion of dynamic equivalence between potentially very different physical setups.
Given a certain number of fundamental building blocks such as beamsplitters, phases and cavities, from which we construct complex networks, we can investigate what kinds of composite systems can be realized. If we also take into account the adiabatic limit theorems for QSDEs (cite Bouten2008a,Bouten2008) the set of physically realizable systems is further expanded.
Hence, the algebraic methods not only facilitate the analysis of quantum circuits, but ultimately they may very well lead to an understanding of how to construct a general system <span class="math">\((\mathbf{S}, \mathbf{L}, H)\)</span> from some set of elementary systems.
There already exist some investigations along these lines for the particular subclass of <em>linear</em> systems (cite Nurdin2009a,Nurdin2009b) which can be thought of as a networked collection of quantum harmonic oscillators.</p>
</div>
<div class="section" id="representation-as-python-objects">
<h3>Representation as Python objects<a class="headerlink" href="#representation-as-python-objects" title="Permalink to this headline">¶</a></h3>
<p>This file features an implementation of the Gough-James circuit algebra rules as introduced in <a class="reference internal" href="references.html#goughjames08">[GoughJames08]</a> and <a class="reference internal" href="references.html#goughjames09">[GoughJames09]</a>.
Python objects that are of the <a class="reference internal" href="qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a> type have some of their operators overloaded to realize symbolic circuit algebra operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="n">B</span>
<span class="go">    SeriesProduct(A, B)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span>
<span class="go">    Concatenation(A, B)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FB</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">    Feedback(A, 0, 1)</span>
</pre></div>
</div>
<p>For a thorough treatment of the circuit expression simplification rules see <a class="reference internal" href="circuit_rules.html#circuit-rules"><em>Properties and Simplification of Circuit Algebraic Expressions</em></a>.</p>
</div>
<div class="section" id="id11">
<h3>Examples<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Extending the JaynesCummings problem above to an open system by adding collapse operators <span class="math">\(L_1 = \sqrt{\kappa} a\)</span> and <span class="math">\(L_2 = \sqrt{\gamma}\sigma.\)</span></p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">SLH_JaynesCummings</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">):</span>

    <span class="c"># create Fock- and Atom local spaces</span>
    <span class="n">fock</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;fock&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">)</span>
    <span class="n">tls</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="s">&#39;tls&#39;</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">))</span>

    <span class="c"># create representations of a and sigma</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">fock</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">tls</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">)</span>

    <span class="c"># Trivial scattering matrix</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># Collapse/Jump operators</span>
    <span class="n">L1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>                                    <span class="c"># Decay of cavity mode through mirror</span>
    <span class="n">L2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span>                                <span class="c"># Atomic decay due to spontaneous emission into outside modes.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="n">L1</span><span class="p">],</span> \
                <span class="p">[</span><span class="n">L2</span><span class="p">]])</span>

    <span class="c"># Hamilton operator</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">Delta</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma</span>                        <span class="c"># detuning from atomic resonance</span>
        <span class="o">+</span> <span class="n">Theta</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span>                               <span class="c"># detuning from cavity resonance</span>
        <span class="o">+</span> <span class="n">I</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>       <span class="c"># atom-mode coupling, I = sqrt(-1)</span>
        <span class="o">+</span> <span class="n">I</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()))</span>                      <span class="c"># external driving amplitude</span>

    <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>Consider now an example where we feed one Jaynes-Cummings system&#8217;s output into a second one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;Delta, Theta, epsilon, g&#39;</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">kappa</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;kappa, gamma&#39;</span><span class="p">)</span>

<span class="n">JC1</span> <span class="o">=</span> <span class="n">SLH_JaynesCummings</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;jc1&#39;</span><span class="p">)</span>
<span class="n">JC2</span> <span class="o">=</span> <span class="n">SLH_JaynesCummings</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">namespace</span> <span class="o">=</span> <span class="s">&#39;jc2&#39;</span><span class="p">)</span>

<span class="n">SYS</span> <span class="o">=</span> <span class="p">(</span><span class="n">JC2</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">P_sigma</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">JC1</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The resulting system&#8217;s block diagram is:</p>
<img alt="_images/circuit_example.png" src="_images/circuit_example.png" />
<p>and its overall SLH model is given by:</p>
<div class="math">
\[\begin{split}\left( \begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0\end{pmatrix}, \begin{pmatrix}  \sqrt{\kappa} {a_{{{\rm fock}}_{{\rm jc1}}}} +  \sqrt{\kappa} {a_{{{\rm fock}}_{{\rm jc2}}}} \\  \sqrt{\gamma} {\sigma_{{\rm g},{\rm e}}^{{{\rm tls}}_{{\rm jc2}}}} \\  \sqrt{\gamma} {\sigma_{{\rm g},{\rm e}}^{{{\rm tls}}_{{\rm jc1}}}}\end{pmatrix},  \Delta {\Pi_{{\rm e}}^{{{\rm tls}}_{{\rm jc1}}}} +  \Delta {\Pi_{{\rm e}}^{{{\rm tls}}_{{\rm jc2}}}} +  \mathbf{\imath} g \left({a_{{{\rm fock}}_{{\rm jc1}}}^\dagger} {\sigma_{{\rm g},{\rm e}}^{{{\rm tls}}_{{\rm jc1}}}} - {a_{{{\rm fock}}_{{\rm jc1}}}} {\sigma_{{\rm e},{\rm g}}^{{{\rm tls}}_{{\rm jc1}}}}\right) +  \mathbf{\imath} g \left({a_{{{\rm fock}}_{{\rm jc2}}}^\dagger} {\sigma_{{\rm g},{\rm e}}^{{{\rm tls}}_{{\rm jc2}}}} - {a_{{{\rm fock}}_{{\rm jc2}}}} {\sigma_{{\rm e},{\rm g}}^{{{\rm tls}}_{{\rm jc2}}}}\right) +  \frac{1}{2} \mathbf{\imath} \left( \sqrt{\kappa} \sqrt{\overline{\kappa}} {a_{{{\rm fock}}_{{\rm jc1}}}^\dagger} {a_{{{\rm fock}}_{{\rm jc2}}}} -  \sqrt{\kappa} \sqrt{\overline{\kappa}} {a_{{{\rm fock}}_{{\rm jc1}}}} {a_{{{\rm fock}}_{{\rm jc2}}}^\dagger}\right) +  \mathbf{\imath} \epsilon \left( -{a_{{{\rm fock}}_{{\rm jc1}}}^\dagger} + {a_{{{\rm fock}}_{{\rm jc1}}}}\right) +  \mathbf{\imath} \epsilon \left( -{a_{{{\rm fock}}_{{\rm jc2}}}^\dagger} + {a_{{{\rm fock}}_{{\rm jc2}}}}\right) +  \Theta {a_{{{\rm fock}}_{{\rm jc1}}}^\dagger} {a_{{{\rm fock}}_{{\rm jc1}}}} +  \Theta {a_{{{\rm fock}}_{{\rm jc2}}}^\dagger} {a_{{{\rm fock}}_{{\rm jc2}}}} \right)\end{split}\]</div>
</div>
</div>
<div class="section" id="the-super-operator-algebra-module">
<span id="super-operator-algebra"></span><h2>The Super-Operator Algebra module<a class="headerlink" href="#the-super-operator-algebra-module" title="Permalink to this headline">¶</a></h2>
<p>The specification of a quantum mechanics symbolic super-operator algebra.
Each super-operator has an associated <cite>space</cite> property which gives the Hilbert space
on which the operators the super-operator acts non-trivially are themselves acting non-trivially.</p>
<p>The most basic way to construct super-operators is by lifting &#8216;normal&#8217; operators to linear pre- and post-multiplication super-operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">),</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">),</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span>
<span class="go">    A * B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SPost</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span>
<span class="go">    B * C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">SPost</span><span class="p">(</span><span class="n">C</span><span class="p">))</span> <span class="o">*</span> <span class="n">B</span>
<span class="go">    A * B * C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">*</span> <span class="n">B</span>        <span class="c"># Linear super-operator associated with A that maps B --&gt; [A,B]</span>
<span class="go">    A * B - B * A</span>
</pre></div>
</div>
<p>There exist some useful constants to specify neutral elements of super-operator addition and multiplication:</p>
<blockquote>
<div><tt class="xref py py-class docutils literal"><span class="pre">ZeroSuperOperator</span></tt>
<tt class="xref py py-class docutils literal"><span class="pre">IdentitySuperOperator</span></tt></div></blockquote>
<p>Super operator objects can be added together in code via the infix &#8216;+&#8217; operator and multiplied with the infix &#8216;*&#8217; operator.
They can also be added to or multiplied by scalar objects.
In the first case, the scalar object is multiplied by the IdentitySuperOperator constant.</p>
<p>Super operators are applied to operators by multiplying an operator with superoperator from the left:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">SuperOperatorSymbol</span><span class="p">(</span><span class="s">&quot;S&quot;</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">*</span> <span class="n">A</span>
<span class="go">    SuperOperatorTimesOperator(S, A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>The result is an operator.</p>
</div>
<div class="section" id="the-state-ket-algebra-module">
<span id="state-algebra"></span><h2>The State (Ket-) Algebra module<a class="headerlink" href="#the-state-ket-algebra-module" title="Permalink to this headline">¶</a></h2>
<p>This module implements a basic Hilbert space state algebra where by default we represent states <span class="math">\(\psi\)</span> as &#8216;Ket&#8217; vectors <span class="math">\(\psi \to | \psi \rangle\)</span>.
However, any state can also be represented in its adjoint Bra form, since those representations are dual:</p>
<div class="math">
\[\psi \leftrightarrow | \psi \rangle \leftrightarrow \langle \psi |\]</div>
<p>States can be added to states of the same Hilbert space. They can be multiplied by:</p>
<ul class="simple">
<li>scalars, to just yield a rescaled state within the original space</li>
<li>operators that act on some of the states degrees of freedom (but none that aren&#8217;t part of the state&#8217;s Hilbert space)</li>
<li>other states that have a Hilbert space corresponding to a disjoint set of degrees of freedom</li>
</ul>
<p>Furthermore,</p>
<ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">Ket</span></tt> object can multiply a <tt class="docutils literal"><span class="pre">Bra</span></tt> of the same space from the left to yield a <tt class="docutils literal"><span class="pre">KetBra</span></tt> type operator.</li>
</ul>
<p>And conversely,</p>
<ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">Bra</span></tt> can multiply a <tt class="docutils literal"><span class="pre">Ket</span></tt> from the left to create a (partial) inner product object <tt class="docutils literal"><span class="pre">BraKet</span></tt>.
Currently, only full inner products are supported, i.e. the <tt class="docutils literal"><span class="pre">Ket</span></tt> and <tt class="docutils literal"><span class="pre">Bra</span></tt> operands need to have the same space.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="circuit_rules.html" title="Properties and Simplification of Circuit Algebraic Expressions"
             >next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Installation/Setup"
             >previous</a> |</li>
        <li><a href="index.html">QNET 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Nikolas Tezak.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>