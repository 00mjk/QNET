

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qnet.algebra.operator_algebra &mdash; QNET 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/mycss.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/mathjax_cancel.js"></script>
    <link rel="top" title="QNET 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for qnet.algebra.operator_algebra</h1><div class="highlight"><pre>
<span class="c">#This file is part of QNET.</span>
<span class="c">#</span>
<span class="c">#    QNET is free software: you can redistribute it and/or modify</span>
<span class="c">#    it under the terms of the GNU General Public License as published by</span>
<span class="c">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#   (at your option) any later version.</span>
<span class="c">#</span>
<span class="c">#    QNET is distributed in the hope that it will be useful,</span>
<span class="c">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#    GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c">#    You should have received a copy of the GNU General Public License</span>
<span class="c">#    along with QNET.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2012-2013, Nikolas Tezak</span>
<span class="c">#</span>
<span class="c">###########################################################################</span>

<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">Operator Algebra</span>
<span class="sd">================</span>

<span class="sd">This module features classes and functions to define and manipulate symbolic Operator expressions.</span>
<span class="sd">For more details see :ref:`operator_algebra`.</span>

<span class="sd">For a list of all properties and methods of an operator object, see the documentation for the basic :py:class:`Operator` class.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># TODO extend slightly, add code examples</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">qnet.algebra.abstract_algebra</span>
<span class="kn">from</span> <span class="nn">qnet.algebra.abstract_algebra</span> <span class="kn">import</span> <span class="n">singleton</span><span class="p">,</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span>\
    <span class="n">AlgebraError</span><span class="p">,</span> <span class="n">tex</span><span class="p">,</span> <span class="n">check_signature</span><span class="p">,</span> <span class="n">idem</span><span class="p">,</span> <span class="n">assoc</span><span class="p">,</span>\
    <span class="n">preprocess_create_with</span><span class="p">,</span> <span class="n">filter_neutral</span><span class="p">,</span> <span class="n">check_signature_assoc</span><span class="p">,</span>\
    <span class="n">match_replace</span><span class="p">,</span> <span class="n">match_replace_binary</span><span class="p">,</span> <span class="n">orderby</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="n">CannotSimplify</span><span class="p">,</span>\
    <span class="n">Expression</span><span class="p">,</span> <span class="n">set_union</span><span class="p">,</span> <span class="n">substitute</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">AlgebraException</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">Match</span><span class="p">,</span> <span class="n">PatternTuple</span><span class="p">,</span> <span class="n">OperandsTuple</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">qnet.algebra.hilbert_space_algebra</span> <span class="kn">import</span> <span class="n">HilbertSpace</span><span class="p">,</span> <span class="n">BasisRegistry</span><span class="p">,</span> <span class="n">BasisNotSetError</span><span class="p">,</span> <span class="n">LocalSpace</span><span class="p">,</span> <span class="n">local_space</span><span class="p">,</span> <span class="n">TrivialSpace</span><span class="p">,</span> <span class="n">FullSpace</span><span class="p">,</span> <span class="n">ProductSpace</span>
<span class="kn">from</span> <span class="nn">qnet.algebra.permutations</span> <span class="kn">import</span> <span class="n">check_permutation</span><span class="p">,</span> <span class="n">BadPermutationError</span><span class="p">,</span> <span class="n">invert_permutation</span><span class="p">,</span> <span class="n">full_block_perm</span><span class="p">,</span> <span class="n">block_perm_and_perms_within_blocks</span><span class="p">,</span> <span class="n">permutation_to_block_permutations</span><span class="p">,</span> <span class="n">concatenate_permutations</span><span class="p">,</span> <span class="n">permute</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span> <span class="k">as</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">izip</span>
<span class="kn">import</span> <span class="nn">qutip</span>

<span class="c">#noinspection PyUnresolvedReferences</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span>\
    <span class="n">acos</span><span class="p">,</span> <span class="n">asin</span><span class="p">,</span> <span class="n">acosh</span><span class="p">,</span> <span class="n">asinh</span><span class="p">,</span> <span class="n">atan</span><span class="p">,</span> <span class="n">atan2</span><span class="p">,</span> <span class="n">atanh</span><span class="p">,</span> <span class="n">acot</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span>\
    <span class="n">factorial</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Basic</span> <span class="k">as</span> <span class="n">SympyBasic</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">series</span> <span class="k">as</span> <span class="n">sympy_series</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">latex</span> <span class="k">as</span> <span class="n">sympy_latex</span>

<span class="c">#noinspection PyUnresolvedReferences</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">np_array</span><span class="p">,</span>\
    <span class="n">shape</span> <span class="k">as</span> <span class="n">np_shape</span><span class="p">,</span>\
    <span class="n">hstack</span> <span class="k">as</span> <span class="n">np_hstack</span><span class="p">,</span>\
    <span class="n">vstack</span> <span class="k">as</span> <span class="n">np_vstack</span><span class="p">,</span>\
    <span class="n">diag</span> <span class="k">as</span> <span class="n">np_diag</span><span class="p">,</span>\
    <span class="n">ones</span> <span class="k">as</span> <span class="n">np_ones</span><span class="p">,</span>\
    <span class="n">conjugate</span> <span class="k">as</span> <span class="n">np_conjugate</span><span class="p">,</span>\
    <span class="n">zeros</span> <span class="k">as</span> <span class="n">np_zeros</span><span class="p">,</span>\
    <span class="n">ndarray</span><span class="p">,</span>\
    <span class="n">arange</span><span class="p">,</span>\
    <span class="n">cos</span> <span class="k">as</span> <span class="n">np_cos</span><span class="p">,</span>\
    <span class="n">sin</span> <span class="k">as</span> <span class="n">np_sin</span><span class="p">,</span>\
    <span class="n">eye</span> <span class="k">as</span> <span class="n">np_eye</span><span class="p">,</span> <span class="n">argwhere</span>

<span class="n">sympyOne</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="adjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.adjoint">[docs]</a><span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the adjoint of an obj.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The basic operator class, which fixes the abstract interface of operator objects </span>
<span class="sd">    and where possible also defines the default behavior under operations.</span>
<span class="sd">    Any operator contains an associated HilbertSpace object, </span>
<span class="sd">    on which it is taken to act non-trivially.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>
    <span class="c"># which data types may serve as scalar coefficients</span>
    <span class="n">scalar_types</span> <span class="o">=</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">SympyBasic</span>


    <span class="nd">@property</span>
<div class="viewcode-block" id="Operator.space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.space">[docs]</a>    <span class="k">def</span> <span class="nf">space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Hilbert space associated with the operator on which it acts non-trivially</span>

<span class="sd">        :type: HilbertSpace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space</span>
</div>
    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Operator.adjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The Hermitian adjoint of the operator.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjoint</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Adjoint</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">conjugate</span> <span class="o">=</span> <span class="n">dag</span> <span class="o">=</span> <span class="n">adjoint</span>

<div class="viewcode-block" id="Operator.pseudo_inverse"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.pseudo_inverse">[docs]</a>    <span class="k">def</span> <span class="nf">pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The pseudo-Inverse of the Operator, i.e., it inverts the operator on the orthogonal complement of its nullspace</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_inverse</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PseudoInverse</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Operator.to_qutip"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.to_qutip">[docs]</a>    <span class="k">def</span> <span class="nf">to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a numerical representation of the operator as a QuTiP object.</span>
<span class="sd">        Note that all symbolic scalar parameters need to be replaced by numerical values before calling this method.</span>

<span class="sd">        :param full_space: The full Hilbert space in which to represent the operator.</span>
<span class="sd">        :type full_space: HilbertSpace</span>
<span class="sd">        :return: The matrix representation of the operator.</span>
<span class="sd">        :rtype: qutip.Qobj (:py:class:`qutip.Qobj`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">full_space</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span>

<div class="viewcode-block" id="Operator.expand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand out distributively all products of sums. Note that this does not expand out sums of scalar coefficients.</span>
<span class="sd">        :return: A fully expanded sum of operators.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">()</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Operator.series_expand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.series_expand">[docs]</a>    <span class="k">def</span> <span class="nf">series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the operator expression as a truncated power series in a scalar parameter.</span>

<span class="sd">        :param param: Expansion parameter.</span>
<span class="sd">        :type param: sympy.core.symbol.Symbol</span>
<span class="sd">        :param about: Point about which to expand.</span>
<span class="sd">        :type about:  Any one of Operator.scalar_types</span>
<span class="sd">        :param order: Maximum order of expansion.</span>
<span class="sd">        :type order: int &gt;= 0</span>
<span class="sd">        :return: tuple of length (order+1), where the entries are the expansion coefficients.</span>
<span class="sd">        :rtype: tuple of Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">*</span> <span class="n">IdentityOperator</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">__radd__</span> <span class="o">=</span> <span class="n">__add__</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="n">sympyOne</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="bp">self</span><span class="p">,)</span> <span class="o">*</span> <span class="n">other</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="Operator.simplify_scalars"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Operator.simplify_scalars">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#TODO implement</span>
        <span class="k">pass</span>

</div></div>
<div class="viewcode-block" id="space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.space">[docs]</a><span class="k">def</span> <span class="nf">space</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives the associated HilbertSpace with an object. Also works for :py:attr:`Operator.scalar_types`.</span>

<span class="sd">    :type obj: Operator or Operator.scalar_types</span>
<span class="sd">    :rtype: HilbertSpace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">space</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TrivialSpace</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

</div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="OperatorSymbol"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorSymbol">[docs]</a><span class="k">class</span> <span class="nc">OperatorSymbol</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator Symbol class, parametrized by an identifier string and an associated Hilbert space.</span>

<span class="sd">        ``OperatorSymbol(name, hs)``</span>

<span class="sd">    :param name: Symbol identifier</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param hs: Associated Hilbert space.</span>
<span class="sd">    :type hs: HilbertSpace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="n">HilbertSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">hs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="c">#noinspection PyArgumentList</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">OperatorSymbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">local_space</span><span class="p">(</span><span class="n">hs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c">#noinspection PyArgumentList</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">OperatorSymbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prod</span><span class="p">([</span><span class="n">local_space</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">],</span> <span class="n">neutral</span><span class="o">=</span><span class="n">TrivialSpace</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#noinspection PyArgumentList</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">OperatorSymbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">identifier_to_tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&quot;Cannot convert operator symbol to representation matrix. Substitute first.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">}</span>

</div>
<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">IdentityOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``IdentityOperator`` constant (singleton) object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>

    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">full_space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()])</span>

    <span class="c">#    def mathematica(self):</span>
    <span class="c">#        return &quot;IdentityOperator&quot;</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;1&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;1&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(())</span>


<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">ZeroOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``ZeroOperator`` constant (singleton) object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>

    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">((),</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">full_space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;0&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;0&quot;</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(())</span>


<span class="k">def</span> <span class="nf">_implied_local_space_mtd</span><span class="p">(</span><span class="n">dcls</span><span class="p">,</span> <span class="n">clsmtd</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For Operations whose first operand is a local space, accept ``int`` or ``str`` arguments and convert these to a ``LocalSpace`` via :py:func:`qnet.algebra.hilbert_space_algebra.local_space`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">clsmtd</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">local_space</span><span class="p">(</span><span class="n">space</span><span class="p">),</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clsmtd</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>

<span class="n">implied_local_space</span> <span class="o">=</span> <span class="n">preprocess_create_with</span><span class="p">(</span><span class="n">_implied_local_space_mtd</span><span class="p">)</span>

<div class="viewcode-block" id="LocalOperator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.LocalOperator">[docs]</a><span class="k">class</span> <span class="nc">LocalOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all kinds of operators that act *locally*,</span>
<span class="sd">    i.e. only on a single degree of freedom.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">full_space</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">full_space</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_qutip_local_factor</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_spaces</span> <span class="o">=</span> <span class="n">full_space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()</span>
            <span class="n">own_space_index</span> <span class="o">=</span> <span class="n">all_spaces</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_spaces</span><span class="p">[:</span><span class="n">own_space_index</span><span class="p">]]</span>
                                  <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">to_qutip_local_factor</span><span class="p">()]</span>
                                  <span class="o">+</span> <span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_spaces</span><span class="p">[</span><span class="n">own_space_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]))</span>

<div class="viewcode-block" id="LocalOperator.to_qutip_local_factor"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.LocalOperator.to_qutip_local_factor">[docs]</a>    <span class="k">def</span> <span class="nf">to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Return a qutip representation for the local operator only on its local space.</span>
<span class="sd">        :rtype: qutip.Qobj</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_qutip_local_factor</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(())</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Create">[docs]</a><span class="k">class</span> <span class="nc">Create</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``Create(space)`` yields a bosonic creation operator acting on a particular local space/degree of freedom.</span>
<span class="sd">    Its adjoint is</span>

<span class="sd">        &gt;&gt;&gt; Create(1).adjoint()</span>
<span class="sd">            Destroy(1)</span>

<span class="sd">    and it obeys the bosonic commutation relation</span>

<span class="sd">        &gt;&gt;&gt; Destroy(1) * Create(1) - Create(1) * Destroy(1)</span>
<span class="sd">            1</span>
<span class="sd">        &gt;&gt;&gt; Destroy(1) * Create(2) - Create(2) * Destroy(1)</span>
<span class="sd">            1</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{a_{{{}}}^\dagger}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;(a_{!s})^*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Destroy"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Destroy">[docs]</a><span class="k">class</span> <span class="nc">Destroy</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``Destroy(space)`` yields a bosonic annihilation operator acting on a particular local space/degree of freedom.</span>
<span class="sd">    Its adjoint is</span>

<span class="sd">        &gt;&gt;&gt; Destroy(1).adjoint()</span>
<span class="sd">            Create(1)</span>

<span class="sd">    and it obeys the bosonic commutation relation</span>

<span class="sd">        &gt;&gt;&gt; Destroy(1) * Create(1) - Create(1) * Destroy(1)</span>
<span class="sd">            1</span>
<span class="sd">        &gt;&gt;&gt; Destroy(1) * Create(2) - Create(2) * Destroy(1)</span>
<span class="sd">            1</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{a_{{{}}}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;a_{!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Phase"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Phase">[docs]</a><span class="k">class</span> <span class="nc">Phase</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The unitary Phase operator acting on a particular local space/degree of freedom:</span>

<span class="sd">    .. math::</span>

<span class="sd">        P_{\rm s}(\phi):= \exp\left(i \phi a_{\rm s}^\dagger a_{\rm s}\right)</span>

<span class="sd">    where :math:`a_{\rm s}` is the annihilation operator acting on the local space s.</span>
<span class="sd">    Use as:</span>

<span class="sd">        ``Phase(space, phi)``</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    :param phi: Displacement amplitude.</span>
<span class="sd">    :type phi: Any from `Operator.scalar_types`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># TODO implement _series_expand for the phase parameter</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np_cos</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">np_sin</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np_diag</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{P_{{{}}}({})}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">(),</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;P_{!s}({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Displace"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Displace">[docs]</a><span class="k">class</span> <span class="nc">Displace</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Unitary coherent displacement operator</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_{\rm s}(\alpha) := \exp\left({\alpha a_{\rm s}^\dagger - \alpha^* a_{\rm s}}\right)</span>

<span class="sd">    where :math:`a_{\rm s}` is the annihilation operator acting on the local space s.</span>
<span class="sd">    Use as:</span>

<span class="sd">        ``Displace(space, alpha)``</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    :param alpha: Displacement amplitude.</span>
<span class="sd">    :type alpha: Any from `Operator.scalar_types`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># TODO implement _series_expand for the coherent displacement parameter</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">_pseudo_inverse</span> <span class="o">=</span> <span class="n">_adjoint</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{D_{{{}}}({})}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">(),</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;D_{!s}({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Squeeze"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Squeeze">[docs]</a><span class="k">class</span> <span class="nc">Squeeze</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    A unitary Squeezing operator acting on a particular local space/degree of freedom:</span>

<span class="sd">    .. math::</span>

<span class="sd">        S_{\rm s}(\eta) := \exp {\left( \frac{\eta}{2} {a_{\rm s}^\dagger}^2 - \frac{\eta^*}{2} {a_{\rm s}}^2 \right)}</span>

<span class="sd">    where :math:`a_{\rm s}` is the annihilation operator acting on the local space s.</span>
<span class="sd">    Use as:</span>

<span class="sd">        ``Squeeze(space, eta)``</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    :param eta: Squeeze parameter.</span>
<span class="sd">    :type eta: Any from `Operator.scalar_types`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># TODO implement _series_expand for the squeeze parameter</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">displace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">_pseudo_inverse</span> <span class="o">=</span> <span class="n">_adjoint</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{S_{{{}}}({})}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">(),</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;S_{!s}({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="LocalSigma"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.LocalSigma">[docs]</a><span class="k">class</span> <span class="nc">LocalSigma</span><span class="p">(</span><span class="n">LocalOperator</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    A local level flip operator operator acting on a particular local space/degree of freedom.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \sigma_{jk}^{\rm s} := \left| j\right\rangle_{\rm s} \left \langle k \right |_{\rm s}</span>

<span class="sd">    Use as:</span>

<span class="sd">        ``LocalSigma(space, j, k)``</span>

<span class="sd">    :param space: Associated local Hilbert space.</span>
<span class="sd">    :type space: LocalSpace or str</span>
<span class="sd">    :param j: State label j.</span>
<span class="sd">    :type j: int or str</span>
<span class="sd">    :param k: State label k.</span>
<span class="sd">    :type k: int or str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">LocalSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_qutip_local_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">ket</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">bra</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ket</span> <span class="o">*</span> <span class="n">bra</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">r&quot;{{\Pi_{{{}}}^{{{}}}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>
        <span class="k">return</span> <span class="s">r&quot;{{\sigma_{{{},{}}}^{{{}}}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">tex</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;Pi_{!s}^[{!s}]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;sigma_{!s}{!s}^[{!s}]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

</div>
<span class="n">LocalProjector</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">spc</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">LocalSigma</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">spc</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>


<div class="viewcode-block" id="X"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.X">[docs]</a><span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Pauli-type X-operator</span>

<span class="sd">    :param local_space: Associated Hilbert space.</span>
<span class="sd">    :type local_space: LocalSpace</span>
<span class="sd">    :param states: The qubit state labels for the basis states :math:`\left\{|0\rangle, |1\rangle \right\}`, where :math:`Z|0\rangle = +|0\rangle`, default = ``(&#39;h&#39;, &#39;g&#39;)``.</span>
<span class="sd">    :type states: tuple with two elements of type int or str</span>
<span class="sd">    :return: Local X-operator.</span>
<span class="sd">    :rtype: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">states</span>
    <span class="k">return</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Y"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Y">[docs]</a><span class="k">def</span> <span class="nf">Y</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Pauli-type Y-operator</span>

<span class="sd">    :param local_space: Associated Hilbert space.</span>
<span class="sd">    :type local_space: LocalSpace</span>
<span class="sd">    :param states: The qubit state labels for the basis states :math:`\left\{|0\rangle, |1\rangle \right\}`, where :math:`Z|0\rangle = +|0\rangle`, default = ``(&#39;h&#39;, &#39;g&#39;)``.</span>
<span class="sd">    :type states: tuple with two elements of type int or str</span>
<span class="sd">    :return: Local Y-operator.</span>
<span class="sd">    :rtype: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">states</span>
    <span class="k">return</span> <span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="Z"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Z">[docs]</a><span class="k">def</span> <span class="nf">Z</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Pauli-type Z-operator</span>

<span class="sd">    :param local_space: Associated Hilbert space.</span>
<span class="sd">    :type local_space: LocalSpace</span>
<span class="sd">    :param states: The qubit state labels for the basis states :math:`\left\{|0\rangle, |1\rangle \right\}`, where :math:`Z|0\rangle = +|0\rangle`, default = ``(&#39;h&#39;, &#39;g&#39;)``.</span>
<span class="sd">    :type states: tuple with two elements of type int or str</span>
<span class="sd">    :return: Local Z-operator.</span>
<span class="sd">    :rtype: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">states</span>
    <span class="k">return</span> <span class="n">LocalProjector</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="n">LocalProjector</span><span class="p">(</span><span class="n">local_space</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="OperatorOperation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorOperation">[docs]</a><span class="k">class</span> <span class="nc">OperatorOperation</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Operations acting only on Operator arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">TrivialSpace</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="tuple_sum"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.tuple_sum">[docs]</a><span class="k">def</span> <span class="nf">tuple_sum</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">inital</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">tels</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">tels</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">tuples</span><span class="p">))</span>

</div>
<span class="nd">@assoc</span>
<span class="nd">@orderby</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="OperatorPlus"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorPlus">[docs]</a><span class="k">class</span> <span class="nc">OperatorPlus</span><span class="p">(</span><span class="n">OperatorOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sum of Operators</span>

<span class="sd">        ``OperatorPlus(*summands)``</span>

<span class="sd">    :param summands: Operator summands.</span>
<span class="sd">    :type summands: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neutral_element</span> <span class="o">=</span> <span class="n">ZeroOperator</span>
    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="OperatorPlus.order_key"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorPlus.order_key">[docs]</a>    <span class="k">def</span> <span class="nf">order_key</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">term</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">coeff</span>
        <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">1</span>
</div>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">full_space</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">full_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">&lt;=</span> <span class="n">full_space</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">op</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroOperator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tuple_sum</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">has_minus_prefactor</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="n">tex</span><span class="p">(</span><span class="o">-</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">has_minus_prefactor</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

</div>
<span class="nd">@assoc</span>
<span class="nd">@orderby</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="OperatorTimes"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes">[docs]</a><span class="k">class</span> <span class="nc">OperatorTimes</span><span class="p">(</span><span class="n">OperatorOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A product of Operators that serves both as a product within a Hilbert space as well as a tensor product.</span>

<span class="sd">        ``OperatorTimes(*factors)``</span>

<span class="sd">    :param factors: Operator factors.</span>
<span class="sd">    :type factors: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neutral_element</span> <span class="o">=</span> <span class="n">IdentityOperator</span>
    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="OperatorTimes.OperatorOrderKey"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes.OperatorOrderKey">[docs]</a>    <span class="k">class</span> <span class="nc">OperatorOrderKey</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auxiliary class that generates the correct pseudo-order relation for operator products.</span>
<span class="sd">        Only operators acting on different Hilbert spaces are commuted to achieve the order specified in the full HilbertSpace.</span>
<span class="sd">        I.e., sorted(factors, key = OperatorOrderKey) achieves this ordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">LocalSpace</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="p">}</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">TrivialSpace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">FullSpace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">operands</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">operands</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

</div>
    <span class="n">order_key</span> <span class="o">=</span> <span class="n">OperatorOrderKey</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="OperatorTimes.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="n">ZeroOperator</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ZeroOperator</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">ops</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="OperatorTimes.factor_for_space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTimes.factor_for_space">[docs]</a>    <span class="k">def</span> <span class="nf">factor_for_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spc</span> <span class="o">==</span> <span class="n">TrivialSpace</span><span class="p">:</span>
            <span class="n">ops_on_spc</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="ow">is</span> <span class="n">TrivialSpace</span><span class="p">]</span>
            <span class="n">ops_not_on_spc</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">TrivialSpace</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops_on_spc</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">&amp;</span> <span class="n">spc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TrivialSpace</span><span class="p">]</span>
            <span class="n">ops_not_on_spc</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">&amp;</span> <span class="n">spc</span><span class="p">)</span> <span class="ow">is</span> <span class="n">TrivialSpace</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">ops_on_spc</span><span class="p">),</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">ops_not_on_spc</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># if any factor acts non-locally, we need to expand distributively.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">space</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
            <span class="n">se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">se</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot represent as QuTiP object: {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">se</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full_space</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">full_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>

        <span class="n">all_spaces</span> <span class="o">=</span> <span class="n">full_space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()</span>
        <span class="n">by_space</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ck</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">all_spaces</span><span class="p">:</span>
            <span class="c"># group factors by associated local space</span>
            <span class="n">ls_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">ls</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls_ops</span><span class="p">):</span>
                <span class="c"># compute factor associated with local space</span>
                <span class="n">by_space</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">ls_ops</span><span class="p">))</span>
                <span class="n">ck</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls_ops</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># if trivial action, take identity matrix</span>
                <span class="n">by_space</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">ls</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">ck</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
        <span class="c"># combine local factors in tensor product</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="n">by_space</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eops</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">]</span>
        <span class="c"># store tuples of summands of all expanded factors</span>
        <span class="n">eopssummands</span> <span class="o">=</span> <span class="p">[</span><span class="n">eo</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eo</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">eo</span><span class="p">,)</span> <span class="k">for</span> <span class="n">eo</span> <span class="ow">in</span> <span class="n">eops</span><span class="p">]</span>
        <span class="c"># iterate over a cartesian product of all factor summands, form product of each tuple and sum over result</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">combo</span><span class="p">)</span> <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">eopssummands</span><span class="p">)),</span> <span class="n">ZeroOperator</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">cfirst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="n">crest</span> <span class="o">=</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">cfirst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">crest</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot; \left({}\right) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot; ({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="ScalarTimesOperator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ScalarTimesOperator">[docs]</a><span class="k">class</span> <span class="nc">ScalarTimesOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply an operator by a scalar coefficient.</span>

<span class="sd">        ``ScalarTimesOperator(coefficient, term)``</span>

<span class="sd">    :param coefficient: Scalar coefficient.</span>
<span class="sd">    :type coefficient: Any of Operator.scalar_types</span>
<span class="sd">    :param term: The operator that is multiplied.</span>
<span class="sd">    :type term: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">,</span> <span class="n">Operator</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ScalarTimesOperator.has_minus_prefactor"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ScalarTimesOperator.has_minus_prefactor">[docs]</a>    <span class="k">def</span> <span class="nf">has_minus_prefactor</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a scalar object c, determine whether it is prepended by a &quot;-&quot; sign.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span>

</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="ScalarTimesOperator.coeff"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ScalarTimesOperator.coeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScalarTimesOperator.term"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ScalarTimesOperator.term">[docs]</a>    <span class="k">def</span> <span class="nf">term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

</div>
    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot; \left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">coeff</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">coeff</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">term</span> <span class="ow">is</span> <span class="n">IdentityOperator</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; \left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot;({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot; {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">IdentityOperator</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; ({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>


    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">et</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">eto</span> <span class="k">for</span> <span class="n">eto</span> <span class="ow">in</span> <span class="n">et</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroOperator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">et</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">te</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SympyBasic</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">about</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">param</span><span class="p">:</span> <span class="n">about</span> <span class="o">+</span> <span class="n">param</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span>
            <span class="n">ce</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">sympy_series</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ce</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ce</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ce</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">ce</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">te</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">tek</span> <span class="k">for</span> <span class="n">tek</span> <span class="ow">in</span> <span class="n">te</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">pseudo_inverse</span><span class="p">()</span> <span class="o">/</span> <span class="n">c</span>


    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="ow">is</span> <span class="n">IdentityOperator</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="ow">is</span> <span class="n">IdentityOperator</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="ow">is</span> <span class="n">IdentityOperator</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ScalarTimesOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_map</span><span class="p">):</span>
        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">var_map</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">SympyBasic</span><span class="p">):</span>
            <span class="n">svar_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">Expression</span><span class="p">)}</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">svar_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">substitute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sc</span> <span class="o">*</span> <span class="n">st</span>

</div>
<div class="viewcode-block" id="safe_tex"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.safe_tex">[docs]</a><span class="k">def</span> <span class="nf">safe_tex</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">format_number_for_tex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">SympyBasic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sympy_latex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;$&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">r&quot;{\rm &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;}&quot;</span>

</div>
<span class="n">tex</span> <span class="o">=</span> <span class="n">qnet</span><span class="o">.</span><span class="n">algebra</span><span class="o">.</span><span class="n">abstract_algebra</span><span class="o">.</span><span class="n">tex</span> <span class="o">=</span> <span class="n">safe_tex</span>

<div class="viewcode-block" id="format_number_for_tex"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.format_number_for_tex">[docs]</a><span class="k">def</span> <span class="nf">format_number_for_tex</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#also True for 0., 0j</span>
        <span class="k">return</span> <span class="s">&quot;0&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">real</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&quot;i&quot;</span>
            <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&quot;(-i)&quot;</span>
            <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&quot;(-</span><span class="si">%s</span><span class="s">i)&quot;</span> <span class="o">%</span> <span class="n">format_number_for_tex</span><span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">i&quot;</span> <span class="o">%</span> <span class="n">format_number_for_tex</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">format_number_for_tex</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s">i)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">format_number_for_tex</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">real</span><span class="p">),</span> <span class="n">format_number_for_tex</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%g</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">num</span>
    <span class="k">return</span> <span class="s">&quot;</span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">num</span>

<span class="c">#</span>
<span class="c">#def format_number_for_mathematica(num):</span>
<span class="c">#    if num == 0: #also True for 0., 0j</span>
<span class="c">#        return &quot;0&quot;</span>
<span class="c">#    if isinstance(num, complex):</span>
<span class="c">#        if num.imag == 0:</span>
<span class="c">#            return format_number_for_tex(num.real)</span>
<span class="c">#        return &quot;Complex[%g,%g]&quot; % (num.real, num.imag)</span>
<span class="c">#</span>
<span class="c">#    return &quot;%g&quot; % num</span>
<span class="c">#</span>


</div>
<span class="n">greek_letter_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;alpha&quot;</span><span class="p">,</span> <span class="s">&quot;beta&quot;</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="s">&quot;delta&quot;</span><span class="p">,</span> <span class="s">&quot;epsilon&quot;</span><span class="p">,</span> <span class="s">&quot;varepsilon&quot;</span><span class="p">,</span>
                        <span class="s">&quot;zeta&quot;</span><span class="p">,</span> <span class="s">&quot;eta&quot;</span><span class="p">,</span> <span class="s">&quot;theta&quot;</span><span class="p">,</span> <span class="s">&quot;vartheta&quot;</span><span class="p">,</span> <span class="s">&quot;iota&quot;</span><span class="p">,</span> <span class="s">&quot;kappa&quot;</span><span class="p">,</span>
                        <span class="s">&quot;lambda&quot;</span><span class="p">,</span> <span class="s">&quot;mu&quot;</span><span class="p">,</span> <span class="s">&quot;nu&quot;</span><span class="p">,</span> <span class="s">&quot;xi&quot;</span><span class="p">,</span> <span class="s">&quot;pi&quot;</span><span class="p">,</span> <span class="s">&quot;varpi&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span>
                        <span class="s">&quot;varrho&quot;</span><span class="p">,</span> <span class="s">&quot;sigma&quot;</span><span class="p">,</span> <span class="s">&quot;varsigma&quot;</span><span class="p">,</span> <span class="s">&quot;tau&quot;</span><span class="p">,</span> <span class="s">&quot;upsilon&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span>
                        <span class="s">&quot;varphi&quot;</span><span class="p">,</span> <span class="s">&quot;chi&quot;</span><span class="p">,</span> <span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="s">&quot;omega&quot;</span><span class="p">,</span>
                        <span class="s">&quot;Gamma&quot;</span><span class="p">,</span> <span class="s">&quot;Delta&quot;</span><span class="p">,</span> <span class="s">&quot;Theta&quot;</span><span class="p">,</span> <span class="s">&quot;Lambda&quot;</span><span class="p">,</span> <span class="s">&quot;Xi&quot;</span><span class="p">,</span>
                        <span class="s">&quot;Pi&quot;</span><span class="p">,</span> <span class="s">&quot;Sigma&quot;</span><span class="p">,</span> <span class="s">&quot;Upsilon&quot;</span><span class="p">,</span> <span class="s">&quot;Phi&quot;</span><span class="p">,</span> <span class="s">&quot;Psi&quot;</span><span class="p">,</span> <span class="s">&quot;Omega&quot;</span><span class="p">]</span>
<span class="n">greekToLatex</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;alpha&quot;</span><span class="p">:</span> <span class="s">&quot;Alpha&quot;</span><span class="p">,</span> <span class="s">&quot;beta&quot;</span><span class="p">:</span> <span class="s">&quot;Beta&quot;</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">:</span> <span class="s">&quot;Gamma&quot;</span><span class="p">,</span> <span class="s">&quot;delta&quot;</span><span class="p">:</span> <span class="s">&quot;Delta&quot;</span><span class="p">,</span> <span class="s">&quot;epsilon&quot;</span><span class="p">:</span> <span class="s">&quot;Epsilon&quot;</span><span class="p">,</span>
                <span class="s">&quot;varepsilon&quot;</span><span class="p">:</span> <span class="s">&quot;Epsilon&quot;</span><span class="p">,</span>
                <span class="s">&quot;zeta&quot;</span><span class="p">:</span> <span class="s">&quot;Zeta&quot;</span><span class="p">,</span> <span class="s">&quot;eta&quot;</span><span class="p">:</span> <span class="s">&quot;Eta&quot;</span><span class="p">,</span> <span class="s">&quot;theta&quot;</span><span class="p">:</span> <span class="s">&quot;Theta&quot;</span><span class="p">,</span> <span class="s">&quot;vartheta&quot;</span><span class="p">:</span> <span class="s">&quot;Theta&quot;</span><span class="p">,</span> <span class="s">&quot;iota&quot;</span><span class="p">:</span> <span class="s">&quot;Iota&quot;</span><span class="p">,</span> <span class="s">&quot;kappa&quot;</span><span class="p">:</span> <span class="s">&quot;Kappa&quot;</span><span class="p">,</span>
                <span class="s">&quot;lambda&quot;</span><span class="p">:</span> <span class="s">&quot;Lambda&quot;</span><span class="p">,</span> <span class="s">&quot;mu&quot;</span><span class="p">:</span> <span class="s">&quot;Mu&quot;</span><span class="p">,</span> <span class="s">&quot;nu&quot;</span><span class="p">:</span> <span class="s">&quot;Nu&quot;</span><span class="p">,</span> <span class="s">&quot;xi&quot;</span><span class="p">:</span> <span class="s">&quot;Xi&quot;</span><span class="p">,</span> <span class="s">&quot;pi&quot;</span><span class="p">:</span> <span class="s">&quot;Pi&quot;</span><span class="p">,</span> <span class="s">&quot;varpi&quot;</span><span class="p">:</span> <span class="s">&quot;Pi&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">:</span> <span class="s">&quot;Rho&quot;</span><span class="p">,</span>
                <span class="s">&quot;varrho&quot;</span><span class="p">:</span> <span class="s">&quot;Rho&quot;</span><span class="p">,</span> <span class="s">&quot;sigma&quot;</span><span class="p">:</span> <span class="s">&quot;Sigma&quot;</span><span class="p">,</span> <span class="s">&quot;varsigma&quot;</span><span class="p">:</span> <span class="s">&quot;Sigma&quot;</span><span class="p">,</span> <span class="s">&quot;tau&quot;</span><span class="p">:</span> <span class="s">&quot;Tau&quot;</span><span class="p">,</span> <span class="s">&quot;upsilon&quot;</span><span class="p">:</span> <span class="s">&quot;Upsilon&quot;</span><span class="p">,</span>
                <span class="s">&quot;phi&quot;</span><span class="p">:</span> <span class="s">&quot;Phi&quot;</span><span class="p">,</span>
                <span class="s">&quot;varphi&quot;</span><span class="p">:</span> <span class="s">&quot;Phi&quot;</span><span class="p">,</span> <span class="s">&quot;chi&quot;</span><span class="p">:</span> <span class="s">&quot;Chi&quot;</span><span class="p">,</span> <span class="s">&quot;psi&quot;</span><span class="p">:</span> <span class="s">&quot;Psi&quot;</span><span class="p">,</span> <span class="s">&quot;omega&quot;</span><span class="p">:</span> <span class="s">&quot;Omega&quot;</span><span class="p">,</span>
                <span class="s">&quot;Gamma&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalGamma&quot;</span><span class="p">,</span> <span class="s">&quot;Delta&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalDelta&quot;</span><span class="p">,</span> <span class="s">&quot;Theta&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalTheta&quot;</span><span class="p">,</span> <span class="s">&quot;Lambda&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalLambda&quot;</span><span class="p">,</span>
                <span class="s">&quot;Xi&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalXi&quot;</span><span class="p">,</span>
                <span class="s">&quot;Pi&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalPi&quot;</span><span class="p">,</span> <span class="s">&quot;Sigma&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalSigma&quot;</span><span class="p">,</span> <span class="s">&quot;Upsilon&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalUpsilon&quot;</span><span class="p">,</span> <span class="s">&quot;Phi&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalPhi&quot;</span><span class="p">,</span>
                <span class="s">&quot;Psi&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalPsi&quot;</span><span class="p">,</span> <span class="s">&quot;Omega&quot;</span><span class="p">:</span> <span class="s">&quot;CapitalOmega&quot;</span>
<span class="p">}</span>

<span class="kn">import</span> <span class="nn">re</span>

<span class="n">_idtp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?!</span><span class="se">\\</span><span class="s">)({})(\b|_)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">greek_letter_strings</span><span class="p">)))</span>

<div class="viewcode-block" id="identifier_to_tex"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.identifier_to_tex">[docs]</a><span class="k">def</span> <span class="nf">identifier_to_tex</span><span class="p">(</span><span class="n">identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If an identifier contains a greek symbol name as a separate word, (e.g. ``my_alpha_1`` contains ``alpha`` as a separate word, but ``alphaman`` doesn&#39;t) add a backslash in front.</span>

<span class="sd">    :param identifier: The string to prepare for LaTeX printing</span>
<span class="sd">    :type identifier: str</span>
<span class="sd">    :returns: An improved version where greek letter symbols can be correctly rendered.</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#    identifier = creduce(lambda a,b: &quot;{%s_%s}&quot; % (b, a), [&quot;{%s}&quot; % part for part in reversed(identifier.split(&quot;_&quot;))])</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">_idtp</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r&#39;{</span><span class="se">\\</span><span class="s">\1}\2&#39;</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>

</div>
<span class="nd">@check_signature</span>
<span class="nd">@match_replace</span>
<div class="viewcode-block" id="Adjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Adjoint">[docs]</a><span class="k">class</span> <span class="nc">Adjoint</span><span class="p">(</span><span class="n">OperatorOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The symbolic Adjoint of an operator.</span>

<span class="sd">        ``Adjoint(op)``</span>

<span class="sd">    :param op: The operator to take the adjoint of.</span>
<span class="sd">    :type op: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Adjoint.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Adjoint.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">dag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">ope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">adjoint</span><span class="p">(</span><span class="n">opet</span><span class="p">)</span> <span class="k">for</span> <span class="n">opet</span> <span class="ow">in</span> <span class="n">ope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eo</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">adjoint</span><span class="p">(</span><span class="n">eoo</span><span class="p">)</span> <span class="k">for</span> <span class="n">eoo</span> <span class="ow">in</span> <span class="n">eo</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroOperator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eo</span><span class="o">.</span><span class="n">_adjoint</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">pseudo_inverse</span><span class="p">()</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;\left(&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span> <span class="o">+</span> <span class="s">r&quot;\right)^\dagger&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">OperatorSymbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&quot;{}^*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&quot;({})^*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>

<span class="c"># for hilbert space dimensions less than or equal to this,</span>
<span class="c"># compute numerically PseudoInverse and NullSpaceProjector representations</span></div>
<span class="n">DENSE_DIMENSION_LIMIT</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="nd">@check_signature</span>
<span class="nd">@match_replace</span>
<div class="viewcode-block" id="PseudoInverse"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.PseudoInverse">[docs]</a><span class="k">class</span> <span class="nc">PseudoInverse</span><span class="p">(</span><span class="n">OperatorOperation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The symbolic pseudo-inverse :math:`X^+` of an operator :math:`X`. It is defined via the relationship</span>

<span class="sd">    .. math::</span>

<span class="sd">        X X^+ X =  X  \\</span>
<span class="sd">        X^+ X X^+ =  X^+  \\</span>
<span class="sd">        (X^+ X)^\dagger = X^+ X  \\</span>
<span class="sd">        (X X^+)^\dagger = X X^+</span>

<span class="sd">    Use as:</span>

<span class="sd">        ``PseudoInverse(X)``</span>

<span class="sd">    :param X: The operator to take the adjoint of.</span>
<span class="sd">    :type X: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delegate_to_method</span> <span class="o">=</span> <span class="n">ScalarTimesOperator</span><span class="p">,</span> <span class="n">Squeeze</span><span class="p">,</span> <span class="n">Displace</span><span class="p">,</span> <span class="n">ZeroOperator</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">IdentityOperator</span><span class="o">.</span><span class="n">__class__</span>

    <span class="c"># TODO implement _series_expand</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="PseudoInverse.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.PseudoInverse.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">delegate_to_method</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">_pseudo_inverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PseudoInverse</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PseudoInverse.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.PseudoInverse.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_space</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&lt;=</span> <span class="n">DENSE_DIMENSION_LIMIT</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">pinv</span>

            <span class="n">piarr</span> <span class="o">=</span> <span class="n">pinv</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">pimo</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">piarr</span><span class="p">)</span>
            <span class="n">pimo</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">pimo</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">isherm</span>
            <span class="n">pimo</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&#39;oper&#39;</span>
            <span class="k">return</span> <span class="n">pimo</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Only implemented for smaller state spaces&quot;</span><span class="p">)</span>

        <span class="c">#        return qutip.dag(self.operands[0].to_qutip(full_space))</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_pseudo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;\left(&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span> <span class="o">+</span> <span class="s">r&quot;\right)^+&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">OperatorSymbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&quot;{}^+&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&quot;({})^+&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
</div>
<span class="n">PseudoInverse</span><span class="o">.</span><span class="n">delegate_to_method</span> <span class="o">=</span> <span class="n">PseudoInverse</span><span class="o">.</span><span class="n">delegate_to_method</span> <span class="o">+</span> <span class="p">(</span><span class="n">PseudoInverse</span><span class="p">,)</span>


<span class="nd">@check_signature</span>
<span class="nd">@match_replace</span>
<div class="viewcode-block" id="NullSpaceProjector"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.NullSpaceProjector">[docs]</a><span class="k">class</span> <span class="nc">NullSpaceProjector</span><span class="p">(</span><span class="n">OperatorOperation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns a projection operator :math:`\mathcal{P}_{{\rm Ker} X}` that projects onto the nullspace of its operand</span>

<span class="sd">    .. math::</span>

<span class="sd">        X \mathcal{P}_{{\rm Ker} X} = 0 \Leftrightarrow  X (1 - \mathcal{P}_{{\rm Ker} X}) = X\\</span>
<span class="sd">        \mathcal{P}_{{\rm Ker} X}^\dagger = \mathcal{P}_{{\rm Ker} X} = \mathcal{P}_{{\rm Ker} X}^2</span>

<span class="sd">    Use as:</span>

<span class="sd">        ``NullSpaceProjector(X)``</span>

<span class="sd">    :param X: Operator argument</span>
<span class="sd">    :type X: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># TODO implement _series_expand</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="NullSpaceProjector.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.NullSpaceProjector.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NullSpaceProjector.to_qutip"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.NullSpaceProjector.to_qutip">[docs]</a>    <span class="k">def</span> <span class="nf">to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_space</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&lt;=</span> <span class="n">DENSE_DIMENSION_LIMIT</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svd</span>
            <span class="c"># compute Singular Value Decomposition</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-8</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zero_svs</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="n">Vhzero</span> <span class="o">=</span> <span class="n">Vh</span><span class="p">[</span><span class="n">zero_svs</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">PKarr</span> <span class="o">=</span> <span class="n">Vhzero</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vhzero</span><span class="p">)</span>
            <span class="n">PKmo</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">PKarr</span><span class="p">)</span>
            <span class="n">PKmo</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">dims</span>
            <span class="n">PKmo</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">PKmo</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&#39;oper&#39;</span>
            <span class="k">return</span> <span class="n">PKmo</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Only implemented for smaller state spaces&quot;</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\mathcal{P}_{{\rm Ker}&quot;</span> <span class="o">+</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;}&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;P_ker({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>

</div>
<span class="nd">@implied_local_space</span>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="OperatorTrace"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.OperatorTrace">[docs]</a><span class="k">class</span> <span class="nc">OperatorTrace</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Take the (partial) trace of an operator :math:`X` over the degrees of freedom given by a Hilbert space :math:`\mathcal{H}`:</span>

<span class="sd">    .. math::</span>

<span class="sd">        {\rm Tr}_{\mathcal{H}} X</span>

<span class="sd">    Use as:</span>

<span class="sd">        ``OperatorTrace(space, X)``</span>

<span class="sd">    :param space: The degrees of freedom to trace over</span>
<span class="sd">    :type space: HilbertSpace</span>
<span class="sd">    :param X: The operator to take the trace of.</span>
<span class="sd">    :type X: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">HilbertSpace</span><span class="p">,</span> <span class="n">Operator</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">space</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorTrace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">over_space</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span> <span class="o">/</span> <span class="n">over_space</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">ope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opet</span><span class="p">)</span> <span class="k">for</span> <span class="n">opet</span> <span class="ow">in</span> <span class="n">ope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="s">r&quot;{{\rm Tr}}_{{{}}} \left[ {} \right]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="s">r&quot;tr_{!s}[{!s}]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="c"># TODO import OperatorTrace._to_qutip()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

</div>
<span class="n">tr</span> <span class="o">=</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span>

<div class="viewcode-block" id="factor_for_trace"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.factor_for_trace">[docs]</a><span class="k">def</span> <span class="nf">factor_for_trace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Given a local space ls to take the partial trace over and an operator, factor the trace such that operators acting on</span>
<span class="sd">    disjoint degrees of freedom are pulled out of the trace. If the operator acts trivially on ls the trace yields only</span>
<span class="sd">    a pre-factor equal to the dimension of ls. If there are LocalSigma operators among a product, the trace&#39;s cyclical property</span>
<span class="sd">    is used to move to sandwich the full product by :py:class:`LocalSigma` operators:</span>

<span class="sd">    .. math::</span>

<span class="sd">        {\rm Tr} A \sigma_{jk} B = {\rm Tr} \sigma_{jk} B A \sigma_{jj}</span>

<span class="sd">    :param ls: Degree of Freedom to trace over</span>
<span class="sd">    :type ls: HilbertSpace</span>
<span class="sd">    :param op: Operator to take the trace of</span>
<span class="sd">    :type op: Operator</span>
<span class="sd">    :return: The (partial) trace over the operator&#39;s spc-degrees of freedom</span>
<span class="sd">    :rtype: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">ls</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">OperatorTimes</span><span class="p">):</span>
            <span class="n">pull_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="ow">is</span> <span class="n">TrivialSpace</span><span class="p">]</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">TrivialSpace</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pull_out</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">pull_out</span><span class="p">)</span> <span class="o">*</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ls</span> <span class="o">&amp;</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">TrivialSpace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ls</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="n">op</span>
    <span class="k">if</span> <span class="n">ls</span> <span class="o">&lt;</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">OperatorTimes</span><span class="p">):</span>
        <span class="n">pull_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">&amp;</span> <span class="n">ls</span><span class="p">)</span> <span class="o">==</span> <span class="n">TrivialSpace</span><span class="p">]</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="o">&amp;</span> <span class="n">ls</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TrivialSpace</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rest</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LocalSigma</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rest</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">LocalSigma</span><span class="p">):</span>
            <span class="n">found_ls</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rest</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">LocalSigma</span><span class="p">):</span>
                    <span class="n">found_ls</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found_ls</span><span class="p">:</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">+</span> <span class="n">rest</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rest</span><span class="p">:</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">IdentityOperator</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pull_out</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">pull_out</span><span class="p">)</span> <span class="o">*</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">))</span>
    <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="decompose_space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.decompose_space">[docs]</a><span class="k">def</span> <span class="nf">decompose_space</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies OperatorTrace expressions over tensor-product spaces by turning it into iterated partial traces.</span>
<span class="sd">    :param H: The full space.</span>
<span class="sd">    :type H: ProductSpace</span>
<span class="sd">    :type A: Operator</span>
<span class="sd">    :return: Iterative partial trace expression</span>
<span class="sd">    :rtype: Operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ProductSpace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">))</span>


<span class="c">## Expression rewriting _rules</span></div>
<span class="n">u</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">A__</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A__&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">A___</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A___&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">B__</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B__&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">B___</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B___&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">Operator</span><span class="p">)</span>

<span class="n">A_plus</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">OperatorPlus</span><span class="p">)</span>
<span class="n">A_times</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">OperatorTimes</span><span class="p">)</span>
<span class="n">A_local</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">LocalOperator</span><span class="p">)</span>
<span class="n">B_local</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">LocalOperator</span><span class="p">)</span>

<span class="n">ls</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">LocalSpace</span><span class="p">)</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">HilbertSpace</span><span class="p">)</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;h2&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">HilbertSpace</span><span class="p">)</span>
<span class="n">H_ProductSpace</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;H&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">ProductSpace</span><span class="p">)</span>

<span class="n">ra</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;ra&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
<span class="n">rb</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;rb&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
<span class="n">rc</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;rc&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
<span class="n">rd</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;rd&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

<span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">ZeroOperator</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">OperatorPlus</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">OperatorTimes</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">),</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">:</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">rb</span> <span class="o">==</span> <span class="n">rc</span> <span class="k">else</span> <span class="n">ZeroOperator</span><span class="p">),</span>

    <span class="p">((</span><span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rd</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rd</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">),</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">),</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">IdentityOperator</span> <span class="o">+</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Phase</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
     <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">exp</span><span class="p">((</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Displace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">),</span> <span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">*</span> <span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="p">(</span><span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="o">*</span> <span class="n">Displace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span>

    <span class="p">((</span><span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">Phase</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">Adjoint</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()),</span>
    <span class="p">((</span><span class="n">A_plus</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">OperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">operands</span><span class="p">])),</span>
    <span class="p">((</span><span class="n">A_times</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">OperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">operands</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])),</span>
    <span class="p">((</span><span class="n">Adjoint</span><span class="p">(</span><span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">:</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">ra</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">Displace</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">IdentityOperator</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">Phase</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">IdentityOperator</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">Squeeze</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">IdentityOperator</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">OperatorTrace</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">TrivialSpace</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
    <span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">ZeroOperator</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">h1</span><span class="p">:</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">IdentityOperator</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">h1</span><span class="p">:</span> <span class="n">h1</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="n">IdentityOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">A_plus</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">h1</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">operands</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">Adjoint</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">h1</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">Adjoint</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">A</span><span class="p">))),</span>
    <span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">h1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="n">OperatorTrace</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">H_ProductSpace</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">H</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">decompose_space</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="n">Create</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="n">Destroy</span><span class="p">(</span><span class="n">ls</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">IdentityOperator</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span> <span class="k">else</span> <span class="n">ZeroOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ls</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">factor_for_trace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">PseudoInverse</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">LocalSigma</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span>
<span class="p">]</span>


<div class="viewcode-block" id="NonSquareMatrix"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.NonSquareMatrix">[docs]</a><span class="k">class</span> <span class="nc">NonSquareMatrix</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


</div>
<div class="viewcode-block" id="Matrix"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix">[docs]</a><span class="k">class</span> <span class="nc">Matrix</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix with Operator (or scalar-) valued elements.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_hash</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np_array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np_array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>


    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.shape"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.shape">[docs]</a>    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of the matrix ``(nrows, ncols)``</span>

<span class="sd">        :type: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.block_structure"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.block_structure">[docs]</a>    <span class="k">def</span> <span class="nf">block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For square matrices this gives the block (-diagonal) structure of the matrix as a</span>
<span class="sd">        tuple of integers that sum up to the full dimension.</span>

<span class="sd">        :type: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;block_structure only defined for square matrices&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">k</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">:]</span><span class="o">.</span><span class="n">block_structure</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">,</span>
</div>
    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">sum</span><span class="p">(</span><span class="n">block_structure</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_structure</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">block_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="n">j</span><span class="p">],)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">j</span><span class="p">:]</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">block_structure</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_structure</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="n">block_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:],)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[:</span><span class="n">block_structure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">block_structure</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span>


    <span class="c">#    @_trace</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="n">sympyOne</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

    <span class="c">#    def __pow__(self, power):</span>
    <span class="c">#        return OperatorMatrix(self.matrix.__pow__(power))</span>

<div class="viewcode-block" id="Matrix.transpose"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The transpose matrix</span>
<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matrix.conjugate"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.conjugate">[docs]</a>    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The element-wise conjugate matrix, i.e., if an element is an operator this means the adjoint operator,</span>
<span class="sd">        but no transposition of matrix elements takes place.</span>
<span class="sd">        :return: Element-wise hermitian conjugate matrix.</span>
<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.T"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.T">[docs]</a>    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Transpose matrix</span>
<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Matrix.adjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the adjoint operator matrix, i.e. transpose and the Hermitian adjoint operators of all elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
</div>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">adjoint</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{}({!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{}({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

<div class="viewcode-block" id="Matrix.trace"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">raise</span> <span class="n">NonSquareMatrix</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.H"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.H">[docs]</a>    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the adjoint operator matrix, i.e. transpose and the Hermitian adjoint operators of all elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span>

</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_id</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>

<div class="viewcode-block" id="Matrix.element_wise"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.element_wise">[docs]</a>    <span class="k">def</span> <span class="nf">element_wise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a method to each matrix element and return the result in a new operator matrix of the same shape.</span>
<span class="sd">        :param method: A method taking a single argument.</span>
<span class="sd">        :type method: FunctionType</span>
<span class="sd">        :return: Operator matrix with results of method applied element-wise.</span>
<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">emat</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np_array</span><span class="p">(</span><span class="n">emat</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="Matrix.expand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand each matrix element distributively.</span>
<span class="sd">        :return: Expanded matrix.</span>
<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="k">else</span> <span class="n">o</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_wise</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_map</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">_substitute</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">var_map</span><span class="p">):</span>
            <span class="n">sympy_var_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">SympyBasic</span><span class="p">)}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">substitute</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SympyBasic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sympy_var_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">o</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_wise</span><span class="p">(</span><span class="n">_substitute</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">set_union</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s">r&quot;\begin{pmatrix} &quot;</span>
        <span class="c">#        for row in self.matrix:</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot;&quot;&quot; \\ &quot;&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">])</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot;\end{pmatrix}&quot;</span>

        <span class="k">return</span> <span class="n">ret</span>


    <span class="nd">@property</span>
<div class="viewcode-block" id="Matrix.space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Matrix.space">[docs]</a>    <span class="k">def</span> <span class="nf">space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the combined Hilbert space of all matrix elements.</span>

<span class="sd">        :type: HilbertSpace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="n">space</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">TrivialSpace</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="hstack"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.hstack">[docs]</a><span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalizes `numpy.hstack` to OperatorMatrix objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np_hstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">matrix</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">)))</span>

</div>
<div class="viewcode-block" id="vstack"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.vstack">[docs]</a><span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalizes `numpy.vstack` to OperatorMatrix objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np_vstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">matrix</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">))</span>
    <span class="c">#    print tuple(m.matrix.dtype for m in matrices)</span>
    <span class="c">#    print arr.dtype</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalizes the diagonal matrix creation capabilities of `numpy.diag` to OperatorMatrix objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np_diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="block_matrix"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.block_matrix">[docs]</a><span class="k">def</span> <span class="nf">block_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate the operator matrix with quadrants</span>

<span class="sd">    .. math::</span>

<span class="sd">       \begin{pmatrix} A B \\ C D \end{pmatrix}</span>

<span class="sd">    :param A: Matrix of shape ``(n, m)``</span>
<span class="sd">    :type A: Matrix</span>
<span class="sd">    :param B: Matrix of shape ``(n, k)``</span>
<span class="sd">    :type B: Matrix</span>
<span class="sd">    :param C: Matrix of shape ``(l, m)``</span>
<span class="sd">    :type C: Matrix</span>
<span class="sd">    :param D: Matrix of shape ``(l, k)``</span>
<span class="sd">    :type D: Matrix</span>

<span class="sd">    :return: The combined block matrix [[A, B], [C, D]].</span>
<span class="sd">    :type: OperatorMatrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vstack</span><span class="p">((</span><span class="n">hstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)),</span> <span class="n">hstack</span><span class="p">((</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))))</span>

</div>
<div class="viewcode-block" id="identity_matrix"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.identity_matrix">[docs]</a><span class="k">def</span> <span class="nf">identity_matrix</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the N-dimensional identity matrix.</span>

<span class="sd">    :param N: Dimension</span>
<span class="sd">    :type N: int</span>
<span class="sd">    :return: Identity matrix in N dimensions</span>
<span class="sd">    :rtype: Matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="n">np_ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="zeros"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.zeros">[docs]</a><span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalizes ``numpy.zeros`` to :py:class:`Matrix` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">np_zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="permutation_matrix"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.permutation_matrix">[docs]</a><span class="k">def</span> <span class="nf">permutation_matrix</span><span class="p">(</span><span class="n">permutation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return an orthogonal permutation matrix</span>
<span class="sd">    :math:`M_\sigma`</span>
<span class="sd">    for a permutation :math:`\sigma` defined by the image tuple</span>
<span class="sd">    :math:`(\sigma(1), \sigma(2),\dots \sigma(n))`,</span>
<span class="sd">    such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        M_\sigma \vec{e}_i = \vec{e}_{\sigma(i)}</span>

<span class="sd">    where :math:`\vec{e}_k` is the k-th standard basis vector.</span>
<span class="sd">    This definition ensures a composition law:</span>

<span class="sd">    .. math::</span>

<span class="sd">        M_{\sigma \cdot \tau} = M_\sigma M_\tau.</span>

<span class="sd">    The column form of :math:`M_\sigma` is thus given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        M = (\vec{e}_{\sigma(1)}, \vec{e}_{\sigma(2)}, \dots \vec{e}_{\sigma(n)}).</span>

<span class="sd">    :param permutation: A permutation image tuple (zero-based indices!)</span>
<span class="sd">    :type permutation: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">check_permutation</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="n">op_matrix</span> <span class="o">=</span> <span class="n">np_zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">permutation</span><span class="p">):</span>
        <span class="n">op_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">op_matrix</span><span class="p">)</span>

<span class="c"># :deprecated:</span>
<span class="c"># for backwards compatibility</span></div>
<span class="n">OperatorMatrixInstance</span> <span class="o">=</span> <span class="n">Matrix</span>
<span class="n">IdentityMatrix</span> <span class="o">=</span> <span class="n">identity_matrix</span>

<div class="viewcode-block" id="Im"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Im">[docs]</a><span class="k">def</span> <span class="nf">Im</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The imaginary part of a number or operator. Acting on OperatorMatrices, it produces the element-wise imaginary parts.</span>
<span class="sd">    :param op: Anything that has a conjugate method.</span>
<span class="sd">    :type op: Operator or Matrix or any of Operator.scalar_types</span>
<span class="sd">    :return: The imaginary part of the operand.</span>
<span class="sd">    :rtype: Same as type of `op`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">-</span> <span class="n">op</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span> <span class="o">/</span> <span class="mi">2</span>

</div>
<div class="viewcode-block" id="Re"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.Re">[docs]</a><span class="k">def</span> <span class="nf">Re</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The real part of a number or operator. Acting on OperatorMatrices, it produces the element-wise real parts.</span>
<span class="sd">    :param op: Anything that has a conjugate method.</span>
<span class="sd">    :type op: Operator or Matrix or any of Operator.scalar_types</span>
<span class="sd">    :return: The real part of the operand.</span>
<span class="sd">    :rtype: Same as type of `op`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> <span class="n">op</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

</div>
<div class="viewcode-block" id="ImAdjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ImAdjoint">[docs]</a><span class="k">def</span> <span class="nf">ImAdjoint</span><span class="p">(</span><span class="n">opmatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The imaginary part of an OperatorMatrix, i.e. a hermitian OperatorMatrix</span>
<span class="sd">    :param opmatrix: The operand.</span>
<span class="sd">    :type opmatrix: Matrix</span>
<span class="sd">    :return: The matrix imaginary part of the operand.</span>
<span class="sd">    :rtype: Matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">opmatrix</span><span class="o">.</span><span class="n">H</span> <span class="o">-</span> <span class="n">opmatrix</span><span class="p">)</span> <span class="o">*</span> <span class="n">I</span> <span class="o">/</span> <span class="mi">2</span>

</div>
<div class="viewcode-block" id="ReAdjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.operator_algebra.ReAdjoint">[docs]</a><span class="k">def</span> <span class="nf">ReAdjoint</span><span class="p">(</span><span class="n">opmatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The real part of an OperatorMatrix, i.e. a hermitian OperatorMatrix</span>
<span class="sd">    :param opmatrix: The operand.</span>
<span class="sd">    :type opmatrix: Matrix</span>
<span class="sd">    :return: The matrix real part of the operand.</span>
<span class="sd">    :rtype: Matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">opmatrix</span><span class="o">.</span><span class="n">H</span> <span class="o">+</span> <span class="n">opmatrix</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Nikolas Tezak.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>