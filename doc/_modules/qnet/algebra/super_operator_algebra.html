

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qnet.algebra.super_operator_algebra &mdash; QNET 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/mycss.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/mathjax_cancel.js"></script>
    <link rel="top" title="QNET 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for qnet.algebra.super_operator_algebra</h1><div class="highlight"><pre>
<span class="c">#This file is part of QNET.</span>
<span class="c">#</span>
<span class="c">#    QNET is free software: you can redistribute it and/or modify</span>
<span class="c">#    it under the terms of the GNU General Public License as published by</span>
<span class="c">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#   (at your option) any later version.</span>
<span class="c">#</span>
<span class="c">#    QNET is distributed in the hope that it will be useful,</span>
<span class="c">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#    GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c">#    You should have received a copy of the GNU General Public License</span>
<span class="c">#    along with QNET.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2012-2013, Nikolas Tezak</span>
<span class="c">#</span>
<span class="c">###########################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Super-Operator Algebra</span>
<span class="sd">======================</span>

<span class="sd">The specification of a quantum mechanics symbolic super-operator algebra.</span>
<span class="sd">See :ref:`super_operator_algebra` for more details.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">operator_algebra</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span> <span class="k">as</span> <span class="n">SympyMatrix</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span> <span class="k">as</span> <span class="n">np_sqrt</span>

<div class="viewcode-block" id="SuperOperator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperator">[docs]</a><span class="k">class</span> <span class="nc">SuperOperator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The super-operator abstract base class.</span>

<span class="sd">    Any super-operator contains an associated HilbertSpace object,</span>
<span class="sd">    on which it is taken to act non-trivially.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="c"># which data types may serve as scalar coefficients</span>
    <span class="n">scalar_types</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span>


    <span class="nd">@property</span>
<div class="viewcode-block" id="SuperOperator.space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperator.space">[docs]</a>    <span class="k">def</span> <span class="nf">space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Hilbert space associated with the operator on which it acts non-trivially</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space</span>
</div>
    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="SuperOperator.superadjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperator.superadjoint">[docs]</a>    <span class="k">def</span> <span class="nf">superadjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The super-operator adjoint (w.r.t to the ``Tr`` operation).</span>
<span class="sd">        See :py:class:`SuperAdjoint` documentation.</span>

<span class="sd">        :return: The super-adjoint of the super-operator.</span>
<span class="sd">        :rtype: SuperOperator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superadjoint</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_superadjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SuperAdjoint</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="SuperOperator.to_qutip"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperator.to_qutip">[docs]</a>    <span class="k">def</span> <span class="nf">to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a numerical representation of the super-operator as a QuTiP object.</span>
<span class="sd">        Note that all symbolic scalar parameters need to be replaced by numerical values before calling this method.</span>

<span class="sd">        :param full_space: The full Hilbert space in which to represent the superoperator.</span>
<span class="sd">        :type full_space: HilbertSpace</span>
<span class="sd">        :return: The matrix representation of the superoperator.</span>
<span class="sd">        :rtype: qutip.Qobj</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">full_space</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">full_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span>

<div class="viewcode-block" id="SuperOperator.expand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperator.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand out distributively all products of sums. Note that this does not expand out sums of scalar coefficients.</span>

<span class="sd">        :return: A fully expanded sum of superoperators.</span>
<span class="sd">        :rtype: SuperOperator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">()</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="c">#TODO implement SuperOperator.series_expand()</span>

<span class="c">#    def series_expand(self, param, about, order):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Expand the superoperator expression as a truncated power series in a scalar parameter.</span>
<span class="c">#        :param param: Expansion parameter.</span>
<span class="c">#        :type param: sympy.core.symbol.Symbol</span>
<span class="c">#        :param about: Point about which to expand.</span>
<span class="c">#        :type about:  Any one of Operator.scalar_types</span>
<span class="c">#        :param order: Maximum order of expansion.</span>
<span class="c">#        :type order: int &gt;= 0</span>
<span class="c">#        :return: tuple of length (order + 1) featuring the contributions at different orders in the parameters</span>
<span class="c">#        :rtype: tuple of SuperOperator</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        return self._series_expand(param, about, order)</span>
<span class="c">#</span>
<span class="c">#    @abstractmethod</span>
<span class="c">#    def _series_expand(self, param, about, order):</span>
<span class="c">#        raise NotImplementedError(self.__class__.__name__)</span>


    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SuperOperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">*</span> <span class="n">IdentitySuperOperator</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SuperOperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">__radd__</span> <span class="o">=</span> <span class="n">__add__</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ScalarTimesSuperOperator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SuperOperatorTimesOperator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SuperOperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ScalarTimesSuperOperator</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperOperator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="n">sympyOne</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>



</div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="SuperOperatorSymbol"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorSymbol">[docs]</a><span class="k">class</span> <span class="nc">SuperOperatorSymbol</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Super-operator symbol class, parametrized by an identifier string and an associated Hilbert space.</span>

<span class="sd">    Instantiate as::</span>

<span class="sd">        SuperOperatorSymbol(name, hs)</span>

<span class="sd">    :param name: Symbol identifier</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param hs: Associated Hilbert space.</span>
<span class="sd">    :type hs: HilbertSpace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="n">HilbertSpace</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">hs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">local_space</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">prod</span><span class="p">([</span><span class="n">local_space</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">],</span> <span class="n">neutral</span><span class="o">=</span><span class="n">TrivialSpace</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SuperOperatorSymbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\hat{{{}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">identifier_to_tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&quot;Cannot convert super-operator symbol to representation matrix. Substitute first.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="c">#    def _series_expand(self, param, about, order):</span>
<span class="c">#        return (self,) + (() * order)</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">}</span>

</div>
<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">IdentitySuperOperator</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IdentitySuperOperator constant (singleton) object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>

    <span class="k">def</span> <span class="nf">_superadjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">spre</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">full_space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()]))</span>


    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="c">#    def _series_expand(self, param, about, order):</span>
<span class="c">#        return (self,) + (() * order)</span>


    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\hat{1}&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;_1_&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(())</span>





<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">ZeroSuperOperator</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ZeroSuperOperator constant (singleton) object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>

    <span class="k">def</span> <span class="nf">_superadjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">spre</span><span class="p">(</span><span class="n">ZeroOperator</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="c">#    def _series_expand(self, param, about, order):</span>
<span class="c">#        return (self,) + (() * order)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\hat{0}&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;_0_&quot;</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(())</span>


<div class="viewcode-block" id="SuperOperatorOperation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorOperation">[docs]</a><span class="k">class</span> <span class="nc">SuperOperatorOperation</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Operations acting only on SuperOperator arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">SuperOperator</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">TrivialSpace</span><span class="p">)</span>



</div>
<span class="nd">@assoc</span>
<span class="nd">@orderby</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="SuperOperatorPlus"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorPlus">[docs]</a><span class="k">class</span> <span class="nc">SuperOperatorPlus</span><span class="p">(</span><span class="n">SuperOperatorOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sum of super-operators.</span>

<span class="sd">    Instantiate as::</span>

<span class="sd">        OperatorPlus(*summands)</span>

<span class="sd">    :param SuperOperator summands: super-operator summands.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neutral_element</span> <span class="o">=</span> <span class="n">ZeroSuperOperator</span>
    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SuperOperatorPlus.order_key"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorPlus.order_key">[docs]</a>    <span class="k">def</span> <span class="nf">order_key</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">term</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">coeff</span>
        <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">1</span>
</div>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">full_space</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">full_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">&lt;=</span> <span class="n">full_space</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">op</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroSuperOperator</span><span class="p">)</span>

<span class="c">#    def _series_expand(self, param, about, order):</span>
<span class="c">#        res = tuple_sum((o.series_expand(param, about, order) for o in self.operands), ZeroSuperOperator)</span>
<span class="c">#        return res</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">has_minus_prefactor</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="n">tex</span><span class="p">(</span><span class="o">-</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ScalarTimesOperator</span><span class="o">.</span><span class="n">has_minus_prefactor</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


</div>
<span class="nd">@assoc</span>
<span class="nd">@orderby</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="SuperOperatorTimes"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimes">[docs]</a><span class="k">class</span> <span class="nc">SuperOperatorTimes</span><span class="p">(</span><span class="n">SuperOperatorOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A product of super-operators that denotes order of application of super-operators (right to left)::</span>

<span class="sd">        SuperOperatorTimes(*factors)</span>

<span class="sd">    :param SuperOperator factors: Super-operator factors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neutral_element</span> <span class="o">=</span> <span class="n">IdentitySuperOperator</span>
    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SuperOperatorTimes.SuperOperatorOrderKey"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimes.SuperOperatorOrderKey">[docs]</a>    <span class="k">class</span> <span class="nc">SuperOperatorOrderKey</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auxiliary class that generates the correct pseudo-order relation for operator products.</span>
<span class="sd">        Only operators acting on different Hilbert spaces are commuted to achieve the order specified in the full HilbertSpace.</span>
<span class="sd">        I.e., sorted(factors, key = OperatorOrderKey) achieves this ordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">space</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">space</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">LocalSpace</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="p">{</span><span class="n">space</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="p">}</span>
            <span class="k">elif</span> <span class="n">space</span> <span class="ow">is</span> <span class="n">TrivialSpace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">space</span> <span class="ow">is</span> <span class="n">FullSpace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">operands</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">operands</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">SPre</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">SPost</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">SPost</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">SPre</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trivial</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">)</span> <span class="o">==</span> <span class="n">Operation</span><span class="o">.</span><span class="n">order_key</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_spaces</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">local_spaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

</div>
    <span class="n">order_key</span> <span class="o">=</span> <span class="n">SuperOperatorOrderKey</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SuperOperatorTimes.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimes.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="n">ZeroSuperOperator</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ZeroSuperOperator</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">ops</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="n">ops_qutip</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">(</span><span class="n">ops_qutip</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eops</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">]</span>
        <span class="c"># store tuples of summands of all expanded factors</span>
        <span class="n">eopssummands</span> <span class="o">=</span> <span class="p">[</span><span class="n">eo</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eo</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">eo</span><span class="p">,)</span> <span class="k">for</span> <span class="n">eo</span> <span class="ow">in</span> <span class="n">eops</span><span class="p">]</span>
        <span class="c"># iterate over a cartesian product of all factor summands, form product of each tuple and sum over result</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">SuperOperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">combo</span><span class="p">)</span> <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">eopssummands</span><span class="p">)),</span> <span class="n">ZeroSuperOperator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot; \left({}\right) &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">r&quot; ({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="ScalarTimesSuperOperator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator">[docs]</a><span class="k">class</span> <span class="nc">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply an operator by a scalar coefficient::</span>

<span class="sd">        ScalarTimesOperator(coefficient, term)</span>

<span class="sd">    :param coefficient: Scalar coefficient.</span>
<span class="sd">    :type coefficient: Any of SuperOperator.scalar_types</span>
<span class="sd">    :param term: The super-operator that is multiplied.</span>
<span class="sd">    :type term: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">SuperOperator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">,</span> <span class="n">SuperOperator</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="ScalarTimesSuperOperator.coeff"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.coeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScalarTimesSuperOperator.term"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.term">[docs]</a>    <span class="k">def</span> <span class="nf">term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

</div>
    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot;\left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">coeff</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot;{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">coeff</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">IdentitySuperOperator</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; \left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot;({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot;{!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">IdentitySuperOperator</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; ({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>


    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">et</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">eto</span> <span class="k">for</span> <span class="n">eto</span> <span class="ow">in</span> <span class="n">et</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroSuperOperator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">et</span>

<span class="c">#    def _pseudo_inverse(self):</span>
<span class="c">#        c, t = self.operands</span>
<span class="c">#        return t.pseudo_inverse() / c</span>


    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="ow">is</span> <span class="n">IdentitySuperOperator</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="ow">is</span> <span class="n">IdentitySuperOperator</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>


</div>
<span class="nd">@check_signature</span>
<span class="nd">@match_replace</span>
<div class="viewcode-block" id="SuperAdjoint"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperAdjoint">[docs]</a><span class="k">class</span> <span class="nc">SuperAdjoint</span><span class="p">(</span><span class="n">SuperOperatorOperation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The symbolic SuperAdjoint of a super-operator.</span>

<span class="sd">    Use as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        SuperAdjoint(L)``</span>

<span class="sd">     For the super-operator :math:`\mathcal{L}`, its super-adjoint :math:`\mathcal{L}^*` satisfies for any pair of operators :math:`M,N`:</span>

<span class="sd">    .. math::</span>
<span class="sd">        {\rm Tr}(M (LN)) == Tr((SuperAdjoint(L)*M) * N)``</span>


<span class="sd">    :param sop: The super-operator to take the adjoint of.</span>
<span class="sd">    :type sop: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SuperAdjoint.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperAdjoint.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;SuperAdjoint({!s}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eo</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">eoo</span><span class="o">.</span><span class="n">superadjoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">eoo</span> <span class="ow">in</span> <span class="n">eo</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">ZeroSuperOperator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eo</span><span class="o">.</span><span class="n">_superadjoint</span><span class="p">()</span>

<span class="c">#    def _pseudo_inverse(self):</span>
<span class="c">#        return self.operand.pseudo_inverse().superadjoint()</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;\left(&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">()</span> <span class="o">+</span> <span class="s">r&quot;\right)^*&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">OperatorSymbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&quot;{}^*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&quot;({})^*&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="SPre"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SPre">[docs]</a><span class="k">class</span> <span class="nc">SPre</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear pre-multiplication operator.</span>

<span class="sd">    Use as::</span>

<span class="sd">        SPre(op)</span>

<span class="sd">    Acting ``SPre(A)`` on an operator ``B`` just yields the product ``A * B``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">,</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">spre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{\rm spre}}\left[{}\right]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;spre({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oe</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">SPre</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">oet</span><span class="p">)</span> <span class="k">for</span> <span class="n">oet</span> <span class="ow">in</span> <span class="n">oe</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SPre</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">oe</span><span class="p">)</span>

</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="SPost"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SPost">[docs]</a><span class="k">class</span> <span class="nc">SPost</span><span class="p">(</span><span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Linear post-multiplication operator.</span>

<span class="sd">        Use as::</span>

<span class="sd">            SPost(op)</span>

<span class="sd">        Acting ``SPost(A)`` on an operator ``B`` just yields the reversed product ``B * A``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">,</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>

    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">spost</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;{{\rm spost}}\left[{}\right]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;spost({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oe</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">SPost</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">oet</span><span class="p">)</span> <span class="k">for</span> <span class="n">oet</span> <span class="ow">in</span> <span class="n">oe</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SPost</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">oe</span><span class="p">)</span>

</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="SuperOperatorTimesOperator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator">[docs]</a><span class="k">class</span> <span class="nc">SuperOperatorTimesOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Application of a super-operator to an operator (result is an Operator).</span>

<span class="sd">    Use as::</span>

<span class="sd">        SuperOperatorTimesOperator(sop, op)</span>

<span class="sd">    :param SuperOperator sop: The super-operator to apply.</span>
<span class="sd">    :param Operator op: The operator it is applied to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">SuperOperator</span><span class="p">,</span> <span class="n">Operator</span>
    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sop</span><span class="o">.</span><span class="n">space</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">space</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SuperOperatorTimesOperator.sop"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.sop">[docs]</a>    <span class="k">def</span> <span class="nf">sop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SuperOperatorTimesOperator.op"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.op">[docs]</a>    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

</div>
    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sop</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sop</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot; \left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">sop</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">sop</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; \left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sop</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sop</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">r&quot;({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">sop</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="s">&quot;{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="n">sop</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; ({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="s">r&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cs</span> <span class="o">+</span> <span class="n">ct</span>


    <span class="k">def</span> <span class="nf">_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span><span class="p">):</span>
        <span class="n">sop</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="k">return</span> <span class="n">sop</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span> <span class="o">*</span> <span class="n">op</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sop</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">sope</span><span class="p">,</span> <span class="n">ope</span> <span class="o">=</span> <span class="n">sop</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">op</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sope</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
            <span class="n">sopet</span> <span class="o">=</span> <span class="n">sope</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sopet</span> <span class="o">=</span> <span class="n">sope</span><span class="p">,</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ope</span><span class="p">,</span> <span class="n">OperatorPlus</span><span class="p">):</span>
            <span class="n">opet</span> <span class="o">=</span> <span class="n">ope</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">opet</span> <span class="o">=</span> <span class="n">ope</span><span class="p">,</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">st</span> <span class="o">*</span> <span class="n">ot</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">sopet</span> <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="n">opet</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_series_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">sop</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">ope</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">series_expand</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">about</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sop</span> <span class="o">*</span> <span class="n">opet</span> <span class="k">for</span> <span class="n">opet</span> <span class="ow">in</span> <span class="n">ope</span><span class="p">)</span>

<span class="c">#    def _pseudo_inverse(self):</span>
<span class="c">#        c, t = self.operands</span>
<span class="c">#        return t.pseudo_inverse() / c</span>


<span class="c">#@check_signature</span>
<span class="c">#@match_replace</span>
<span class="c">#class PseudoInverse(OperatorOperation):</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    The symbolic pseudo-inverse of an operator.</span>
<span class="c">#        PseudoInverse(op)</span>
<span class="c">#    :param op: The operator to take the adjoint of.</span>
<span class="c">#    :type op: Operator</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    delegate_to_method = ScalarTimesOperator, Squeeze, Displace, ZeroOperator.__class__, IdentityOperator.__class__</span>
<span class="c">#</span>
<span class="c">#    @classmethod</span>
<span class="c">#    def create(cls, op):</span>
<span class="c">#        if isinstance(op, cls.delegate_to_method):</span>
<span class="c">#            return op._pseudo_inverse()</span>
<span class="c">#        return super(PseudoInverse, cls).create(op)</span>
<span class="c">#</span>
<span class="c">#    @property</span>
<span class="c">#    def operand(self):</span>
<span class="c">#        return self.operands[0]</span>
<span class="c">#</span>
<span class="c">#    _rules = []</span>
<span class="c">#</span>
<span class="c">#    def _to_qutip(self, full_space=None):</span>
<span class="c">#        mo = self.operand.to_qutip(full_space)</span>
<span class="c">#        if full_space.dimension &lt;= DENSE_DIMENSION_LIMIT:</span>
<span class="c">#            arr = mo.data.toarray()</span>
<span class="c">#            from scipy.linalg import pinv</span>
<span class="c">#            piarr = pinv(arr)</span>
<span class="c">#            pimo = qutip.Qobj(piarr)</span>
<span class="c">#            pimo.dims = mo.dims</span>
<span class="c">#            pimo.isherm = mo.isherm</span>
<span class="c">#            pimo.type = &#39;oper&#39;</span>
<span class="c">#            return pimo</span>
<span class="c">#        raise NotImplementedError(&quot;Only implemented for smaller state spaces&quot;)</span>
<span class="c">##        return qutip.dag(self.operands[0].to_qutip(full_space))</span>
<span class="c">#</span>
<span class="c">#    def _expand(self):</span>
<span class="c">#        return self</span>
<span class="c">#</span>
<span class="c">#    def _pseudo_inverse(self):</span>
<span class="c">#        return self.operand</span>
<span class="c">#</span>
<span class="c">#    def _tex(self):</span>
<span class="c">#        return &quot;\left(&quot; + self.operands[0].tex() + r&quot;\right)^+&quot;</span>
<span class="c">#</span>
<span class="c">#    def __str__(self):</span>
<span class="c">#        if isinstance(self.operand, OperatorSymbol):</span>
<span class="c">#            return &quot;{}^+&quot;.format(str(self.operand))</span>
<span class="c">#        return &quot;({})^+&quot;.format(str(self.operand))</span>
<span class="c">#</span>
<span class="c">#PseudoInverse.delegate_to_method = PseudoInverse.delegate_to_method + (PseudoInverse,)</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#@check_signature</span>
<span class="c">#@match_replace</span>
<span class="c">#class NullSpaceProjector(OperatorOperation):</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    Returns a projection operator that projects onto the nullspace of its operand</span>
<span class="c">#        NullSpaceProjector(op)</span>
<span class="c">#    I.e. `op * NullSpaceProjector(op) == 0`</span>
<span class="c">#    :param op: Operator argument</span>
<span class="c">#    :type op: Operator</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c">#    _rules = []</span>
<span class="c">#</span>
<span class="c">#    @property</span>
<span class="c">#    def operand(self):</span>
<span class="c">#        return self.operands[0]</span>
<span class="c">#</span>
<span class="c">#    def to_qutip(self, full_space=None):</span>
<span class="c">#        mo = self.operand.to_qutip(full_space)</span>
<span class="c">#        if full_space.dimension &lt;= DENSE_DIMENSION_LIMIT:</span>
<span class="c">#            arr = mo.data.toarray()</span>
<span class="c">#            from scipy.linalg import svd</span>
<span class="c">#            # compute Singular Value Decomposition</span>
<span class="c">#            U, s, Vh = svd(arr)</span>
<span class="c">#            tol = 1e-8 * s[0]</span>
<span class="c">#            zero_svs = s &lt; tol</span>
<span class="c">#            Vhzero = Vh[zero_svs,:]</span>
<span class="c">#            PKarr = Vhzero.conjugate().transpose().dot(Vhzero)</span>
<span class="c">#            PKmo = qutip.Qobj(PKarr)</span>
<span class="c">#            PKmo.dims = mo.dims</span>
<span class="c">#            PKmo.isherm = True</span>
<span class="c">#            PKmo.type = &#39;oper&#39;</span>
<span class="c">#            return PKmo</span>
<span class="c">#        raise NotImplementedError(&quot;Only implemented for smaller state spaces&quot;)</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#    def _tex(self):</span>
<span class="c">#        return r&quot;\mathcal{P}_{{\rm Ker}&quot; + tex(self.operand) + &quot;}&quot;</span>
<span class="c">#</span>
<span class="c">#    def __str__(self):</span>
<span class="c">#        return &quot;P_ker({})&quot;.format(str(self.operand))</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#@implied_local_space</span>
<span class="c">#@match_replace</span>
<span class="c">#@check_signature</span>
<span class="c">#class OperatorTrace(Operator, Operation):</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    Take the (partial) trace of an operator `op` over the degrees of freedom given by `space`.</span>
<span class="c">#        OperatorTrace(space, op)</span>
<span class="c">#    :param space: The degrees of freedom to trace over</span>
<span class="c">#    :type space: HilbertSpace</span>
<span class="c">#    :param op: The operator to take the trace of.</span>
<span class="c">#    :type op: Operator</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    signature = HilbertSpace, Operator</span>
<span class="c">#    _rules = []</span>
<span class="c">#</span>
<span class="c">#    def __init__(self, space, op):</span>
<span class="c">#        if isinstance(space, (int, str)):</span>
<span class="c">#            space = local_space(space)</span>
<span class="c">#        super(OperatorTrace, self).__init__(space, op)</span>
<span class="c">#</span>
<span class="c">#    @property</span>
<span class="c">#    def _space(self):</span>
<span class="c">#        over_space, op = self.operands</span>
<span class="c">#        return op.space / over_space</span>
<span class="c">#</span>
<span class="c">#    def _expand(self):</span>
<span class="c">#        s, o = self.operands</span>
<span class="c">#        return OperatorTrace.create(s, o.expand())</span>
<span class="c">#</span>
<span class="c">#    def _tex(self):</span>
<span class="c">#        s, o = self.operands</span>
<span class="c">#        return r&quot;{{\rm Tr}}_{{{}}} \left[ {} \right]&quot;.format(tex(s), tex(o))</span>
<span class="c">#</span>
<span class="c">#    def _tex(self):</span>
<span class="c">#        s, o = self.operands</span>
<span class="c">#        return r&quot;tr_{!s}[{!s}]&quot;.format(s, o)</span>
<span class="c">#</span>
<span class="c">#tr = OperatorTrace.create</span>


<span class="c">## Expression rewriting _rules</span>
</div>
<span class="n">sA</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sA&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>
<span class="n">sA__</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sA__&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>
<span class="n">sA___</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sA___&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>
<span class="n">sB</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sB&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>
<span class="n">sB__</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sB__&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>
<span class="n">sB___</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sB___&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperator</span><span class="p">)</span>


<span class="n">sA_plus</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sA&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperatorPlus</span><span class="p">)</span>
<span class="n">sA_times</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;sA&quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">SuperOperatorTimes</span><span class="p">)</span>


<span class="n">ScalarTimesSuperOperator</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="n">sA</span><span class="p">),</span>
    <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">sA</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">SuperOperatorPlus</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">sA</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="n">sA</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">:</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sA</span><span class="p">),</span>
    <span class="p">((</span><span class="n">sA</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">,</span> <span class="n">sA</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">sA</span><span class="p">),</span>
    <span class="p">((</span><span class="n">sA</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sA</span><span class="p">),</span>
<span class="p">]</span>


<span class="n">SuperOperatorTimes</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="n">sB</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">,</span> <span class="n">sB</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">sA</span> <span class="o">*</span> <span class="n">sB</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">sA</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sB</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">sB</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">sA</span> <span class="o">*</span> <span class="n">sB</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">SPre</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">SPre</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">SPost</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">SPost</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="n">A</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">SuperAdjoint</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">sA</span><span class="o">.</span><span class="n">superadjoint</span><span class="p">()),</span>
    <span class="p">((</span><span class="n">sA_plus</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="n">SuperOperatorPlus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">superadjoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">sA</span><span class="o">.</span><span class="n">operands</span><span class="p">])),</span>
    <span class="p">((</span><span class="n">sA_times</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="n">SuperOperatorTimes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">superadjoint</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">sA</span><span class="o">.</span><span class="n">operands</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])),</span>
    <span class="p">((</span><span class="n">SuperAdjoint</span><span class="p">(</span><span class="n">sA</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">:</span> <span class="n">sA</span><span class="p">),</span>
    <span class="p">((</span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">SPost</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">SPre</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">IdentitySuperOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">IdentitySuperOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ZeroSuperOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">SPre</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span><span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="n">SPre</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">IdentityOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">IdentitySuperOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ZeroOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">SPost</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span><span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="n">SPost</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">IdentityOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">IdentitySuperOperator</span><span class="p">),</span>
    <span class="p">((</span><span class="n">ZeroOperator</span><span class="p">,),</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">ZeroSuperOperator</span><span class="p">),</span>
<span class="p">]</span>


<span class="n">SuperOperatorTimesOperator</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span><span class="p">[</span>
    <span class="p">((</span><span class="n">ScalarTimesSuperOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">sA</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">sA</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">sA</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">sA</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">sA</span><span class="p">,</span> <span class="n">SuperOperatorTimesOperator</span><span class="p">(</span><span class="n">sB</span><span class="p">,</span> <span class="n">C</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">sA</span><span class="p">,</span> <span class="n">sB</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">sA</span> <span class="o">*</span> <span class="n">sB</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span><span class="p">),</span>
    <span class="p">((</span><span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="p">),</span>
    <span class="p">((</span><span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">B</span><span class="o">*</span><span class="n">A</span><span class="p">),</span>
<span class="p">]</span>


<div class="viewcode-block" id="commutator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.commutator">[docs]</a><span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If ``B != None``, return the commutator :math:`[A,B]`, otherwise return the super-operator :math:`[A,\cdot]`.</span>
<span class="sd">    The super-operator :math:`[A,\cdot]` maps any other operator ``B`` to the commutator :math:`[A, B] = A B - B A`.</span>

<span class="sd">    :param Operator A: The first operator to form the commutator of.</span>
<span class="sd">    :param (Operator or None) B: The second operator to form the commutator of, or None.</span>
<span class="sd">    :return: The linear superoperator :math:`[A,\cdot]`</span>
<span class="sd">    :rtype: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">B</span> <span class="o">*</span> <span class="n">A</span>
    <span class="k">return</span> <span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="anti_commutator"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.anti_commutator">[docs]</a><span class="k">def</span> <span class="nf">anti_commutator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If ``B != None``, return the anti-commutator :math:`\{A,B\}`, otherwise return the super-operator :math:`\{A,\cdot\}`.</span>
<span class="sd">    The super-operator :math:`\{A,\cdot\}` maps any other operator ``B`` to the anti-commutator :math:`\{A, B\} = A B + B A`.</span>

<span class="sd">    :param Operator A: The first operator to form all anti-commutators of.</span>
<span class="sd">    :param (Operator or None) B: The second operator to form the anti-commutator of, or None.</span>
<span class="sd">    :return: The linear superoperator :math:`[A,\cdot]`</span>
<span class="sd">    :rtype: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">A</span>
    <span class="k">return</span> <span class="n">SPre</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">SPost</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="lindblad"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.lindblad">[docs]</a><span class="k">def</span> <span class="nf">lindblad</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return ``SPre(C) * SPost(C.adjoint()) - (1/2) * santi_commutator(C.adjoint()*C)``.</span>
<span class="sd">    These are the super-operators :math:`\mathcal{D}[C]` that form the collapse terms of a Master-Equation.</span>
<span class="sd">    Applied to an operator :math:`X` they yield</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{D}[C] X = C X C^\dagger - {1\over 2} (C^\dagger C X + X C^\dagger C)</span>

<span class="sd">    :param C: The associated collapse operator</span>
<span class="sd">    :type C: Operator</span>
<span class="sd">    :return: The Lindblad collapse generator.</span>
<span class="sd">    :rtype: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">scalar_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ZeroSuperOperator</span>
    <span class="k">return</span> <span class="n">SPre</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">SPost</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())</span> <span class="o">-</span> <span class="p">(</span><span class="n">sympyOne</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">anti_commutator</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="liouvillian"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.liouvillian">[docs]</a><span class="k">def</span> <span class="nf">liouvillian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Ls</span> <span class="o">=</span> <span class="p">[]):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the Liouvillian super-operator associated with a Hamilton operator ``H`` and a set of collapse-operators ``Ls = [L1, L2, ...]``.</span>

<span class="sd">    The Liouvillian :math:`\mathcal{L}` generates the Markovian-dynamics of a system via the Master equation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \dot{\rho} = \mathcal{L}\rho = -i[H,\rho] + \sum_{j=1}^n \mathcal{D}[L_j] \rho</span>

<span class="sd">    :param H: The associated Hamilton operator</span>
<span class="sd">    :type H: Operator</span>
<span class="sd">    :param Ls: A sequence of collapse operators.</span>
<span class="sd">    :type Ls: sequence or Matrix</span>
<span class="sd">    :return: The Liouvillian super-operator.</span>
<span class="sd">    :rtype: SuperOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ls</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">I</span> <span class="o">*</span> <span class="n">commutator</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">((</span><span class="n">lindblad</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">Ls</span><span class="p">),</span> <span class="n">ZeroSuperOperator</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="BadLiouvillianError"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.BadLiouvillianError">[docs]</a><span class="k">class</span> <span class="nc">BadLiouvillianError</span><span class="p">(</span><span class="n">AlgebraError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise when a Liouvillian is not of standard Lindblad form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="CannotSymbolicallyDiagonalize"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.CannotSymbolicallyDiagonalize">[docs]</a><span class="k">class</span> <span class="nc">CannotSymbolicallyDiagonalize</span><span class="p">(</span><span class="n">AlgebraException</span><span class="p">):</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="liouvillian_normal_form"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.super_operator_algebra.liouvillian_normal_form">[docs]</a><span class="k">def</span> <span class="nf">liouvillian_normal_form</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return a Hamilton operator ``H`` and a minimal list of collapse operators ``Ls`` that generate the liouvillian ``L``.</span>

<span class="sd">    A Liouvillian defined by a hermitian Hamilton operator :math:`H` and a vector of collapse operators</span>
<span class="sd">    :math:`\mathbf{L} = (L_1, L_2, \dots L_n)^T` is invariant under the following two operations:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left(H, \mathbf{L}\right) &amp; \mapsto \left(H + {1\over 2i}\left(\mathbf{w}^\dagger \mathbf{L} - \mathbf{L}^\dagger \mathbf{w}\right), \mathbf{L} + \mathbf{w} \right) \\</span>
<span class="sd">        \left(H, \mathbf{L}\right) &amp; \mapsto \left(H, \mathbf{U}\mathbf{L}\right)\\</span>

<span class="sd">    where :math:`\mathbf{w}` is just a vector of complex numbers and :math:`\mathbf{U}` is a complex unitary matrix.</span>
<span class="sd">    It turns out that for quantum optical circuit models the set of collapse operators is linearly dependent.</span>
<span class="sd">    This routine tries to find a representation of the Liouvillian in terms of a Hamilton operator ``H`` with</span>
<span class="sd">    as few non-zero collapse operators ``Ls`` as possible.</span>
<span class="sd">    Consider the following example, which results from a two-port linear cavity with a coherent input into the first port:</span>

<span class="sd">    &gt;&gt;&gt; kappa_1, kappa_2 = symbols(&#39;kappa_1, kappa_2&#39;, positive = True)</span>
<span class="sd">    &gt;&gt;&gt; Delta = symbols(&#39;Delta&#39;, real = True)</span>
<span class="sd">    &gt;&gt;&gt; alpha = symbols(&#39;alpha&#39;)</span>
<span class="sd">    &gt;&gt;&gt; H = Delta * Create(1) * Destroy(1) + (sqrt(kappa_1) / (2 * I)) * (alpha * Create(1) - alpha.conjugate() * Destroy(1))</span>
<span class="sd">    &gt;&gt;&gt; Ls = [sqrt(kappa_1) * Destroy(1) + alpha, sqrt(kappa_2) * Destroy(1)]</span>
<span class="sd">    &gt;&gt;&gt; LL = liouvillian(H, Ls)</span>
<span class="sd">    &gt;&gt;&gt; Hnf, Lsnf = liouvillian_normal_form(LL)</span>
<span class="sd">    &gt;&gt;&gt; Hnf</span>
<span class="sd">        Delta * Create(1) * Destroy(1) - I *  sqrt(kappa_1) * (alpha * Create(1) - alpha.conjugate() * Destroy(1))</span>
<span class="sd">    &gt;&gt;&gt; Lsnf</span>
<span class="sd">        [sqrt(kappa_1 + kappa_2) * Destroy(1)]</span>

<span class="sd">    In terms of the ensemble dynamics this final system is equivalent.</span>
<span class="sd">    Note that this function will only work for proper Liouvillians.</span>

<span class="sd">    :param L: The Liouvillian</span>
<span class="sd">    :type L: SuperOperator</span>
<span class="sd">    :return: ``(H, Ls)``</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    :raises: BadLiouvillianError</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">SuperOperatorPlus</span><span class="p">):</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spres</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sposts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">collapse_form</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">term</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">operands</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ScalarTimesSuperOperator</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">sympyOne</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">SPre</span><span class="p">):</span>
                <span class="n">spres</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">SPost</span><span class="p">):</span>
                <span class="n">sposts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">SuperOperatorTimes</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SPre</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">SPost</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="n">BadLiouvillianError</span><span class="p">(</span><span class="s">&quot;All terms of the Liouvillian need to be of form &quot;</span>
                                              <span class="s">&quot;SPre(X), SPost(X) or SPre(X)*SPost(X): This term is in violation {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">term</span><span class="p">))</span>
                <span class="n">spreL</span><span class="p">,</span> <span class="n">spostL</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">Li</span><span class="p">,</span> <span class="n">Ljd</span> <span class="o">=</span> <span class="n">spreL</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spostL</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

                <span class="n">collapse_form</span><span class="p">[</span><span class="n">Li</span><span class="p">][</span><span class="n">Ljd</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">collapse_form</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Li</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">Lj</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">[</span><span class="n">ii</span><span class="p">:]:</span>
                <span class="n">cij</span> <span class="o">=</span> <span class="n">collapse_form</span><span class="p">[</span><span class="n">Li</span><span class="p">][</span><span class="n">Lj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()]</span>
                <span class="n">cji</span> <span class="o">=</span> <span class="n">collapse_form</span><span class="p">[</span><span class="n">Lj</span><span class="p">][</span><span class="n">Li</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()]</span>
                <span class="k">if</span> <span class="n">cij</span> <span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">cji</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">cij</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">-</span> <span class="n">cji</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                            <span class="k">print</span><span class="p">((</span><span class="s">&quot;Warning: the Liouvillian is probably malformed: &quot;</span>
                                   <span class="s">&quot;The coefficients of SPre({!s})*SPost({!s}) and SPre({!s})*SPost({!s}) &quot;</span>
                                   <span class="s">&quot;should be complex conjugates of each other&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Li</span><span class="p">,</span> <span class="n">Lj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">Lj</span><span class="p">,</span> <span class="n">Li</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()))</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">simplify</span><span class="p">():</span>
                            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Warning: the Liouvillian my be malformed, convert to numerical representation&quot;</span><span class="p">)</span>
        <span class="n">final_Lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">kappa1</span> <span class="o">=</span> <span class="n">collapse_form</span><span class="p">[</span><span class="n">l1</span><span class="p">][</span><span class="n">l1</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()]</span>
                <span class="n">final_Lis</span> <span class="o">=</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa1</span><span class="p">)</span> <span class="o">*</span> <span class="n">l1</span><span class="p">]</span>
                <span class="n">sdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">l1</span> <span class="o">*</span> <span class="n">kappa1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">spres</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>
                <span class="n">sposts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>
<span class="c">#            elif len(basis) == 2:</span>
<span class="c">#                l1, l2 = basis</span>
<span class="c">#                kappa_1 = collapse_form[l1][l1.adjoint()]</span>
<span class="c">#                kappa_2 = collapse_form[l2][l2.adjoint()]</span>
<span class="c">#                kappa_12 = collapse_form[l1][l2.adjoint()]</span>
<span class="c">#                kappa_21 = collapse_form[l2][l1.adjoint()]</span>
<span class="c">##                assert (kappa_12.conjugate() - kappa_21) == 0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">SympyMatrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">collapse_form</span><span class="p">[</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">basis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()])</span>

                <span class="c"># First check if M is already diagonal (sympy does not handle this well, for some reason)</span>
                <span class="n">diag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplify</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">diag</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">diag</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">diag</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">bj</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                        <span class="n">final_Lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bj</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">collapse_form</span><span class="p">[</span><span class="n">bj</span><span class="p">][</span><span class="n">bj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()]))</span>
                        <span class="n">sdiff</span> <span class="o">=</span> <span class="n">bj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">bj</span> <span class="o">*</span> <span class="n">collapse_form</span><span class="p">[</span><span class="n">bj</span><span class="p">][</span><span class="n">bj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()]</span><span class="o">/</span><span class="mi">2</span>
                        <span class="n">spres</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>
                        <span class="n">sposts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>

                <span class="c"># Try sympy algo</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()</span>

                        <span class="k">for</span> <span class="n">evalue</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">ebasis</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">evalue</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ebasis</span><span class="p">:</span>
                                <span class="n">new_L</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">evalue</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Lj</span> <span class="k">for</span> <span class="p">(</span><span class="n">cj</span><span class="p">,</span> <span class="n">Lj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">basis</span><span class="p">)))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                                <span class="n">final_Lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_L</span><span class="p">)</span>
                                <span class="n">sdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">new_L</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                                <span class="n">spres</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>
                                <span class="n">sposts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>

                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">CannotSymbolicallyDiagonalize</span><span class="p">((</span><span class="s">&quot;The matrix {} is too hard to diagonalize symbolically. &quot;</span>
                                                            <span class="s">&quot;Please try converting to fully numerical representation.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np_array</span><span class="p">([[</span><span class="nb">complex</span><span class="p">(</span><span class="n">collapse_form</span><span class="p">[</span><span class="n">Li</span><span class="p">][</span><span class="n">Lj</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()])</span> <span class="k">for</span> <span class="n">Lj</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span> <span class="k">for</span> <span class="n">Li</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">])</span>


            <span class="n">vals</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sv</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np_sqrt</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">vecs</span><span class="o">.</span><span class="n">transpose</span><span class="p">()):</span>
                <span class="n">new_L</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">sv</span> <span class="o">*</span> <span class="n">ci</span><span class="p">)</span> <span class="o">*</span> <span class="n">Li</span> <span class="k">for</span> <span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">Li</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span>
                <span class="n">final_Lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_L</span><span class="p">)</span>
                <span class="n">sdiff</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">new_L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span><span class="o">*</span><span class="n">new_L</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                <span class="n">spres</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>
                <span class="n">sposts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdiff</span><span class="p">)</span>


        <span class="n">miHspre</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">spres</span><span class="p">)</span>
        <span class="n">iHspost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sposts</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">miHspre</span> <span class="o">+</span> <span class="n">iHspost</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZeroOperator</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">miHspre</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">+</span> <span class="n">miHspre</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZeroOperator</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Warning, potentially malformed Liouvillian {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>

        <span class="n">final_H</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">miHspre</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">final_H</span><span class="p">,</span> <span class="n">final_Lis</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="n">ZeroSuperOperator</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ZeroOperator</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">raise</span> <span class="n">BadLiouvillianError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Nikolas Tezak.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>