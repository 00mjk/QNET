

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qnet.algebra.circuit_algebra &mdash; QNET 0.9 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/mycss.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/mathjax_cancel.js"></script>
    <link rel="top" title="QNET 0.9 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 0.9 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for qnet.algebra.circuit_algebra</h1><div class="highlight"><pre>
<span class="c">#This file is part of QNET.</span>
<span class="c">#</span>
<span class="c">#    QNET is free software: you can redistribute it and/or modify</span>
<span class="c">#    it under the terms of the GNU General Public License as published by</span>
<span class="c">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#   (at your option) any later version.</span>
<span class="c">#</span>
<span class="c">#    QNET is distributed in the hope that it will be useful,</span>
<span class="c">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#    GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c">#    You should have received a copy of the GNU General Public License</span>
<span class="c">#    along with QNET.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2012-2013, Nikolas Tezak</span>
<span class="c">#</span>
<span class="c">###########################################################################</span>

<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">Circuit Algebra</span>
<span class="sd">===============</span>

<span class="sd">This module defines the circuit algebra for quantum optical feedback and feedforward circuits in the zero-internal time-delay limit.</span>
<span class="sd">For more details see :ref:`circuit_algebra`.</span>

<span class="sd">References:</span>

<span class="sd">.. [1] Gough, James &amp; Nurdin (2010). Squeezing components in linear quantum feedback networks. Physical Review A, 81(2). doi:10.1103/PhysRevA.81.023804</span>
<span class="sd">.. [2] Gough &amp; James (2008). Quantum Feedback Networks: Hamiltonian Formulation. Communications in Mathematical Physics, 287(3), 1109-1132. doi:10.1007/s00220-008-0698-8</span>
<span class="sd">.. [3] Gough &amp; James (2009). The Series Product and Its Application to Quantum Feedforward and Feedback Networks. IEEE Transactions on Automatic Control, 54(11), 2530-2544. doi:10.1109/TAC.2009.2031205</span>


<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">operator_algebra</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="CannotConvertToSLH"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CannotConvertToSLH">[docs]</a><span class="k">class</span> <span class="nc">CannotConvertToSLH</span><span class="p">(</span><span class="n">AlgebraException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is raised when a circuit algebra object cannot be converted to a concrete SLH object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="CannotConvertToABCD"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CannotConvertToABCD">[docs]</a><span class="k">class</span> <span class="nc">CannotConvertToABCD</span><span class="p">(</span><span class="n">AlgebraException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is raised when a circuit algebra object cannot be converted to a concrete ABCD object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="CannotVisualize"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CannotVisualize">[docs]</a><span class="k">class</span> <span class="nc">CannotVisualize</span><span class="p">(</span><span class="n">AlgebraException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is raised when a circuit algebra object cannot be visually represented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="WrongCDimError"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.WrongCDimError">[docs]</a><span class="k">class</span> <span class="nc">WrongCDimError</span><span class="p">(</span><span class="n">AlgebraError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is raised when two object are tried to joined together in series but have different channel dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="CircuitVisualizer"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CircuitVisualizer">[docs]</a><span class="k">class</span> <span class="nc">CircuitVisualizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualization wrapper class that implements IPython&#39;s _repr_png_ method to</span>
<span class="sd">    generate a graphical representation (in PNG format) of its circuit object.</span>
<span class="sd">    Use as::</span>

<span class="sd">        CircuitVisualizer(circuit)</span>

<span class="sd">    :param circuit: The circuit expression to visualize</span>
<span class="sd">    :type circuit: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_circuit</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">circuit</span><span class="p">):</span>
        <span class="c">#noinspection PyRedeclaration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span> <span class="o">=</span> <span class="n">circuit</span>

    <span class="k">def</span> <span class="nf">_repr_png_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">qnet.misc.circuit_visualization</span> <span class="kn">as</span> <span class="nn">circuit_visualization</span>
        <span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">gettempdir</span>

        <span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">gettempdir</span><span class="p">()</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">tmp_dir</span> <span class="o">+</span> <span class="s">&quot;/tmp_{}.png&quot;</span> <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">circuit_visualization</span><span class="o">.</span><span class="n">draw_circuit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">png_file</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">png_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">fdata</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Could not open visualization file for {!s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">CannotVisualize</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CannotVisualize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{}({!r})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IncompatibleBlockStructures"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.IncompatibleBlockStructures">[docs]</a><span class="k">class</span> <span class="nc">IncompatibleBlockStructures</span><span class="p">(</span><span class="n">AlgebraError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is raised when a circuit decomposition into a block-structure is requested</span>
<span class="sd">    that is icompatible with the actual block structure of the circuit expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>


</div>
<div class="viewcode-block" id="Circuit"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit">[docs]</a><span class="k">class</span> <span class="nc">Circuit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for the circuit algebra elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Circuit.cdim"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.cdim">[docs]</a>    <span class="k">def</span> <span class="nf">cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The channel dimension of the circuit expression,</span>
<span class="sd">        i.e. the number of external bosonic noises/inputs that the circuit couples to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdim</span>
</div>
    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Circuit.block_structure"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.block_structure">[docs]</a>    <span class="k">def</span> <span class="nf">block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the circuit is *reducible* (i.e., it can be represented as a :py:class:Concatenation: of individual circuit expressions),</span>
<span class="sd">        this gives a tuple of cdim values of the subblocks.</span>
<span class="sd">        E.g. if A and B are irreducible and have ``A.cdim = 2``, ``B.cdim = 3``</span>

<span class="sd">            &gt;&gt;&gt; A = CircuitSymbol(&#39;A&#39;, 2)</span>
<span class="sd">            &gt;&gt;&gt; B = CircuitSymbol(&#39;B&#39;, 3)</span>

<span class="sd">        Then the block structure of their Concatenation is:</span>

<span class="sd">            &gt;&gt;&gt; (A + B).block_structure</span>
<span class="sd">                (2,3),</span>

<span class="sd">        while</span>

<span class="sd">            &gt;&gt;&gt; A.block_structure</span>
<span class="sd">                (2,)</span>
<span class="sd">            &gt;&gt;&gt; B.block_structure</span>
<span class="sd">                (3,)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_structure</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">,</span>

<div class="viewcode-block" id="Circuit.index_in_block"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.index_in_block">[docs]</a>    <span class="k">def</span> <span class="nf">index_in_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the index a channel has within the subblock it belongs to.</span>
<span class="sd">        I.e., only for reducible circuits, this gives a result different from the argument itself.</span>

<span class="sd">        :param channel_index: The index of the external channel</span>
<span class="sd">        :type channel_index: int</span>
<span class="sd">        :return: The index of the external channel within the subblock it belongs to.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raise: ValueError</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channel_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">channel_index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">channel_index</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nb">sum</span><span class="p">(</span><span class="n">struct</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">channel_index</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">block_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">index_in_block</span> <span class="o">=</span> <span class="n">channel_index</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">struct</span><span class="p">[:</span><span class="n">block_index</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">index_in_block</span><span class="p">,</span> <span class="n">block_index</span>

</div>
<div class="viewcode-block" id="Circuit.get_blocks"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.get_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a reducible circuit, get a sequence of subblocks that when concatenated again yield the original circuit.</span>
<span class="sd">        The block structure given has to be compatible with the circuits actual block structure,</span>
<span class="sd">        i.e. it can only be more coarse-grained.</span>

<span class="sd">        :param block_structure: The block structure according to which the subblocks are generated (default = ``None``, corresponds to the circuit&#39;s own block structure)</span>
<span class="sd">        :type block_structure: tuple</span>
<span class="sd">        :return: A tuple of subblocks that the circuit consists of.</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        :raises: IncompatibleBlockStructures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">block_structure</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#noinspection PyRedeclaration</span>
            <span class="n">block_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">block_structure</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">IncompatibleBlockStructures</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
</div>
    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">block_structure</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="n">IncompatibleBlockStructures</span><span class="p">(</span><span class="s">&quot;Requested incompatible block structure </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">block_structure</span><span class="p">,))</span>

<div class="viewcode-block" id="Circuit.series_inverse"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.series_inverse">[docs]</a>    <span class="k">def</span> <span class="nf">series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse object (under the series product) for a circuit.</span>
<span class="sd">        In general for any X</span>

<span class="sd">            &gt;&gt;&gt; X &lt;&lt; X.series_inverse() == X.series_inverse() &lt;&lt; X == cid(X.cdim)</span>
<span class="sd">                True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_series_inverse</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SeriesInverse</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.feedback"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.feedback">[docs]</a>    <span class="k">def</span> <span class="nf">feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">in_index</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a circuit with self-feedback from the output port (zero-based) ``out_index`` to the input port ``in_index``.</span>

<span class="sd">        :param out_index: The output port from which the feedback connection leaves (zero-based, default = ``None`` corresponds to the *last* port).</span>
<span class="sd">        :type out_index: int or NoneType</span>
<span class="sd">        :param in_index: The input port into which the feedback connection goes (zero-based, default = ``None`` corresponds to the *last* port).</span>
<span class="sd">        :type in_index: int or NoneType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out_index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#noinspection PyRedeclaration</span>
            <span class="n">out_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">in_index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#noinspection PyRedeclaration</span>
            <span class="n">in_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span><span class="p">(</span><span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.show"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Show the circuit expression in an IPython notebook.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CircuitVisualizer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Circuit.creduce"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.creduce">[docs]</a>    <span class="k">def</span> <span class="nf">creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the circuit is reducible, try to reduce each subcomponent once.</span>
<span class="sd">        Depending on whether the components at the next hierarchy-level are themselves reducible,</span>
<span class="sd">        successive ``circuit.creduce()`` operations yields an increasingly fine-grained decomposition of a circuit into its most primitive elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_creduce</span><span class="p">()</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Circuit.toSLH"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.toSLH">[docs]</a>    <span class="k">def</span> <span class="nf">toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the SLH representation of a circuit. This can fail if there are un-substituted pure circuit all_symbols (:py:class:`CircuitSymbol`) left</span>
<span class="sd">        in the expression or if the circuit includes *non-passive* ABCD models (cf. [1]_)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toSLH</span><span class="p">()</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.toABCD"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.toABCD">[docs]</a>    <span class="k">def</span> <span class="nf">toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ABCD representation of a circuit expression. If `linearize=True` all operator expressions giving rise to non-linear equations of motion are dropped.</span>
<span class="sd">        This can fail if there are un-substituted pure circuit all_symbols (:py:class:`CircuitSymbol`) left in the expression or if `linearize = False` and the circuit includes non-linear SLH models.</span>
<span class="sd">        (cf. [1]_)</span>


<span class="sd">        :param linearize: Whether or not to explicitly neglect non-linear contributions (default = False)</span>
<span class="sd">        :type linearize: bool</span>
<span class="sd">        :return: ABCD model for the circuit</span>
<span class="sd">        :rtype: ABCD</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toABCD</span><span class="p">(</span><span class="n">linearize</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Circuit.coherent_input"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.coherent_input">[docs]</a>    <span class="k">def</span> <span class="nf">coherent_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">input_amps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Feed coherent input amplitudes into the circuit.</span>
<span class="sd">        E.g. For a circuit with channel dimension of two,</span>
<span class="sd">        `C.coherent_input(0,1)` leads to an input amplitude of zero into the first and one into the second port.</span>

<span class="sd">        :param input_amps: The coherent input amplitude for each port</span>
<span class="sd">        :type input_amps: any of :py:attr:`qnet.algebra.operator_algebra.Operator.scalar_types`</span>
<span class="sd">        :return: The circuit including the coherent inputs.</span>
<span class="sd">        :rtype: Circuit</span>
<span class="sd">        :raise: WrongCDimError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coherent_input</span><span class="p">(</span><span class="o">*</span><span class="n">input_amps</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_coherent_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">input_amps</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_amps</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongCDimError</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">SLH</span><span class="p">(</span><span class="n">identity_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">),</span> <span class="n">Matrix</span><span class="p">((</span><span class="n">input_amps</span><span class="p">,))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Circuit.space"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Circuit.space">[docs]</a>    <span class="k">def</span> <span class="nf">space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All Hilbert space degree of freedoms associated with a given circuit component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space</span>
</div>
    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>


</div>
<div class="viewcode-block" id="SLH"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH">[docs]</a><span class="k">class</span> <span class="nc">SLH</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SLH class to encapsulate an open system model that is parametrized as described in [2]_ , [3]_ ::</span>

<span class="sd">        SLH(S, L, H)</span>

<span class="sd">    :param S: The scattering matrix (with in general Operator-valued elements)</span>
<span class="sd">    :type S: Matrix</span>
<span class="sd">    :param L: The coupling vector (with in general Operator-valued elements)</span>
<span class="sd">    :type L: Matrix</span>
<span class="sd">    :param H: The internal Hamilton operator</span>
<span class="sd">    :type H: Operator</span>
<span class="sd">    :raise: ValueError</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#noinspection PyRedeclaration,PyUnresolvedReferences</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;S and L misaligned: S = {!r}, L = {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>

        <span class="c">#noinspection PyArgumentList</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SLH</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SLH.S"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.S">[docs]</a>    <span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The scattering matrix (with in general Operator-valued elements) of shape ``(cdim, cdim)``</span>

<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SLH.L"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.L">[docs]</a>    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coupling vector (with in general Operator-valued elements) of shape ``(cdim, 1)``</span>

<span class="sd">        :rtype: Matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c">#noinspection PyRedeclaration</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SLH.H"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.H">[docs]</a>    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The internal Hamilton operator.</span>

<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">space</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">space</span> <span class="o">*</span> <span class="n">space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>


<div class="viewcode-block" id="SLH.series_with_slh"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.series_with_slh">[docs]</a>    <span class="k">def</span> <span class="nf">series_with_slh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the series product with another :py:class:``SLH`` object.</span>

<span class="sd">        :param other: An upstream SLH circuit.</span>
<span class="sd">        :type other: SLH</span>
<span class="sd">        :return: The combines system.</span>
<span class="sd">        :rtype: SLH</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">S</span>
        <span class="n">new_L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>

        <span class="n">delta</span> <span class="o">=</span>  <span class="n">ImAdjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">new_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">H</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">new_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">H</span>

        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">new_S</span><span class="p">,</span> <span class="n">new_L</span><span class="p">,</span> <span class="n">new_H</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SLH.concatenate_slh"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.concatenate_slh">[docs]</a>    <span class="k">def</span> <span class="nf">concatenate_slh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the concatenation product with another SLH object.</span>

<span class="sd">        :param other: Another SLH object</span>
<span class="sd">        :type other: SLH</span>
<span class="sd">        :return: The combined system</span>
<span class="sd">        :rtype: SLH</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selfS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">otherS</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">S</span>
        <span class="n">new_S</span> <span class="o">=</span> <span class="n">block_matrix</span><span class="p">(</span><span class="n">selfS</span><span class="p">,</span> <span class="n">zeros</span><span class="p">((</span><span class="n">selfS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">otherS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">),</span> <span class="n">zeros</span><span class="p">((</span><span class="n">otherS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">selfS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">),</span> <span class="n">otherS</span><span class="p">)</span>
        <span class="n">new_L</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">L</span><span class="p">))</span>
        <span class="n">new_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">H</span>

        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">new_S</span><span class="p">,</span> <span class="n">new_L</span><span class="p">,</span> <span class="n">new_H</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;({!s}, {!s}, {!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\left( {}, {}, {} \right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">),</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="SLH.expand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand out all operator expressions within S, L and H and return a new SLH object with these expanded expressions.</span>

<span class="sd">        :rtype: SLH</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="SLH.HL_to_qutip"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.HL_to_qutip">[docs]</a>    <span class="k">def</span> <span class="nf">HL_to_qutip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_space</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and return QuTiP representation matrices for the Hamiltonian and the collapse operators.</span>

<span class="sd">        :param full_space: The Hilbert space in which to represent the operators.</span>
<span class="sd">        :type full_space: HilbertSpace or None</span>
<span class="sd">        :return tuple: (H, [L1, L2, ...]) as numerical qutip.Qobj representations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">full_space</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">full_space</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&quot;full_space = {} needs to at least include self.space = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_space</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">to_qutip</span><span class="p">(</span><span class="n">full_space</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">Ls</span>



<span class="c">#    _block_structure_ = None</span>
<span class="c">#</span>
<span class="c">#    @property</span>
<span class="c">#    def _block_structure(self):</span>
<span class="c">#        if self.cdim and not self._block_structure_:</span>
<span class="c">#            self._block_structure_ = self.S.block_structure</span>
<span class="c">#        return self._block_structure_</span>
<span class="c">#</span>
<span class="c">#    def _get_blocks(self, block_structure):</span>
<span class="c">#        Sblocks = self.S._get_blocks(block_structure)</span>
<span class="c">#        Lblocks = self.L._get_blocks(block_structure)</span>
<span class="c">#        Hblocks = (self.H,) + ((0,)*(len(block_structure)-1))</span>
<span class="c">#        return tuple(SLH(S,L,H) for (S,L,H) in zip(Sblocks, Lblocks, Hblocks))</span>

</div>
    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">out_index</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">out_index</span><span class="p">:</span><span class="n">n</span><span class="p">},</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">feedback</span><span class="p">(</span><span class="n">in_index</span> <span class="o">=</span> <span class="n">in_index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">in_index</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">n</span><span class="p">:</span><span class="n">in_index</span><span class="p">},</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span><span class="o">.</span><span class="n">toSLH</span><span class="p">())</span><span class="o">.</span><span class="n">feedback</span><span class="p">()</span>


        <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

        <span class="n">one_minus_Snn</span> <span class="o">=</span> <span class="n">sympyOne</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">one_minus_Snn</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">one_minus_Snn</span><span class="p">,</span> <span class="n">ScalarTimesOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">one_minus_Snn</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">IdentityOperator</span><span class="p">():</span>
                <span class="n">one_minus_Snn</span> <span class="o">=</span> <span class="n">one_minus_Snn</span><span class="o">.</span><span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&#39;Inversion not implemented for general operators&#39;</span><span class="p">)</span>

        <span class="n">one_minus_Snn_inv</span> <span class="o">=</span> <span class="n">sympyOne</span><span class="o">/</span><span class="n">one_minus_Snn</span>

        <span class="n">new_S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="n">n</span><span class="p">,:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span> <span class="p">,</span> <span class="n">n</span><span class="p">:]</span> <span class="o">*</span> <span class="n">one_minus_Snn_inv</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">n</span><span class="p">:,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">n</span><span class="p">]</span>

        <span class="n">new_L</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">one_minus_Snn_inv</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">delta_H</span>  <span class="o">=</span> <span class="n">Im</span><span class="p">((</span><span class="n">L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">S</span><span class="p">[:,</span><span class="n">n</span><span class="p">:])</span> <span class="o">*</span> <span class="n">one_minus_Snn_inv</span> <span class="o">*</span> <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta_H</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">delta_H</span> <span class="o">=</span> <span class="n">delta_H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">delta_H</span>

        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">new_S</span><span class="p">,</span> <span class="n">new_L</span><span class="p">,</span> <span class="n">new_H</span><span class="p">)</span>


<div class="viewcode-block" id="SLH.symbolic_liouvillian"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.symbolic_liouvillian">[docs]</a>    <span class="k">def</span> <span class="nf">symbolic_liouvillian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">super_operator_algebra</span> <span class="kn">import</span> <span class="n">liouvillian</span>
        <span class="k">return</span> <span class="n">liouvillian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

    <span class="c">#noinspection PyRedeclaration</span></div>
<div class="viewcode-block" id="SLH.symbolic_master_equation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.symbolic_master_equation">[docs]</a>    <span class="k">def</span> <span class="nf">symbolic_master_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symbolic Liouvillian acting on a state rho.</span>
<span class="sd">        If no rho is given, an OperatorSymbol is created in its place.</span>
<span class="sd">        This correspnds to the RHS of the master equation</span>
<span class="sd">        in which an average is taken over the external noise degrees of freedom.</span>

<span class="sd">        :param rho: A symbolic density matrix operator</span>
<span class="sd">        :type rho: Operator</span>
<span class="sd">        :return: The RHS of the master equation.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&#39;rho&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">*</span><span class="n">rho</span> <span class="o">-</span> <span class="n">rho</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">Lk</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span>
                             <span class="o">-</span>  <span class="p">(</span><span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span><span class="o">*</span><span class="n">Lk</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span><span class="o">*</span><span class="n">Lk</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                                                <span class="k">for</span> <span class="n">Lk</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>


    <span class="c">#noinspection PyRedeclaration</span></div>
<div class="viewcode-block" id="SLH.symbolic_heisenberg_eom"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SLH.symbolic_heisenberg_eom">[docs]</a>    <span class="k">def</span> <span class="nf">symbolic_heisenberg_eom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">noises</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symbolic Heisenberg equations of motion of a system operator X.</span>
<span class="sd">        If no X is given, an OperatorSymbol is created in its place.</span>
<span class="sd">        If no noises are given, this correspnds to the ensemble-averaged Heisenberg equation of motion.</span>

<span class="sd">        :param X: A system operator</span>
<span class="sd">        :type X: Operator</span>
<span class="sd">        :param noises: A vector of noise inputs</span>
<span class="sd">        :type noises: Operator</span>
<span class="sd">        :return: The RHS of the Heisenberg equations of motion of X.</span>
<span class="sd">        :rtype: Operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>

        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">OperatorSymbol</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">space</span> <span class="o">|</span> <span class="n">H</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span>  <span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="n">H</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span><span class="o">*</span> <span class="n">X</span> <span class="o">*</span> <span class="n">Lk</span> \
                    <span class="o">-</span>  <span class="p">(</span><span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span><span class="o">*</span><span class="n">Lk</span> <span class="o">*</span> <span class="n">X</span> <span class="o">+</span> <span class="n">X</span> <span class="o">*</span> <span class="n">adjoint</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span><span class="o">*</span><span class="n">Lk</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> \
                                                            <span class="k">for</span> <span class="n">Lk</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">noises</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noises</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                <span class="n">noises</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">noises</span><span class="p">)</span>
            <span class="n">LambdaT</span> <span class="o">=</span> <span class="p">(</span><span class="n">noises</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">noises</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">noises</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">adjoint</span><span class="p">(</span><span class="n">noises</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">L</span> <span class="o">-</span> <span class="n">L</span> <span class="o">*</span> <span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">evalf</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> \
                    <span class="o">+</span> <span class="p">((</span><span class="n">L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span> <span class="o">*</span> <span class="n">L</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">noises</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">space</span> <span class="o">&amp;</span> <span class="n">X</span><span class="o">.</span><span class="n">space</span><span class="p">):</span>
                <span class="n">comm</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span> <span class="o">*</span> <span class="n">X</span> <span class="o">*</span> <span class="n">S</span> <span class="o">-</span> <span class="n">X</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">+=</span>  <span class="p">(</span><span class="n">comm</span> <span class="o">*</span> <span class="n">LambdaT</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="c">#TODO implement SLH._toABCD()</span>
        <span class="k">pass</span>

<span class="c">#    def _mathematica(self):</span>
<span class="c">#        return &quot;SLH[%s, %s, %s]&quot; % (mathematica(self.S), mathematica(self.L), mathematica(self.H))</span>


<span class="c">#TODO ADD ABCD class and toABCD() methods</span></div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="ABCD"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD">[docs]</a><span class="k">class</span> <span class="nc">ABCD</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    ABCD model class in amplitude representation.</span>

<span class="sd">        ``ABCD(A, B, C, D, w, space)``</span>

<span class="sd">    I.e. for a doubled up vector a = (a_1, ..., a_n, a_1^*, ... a_n^*)^T = double_up((a_1, ..., a_n)^T)</span>
<span class="sd">    and doubled up noises dA = (dA_1, ..., dA_m, dA_1^*, ..., dA_m^*)^T = double_up((dA_1, ..., dA_n)^T)</span>
<span class="sd">    The equation of motion for a is</span>

<span class="sd">    .. math::</span>
<span class="sd">        da = A a dt + B (dA + double_up(w) dt)</span>

<span class="sd">    The output field dA&#39; is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        dA&#39; = C a dt + D (dA + double_up(w) dt)</span>


<span class="sd">    :param A: Coupling matrix: internal to internal, scalar valued elements, ``shape = (2*n,2*n)``</span>
<span class="sd">    :type A: Matrix</span>
<span class="sd">    :param B: Coupling matrix external input to internal, scalar valued elements, ``shape = (2*n,2*m)``</span>
<span class="sd">    :type B: Matrix</span>
<span class="sd">    :param C: Coupling matrix internal to external output, scalar valued elements, ``shape = (2*m,2*n)``</span>
<span class="sd">    :type C: Matrix</span>
<span class="sd">    :param D: Coupling matrix external input to output, scalar valued elements, ``shape = (2*m,2*m)``</span>
<span class="sd">    :type D: Matrix</span>
<span class="sd">    :param w: Coherent input amplitude vector, **NOT DOUBLED UP**, scalar valued elements, ``shape = (m,1)``</span>
<span class="sd">    :type w: Matrix</span>
<span class="sd">    :param space: Hilbert space with exactly n local factor spaces corresponding to the n internal degrees of freedom.</span>
<span class="sd">    :type space: HilbertSpace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">HilbertSpace</span>

    <span class="c">#noinspection PyArgumentList</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ABCD</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="ABCD.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See ABCD documentation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n2</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n2</span><span class="o">%</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m2</span><span class="o">%</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n2</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">m2</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">n2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">())</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; != &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ABCD</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.A"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.A">[docs]</a>    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coupling matrix: internal to internal, scalar valued elements, ``shape = (2*n,2*n)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.B"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.B">[docs]</a>    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coupling matrix external input to internal, scalar valued elements, ``shape = (2*n,2*m)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.C"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.C">[docs]</a>    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coupling matrix internal to external output, scalar valued elements, ``shape = (2*m,2*n)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.D"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.D">[docs]</a>    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coupling matrix external input to output, scalar valued elements, ``shape = (2*m,2*m)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.w"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.w">[docs]</a>    <span class="k">def</span> <span class="nf">w</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coherent input amplitude vector, **NOT DOUBLED UP**, scalar valued elements, ``shape = (m,1)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: HilbertSpace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.n"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.n">[docs]</a>    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of oscillators.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">())</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ABCD.m"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.ABCD.m">[docs]</a>    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of external fields.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>

    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">,</span>


    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># TODO IMPLEMENT ABCD._toSLH()</span>
        <span class="n">doubled_up_as</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">((</span><span class="n">Matrix</span><span class="p">([[</span><span class="n">Destroy</span><span class="p">(</span><span class="n">spc</span><span class="p">)</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()]])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                <span class="n">Matrix</span><span class="p">([[</span><span class="n">Create</span><span class="p">(</span><span class="n">spc</span><span class="p">)</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">local_factors</span><span class="p">()]])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

</div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="CircuitSymbol"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CircuitSymbol">[docs]</a><span class="k">class</span> <span class="nc">CircuitSymbol</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Circuit Symbol object, parametrized by an identifier and channel dimension.</span>

<span class="sd">        ``CircuitSymbol(identifier, cdim)``</span>

<span class="sd">    :type identifier: str</span>
<span class="sd">    :type cdim: int &gt;= 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">identifier_to_tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="CircuitSymbol.identifier"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CircuitSymbol.identifier">[docs]</a>    <span class="k">def</span> <span class="nf">identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The symbol identifier</span>

<span class="sd">        :type: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">CannotConvertToABCD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">CannotConvertToSLH</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_space</span> <span class="o">=</span> <span class="n">FullSpace</span>
</div>
<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">CIdentity</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Single channel circuit identity system, the neutral element of single channel series products.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_cdim</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;cid(1)&quot;</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\mathbf{1}_1&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">CannotConvertToSLH</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">]]),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ABCD</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">TrivialSpace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>


<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">CircuitZero</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The zero circuit system, the neutral element of Concatenation. No ports, no internal dynamics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_cdim</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;cid(0)&quot;</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\mathbf{1}_0&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">CannotConvertToSLH</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([[]]),</span> <span class="n">Matrix</span><span class="p">([[]]),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ABCD</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">TrivialSpace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>


<span class="n">cid_1</span> <span class="o">=</span> <span class="n">CIdentity</span>

<div class="viewcode-block" id="circuit_identity"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.circuit_identity">[docs]</a><span class="k">def</span> <span class="nf">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the circuit identity for n channels.</span>

<span class="sd">    :param n: The channel dimension</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: n-channel identity circuit</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CircuitZero</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cid_1</span>
    <span class="k">return</span> <span class="n">Concatenation</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">cid_1</span><span class="p">,)</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
</div>
<span class="n">cid</span> <span class="o">=</span> <span class="n">circuit_identity</span>



<span class="c">#noinspection PyRedeclaration,PyTypeChecker</span>
<div class="viewcode-block" id="get_common_block_structure"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.get_common_block_structure">[docs]</a><span class="k">def</span> <span class="nf">get_common_block_structure</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">,</span> <span class="n">rhs_bs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For two block structures ``aa = (a1, a2, ..., an)``, ``bb = (b1, b2, ..., bm)``</span>
<span class="sd">    generate the maximal common block structure so that every block from aa and bb</span>
<span class="sd">    is contained in exactly one block of the resulting structure.</span>
<span class="sd">    This is useful for determining how to apply the distributive law when feeding</span>
<span class="sd">    two concatenated Circuit objects into each other.</span>

<span class="sd">    Examples:</span>
<span class="sd">        ``(1, 1, 1), (2, 1) -&gt; (2, 1)``</span>
<span class="sd">        ``(1, 1, 2, 1), (2, 1, 2) -&gt; (2, 3)``</span>

<span class="sd">    :param lhs_bs: first block structure</span>
<span class="sd">    :type lhs_bs: tuple</span>
<span class="sd">    :param rhs_bs: second block structure</span>
<span class="sd">    :type rhs_bs: tuple</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># for convenience the arguments may also be Circuit objects</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
        <span class="n">lhs_bs</span> <span class="o">=</span> <span class="n">lhs_bs</span><span class="o">.</span><span class="n">block_structure</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs_bs</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
        <span class="n">rhs_bs</span> <span class="o">=</span> <span class="n">rhs_bs</span><span class="o">.</span><span class="n">block_structure</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rhs_bs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&#39;Blockstructures have different total channel numbers.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_bs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">lsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">lsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
        <span class="n">rsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rhs_bs</span><span class="p">[:</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">lsum</span> <span class="o">&lt;</span> <span class="n">rsum</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">rsum</span> <span class="o">&lt;</span> <span class="n">lsum</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">lsum</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">get_common_block_structure</span><span class="p">(</span><span class="n">lhs_bs</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">rhs_bs</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>



</div>
<div class="viewcode-block" id="check_cdims_mtd"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.check_cdims_mtd">[docs]</a><span class="k">def</span> <span class="nf">check_cdims_mtd</span><span class="p">(</span><span class="n">dcls</span><span class="p">,</span> <span class="n">clsmtd</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that all operands (`ops`) have equal channel dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">({</span><span class="n">o</span><span class="o">.</span><span class="n">cdim</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Not all operands have the same cdim:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">clsmtd</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
</div>
<span class="n">check_cdims</span> <span class="o">=</span> <span class="n">preprocess_create_with</span><span class="p">(</span><span class="n">check_cdims_mtd</span><span class="p">)</span>




<span class="nd">@assoc</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_cdims</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="SeriesProduct"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SeriesProduct">[docs]</a><span class="k">class</span> <span class="nc">SeriesProduct</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The series product circuit operation. It can be applied to any sequence of circuit objects that have equal channel dimension.</span>

<span class="sd">        ``SeriesProduct(*operands)``</span>

<span class="sd">    :param operands: Circuits in feedforward configuration.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">,</span>
    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">]</span>


    <span class="nd">@singleton</span>
<div class="viewcode-block" id="SeriesProduct.neutral_element"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SeriesProduct.neutral_element">[docs]</a>    <span class="k">class</span> <span class="nc">neutral_element</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic neutral element checker of the ``SeriesProduct``, it works for any channel dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="c">#            print &quot;neutral?&quot;, other</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="n">other</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cdim</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span><span class="o">.</span><span class="n">series_with_slh</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">creduce</span><span class="p">()</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span>  <span class="o">=</span> <span class="s">&quot; \lhd &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;{{{}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Concatenation</span><span class="p">)</span>
                                <span class="k">else</span> <span class="s">r&quot;\left({}\right)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">tex</span><span class="p">())</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
<span class="c">#        print ret</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot; &lt;&lt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Concatenation</span><span class="p">)</span>
                                <span class="k">else</span> <span class="s">r&quot;({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="c"># TODO implement SeriesProduct._toABCD()</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">TrivialSpace</span><span class="p">)</span>

</div>
<span class="nd">@assoc</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@match_replace_binary</span>
<span class="nd">@filter_neutral</span>
<span class="nd">@check_signature_assoc</span>
<div class="viewcode-block" id="Concatenation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Concatenation">[docs]</a><span class="k">class</span> <span class="nc">Concatenation</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The concatenation product circuit operation. It can be applied to any sequence of circuit objects.</span>

<span class="sd">        ``Concatenation(*operands)``</span>

<span class="sd">    :param Circuit operands: Circuits in parallel configuration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">,</span>

    <span class="n">neutral_element</span> <span class="o">=</span> <span class="n">CircuitZero</span>

    <span class="n">_binary_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ops_strs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">id_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">CIdentity</span><span class="p">:</span>
                <span class="n">id_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">id_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="s">r&quot;\mathbf{{1}}_{{{}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_count</span><span class="p">)]</span>
                    <span class="n">id_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tex</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SeriesProduct</span><span class="p">)</span> <span class="k">else</span> <span class="s">&quot;({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">tex</span><span class="p">())]</span>
        <span class="k">if</span> <span class="n">id_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="s">r&quot;\mathbf{{1}}_{{{}}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_count</span><span class="p">)]</span>
        <span class="k">return</span> <span class="s">r&quot; \boxplus &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ops_strs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ops_strs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">id_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">CIdentity</span><span class="p">:</span>
                <span class="n">id_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">id_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;cid({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_count</span><span class="p">)]</span>
                    <span class="n">id_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">SeriesProduct</span><span class="p">)</span> <span class="k">else</span> <span class="s">&quot;({!s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">id_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ops_strs</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;cid({})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_count</span><span class="p">)]</span>
        <span class="k">return</span> <span class="s">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ops_strs</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span> <span class="k">for</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span><span class="o">.</span><span class="n">concatenate_slh</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">creduce</span><span class="p">()</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">circuit</span><span class="o">.</span><span class="n">block_structure</span> <span class="k">for</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="p">())</span>


    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">):</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">block_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">op</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">()</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="p">()))</span>
        <span class="n">cbo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">block_structure</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">current_length</span> <span class="o">&lt;</span> <span class="n">bl</span><span class="p">:</span>
                <span class="n">next_op</span> <span class="o">=</span> <span class="n">block_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">cbo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_op</span><span class="p">)</span>
                <span class="n">current_length</span> <span class="o">+=</span> <span class="n">next_op</span><span class="o">.</span><span class="n">cdim</span>
            <span class="k">if</span> <span class="n">current_length</span> <span class="o">!=</span> <span class="n">bl</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">IncompatibleBlockStructures</span><span class="p">(</span><span class="s">&#39;requested blocks according to incompatible block_structure&#39;</span><span class="p">)</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">cbo</span><span class="p">))</span>
            <span class="n">cbo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">])</span>


    <span class="k">def</span> <span class="nf">_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span>

        <span class="k">if</span> <span class="n">out_index</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">in_index</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">feedback</span><span class="p">(),)))</span>


        <span class="n">in_index_in_block</span><span class="p">,</span> <span class="n">in_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_in_block</span><span class="p">(</span><span class="n">in_index</span><span class="p">)</span>
        <span class="n">out_index_in_block</span><span class="p">,</span> <span class="n">out_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_in_block</span><span class="p">(</span><span class="n">out_index</span><span class="p">)</span>


        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">in_block</span> <span class="o">==</span> <span class="n">out_block</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[:</span><span class="n">out_block</span><span class="p">])</span> \
                <span class="o">+</span> <span class="n">blocks</span><span class="p">[</span><span class="n">out_block</span><span class="p">]</span><span class="o">.</span><span class="n">feedback</span><span class="p">(</span><span class="n">out_index</span> <span class="o">=</span> <span class="n">out_index_in_block</span><span class="p">,</span> <span class="n">in_index</span> <span class="o">=</span> <span class="n">in_index_in_block</span><span class="p">)</span> \
                <span class="o">+</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[</span><span class="n">out_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="c">### no &#39;real&#39; feedback loop, just an effective series</span>
        <span class="c">#partition all blocks into just two</span>


        <span class="k">if</span> <span class="n">in_block</span> <span class="o">&lt;</span> <span class="n">out_block</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[:</span><span class="n">out_block</span><span class="p">])</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[</span><span class="n">out_block</span><span class="p">:])</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">b1</span> <span class="o">+</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  \
                    <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">out_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span><span class="n">in_index</span><span class="p">},</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> \
                        <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">circuit_identity</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[:</span><span class="n">in_block</span><span class="p">])</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">[</span><span class="n">in_block</span><span class="p">:])</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">circuit_identity</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> \
                    <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">out_index</span> <span class="p">:</span> <span class="n">in_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">},</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> \
                        <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">b1</span> <span class="o">+</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="c"># TODO implement Concatenation._toABCD()</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">space</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span> <span class="n">TrivialSpace</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="CannotFactorize"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CannotFactorize">[docs]</a><span class="k">class</span> <span class="nc">CannotFactorize</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


</div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="CPermutation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CPermutation">[docs]</a><span class="k">class</span> <span class="nc">CPermutation</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The channel permuting circuit. This circuit expression is only a rearrangement of input and output fields.</span>
<span class="sd">    A channel permutation is given as a tuple of image points. Permutations are usually represented as</span>

<span class="sd">    A permutation :math:`\sigma \in \Sigma_n` of :math:`n` elements  is often represented in the following form</span>

<span class="sd">    .. math::</span>
<span class="sd">         \begin{pmatrix}</span>
<span class="sd">                1           &amp;       2   &amp; \dots &amp;   n       \\</span>
<span class="sd">                \sigma(1)   &amp; \sigma(2) &amp; \dots &amp; \sigma(n)</span>
<span class="sd">        \end{pmatrix},</span>

<span class="sd">    but obviously it is fully sufficient to specify the tuple of images :math:`(\sigma(1), \sigma(2), \dots, \sigma(n))`.</span>
<span class="sd">    We thus parametrize our permutation circuits only in terms of the image tuple.</span>
<span class="sd">    Moreover, we will be working with *zero-based indices*!</span>

<span class="sd">    A channel permutation circuit for a given permutation (represented as a python tuple of image indices)</span>
<span class="sd">    scatters the :math:`j`-th input field to the :math:`\sigma(j)`-th output field.</span>

<span class="sd">    It is instantiated as</span>

<span class="sd">        ``CPermutation(permutation)``</span>

<span class="sd">    :param permutation: Channel permutation image tuple.</span>
<span class="sd">    :type permutation: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">,</span>

    <span class="c">#noinspection PyDocstring</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="CPermutation.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CPermutation.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See CPermutation docs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check_permutation</span><span class="p">(</span><span class="n">permutation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">BadPermutationError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">cid</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CPermutation</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
</div>
    <span class="n">_block_perms</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="CPermutation.block_perms"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CPermutation.block_perms">[docs]</a>    <span class="k">def</span> <span class="nf">block_perms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the circuit is reducible into permutations within subranges of the full range of channels,</span>
<span class="sd">        this yields a tuple with the internal permutations for each such block.</span>

<span class="sd">        :type: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_perms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_block_perms</span> <span class="o">=</span> <span class="n">permutation_to_block_permutations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_perms</span>

</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="CPermutation.permutation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CPermutation.permutation">[docs]</a>    <span class="k">def</span> <span class="nf">permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The permutation image tuple.</span>

<span class="sd">        :type: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SLH</span><span class="p">(</span><span class="n">permutation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">),</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linearize</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span><span class="o">.</span><span class="n">toABCD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;P_sigma{!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;\mathbf{{P}}_\sigma </span><span class="se">\\</span><span class="s">begin{{pmatrix}} {} </span><span class="se">\\</span><span class="s">\ {} </span><span class="se">\\</span><span class="s">end{{pmatrix}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">))),</span> <span class="s">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">)))</span>

<div class="viewcode-block" id="CPermutation.series_with_permutation"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.CPermutation.series_with_permutation">[docs]</a>    <span class="k">def</span> <span class="nf">series_with_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the series product with another channel permutation circuit.</span>

<span class="sd">        :type other: CPermutation</span>
<span class="sd">        :return: The composite permutation circuit (could also be the identity circuit for n channels)</span>
<span class="sd">        :rtype: Circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_permutation</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">permutation</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">combined_permutation</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CPermutation</span><span class="p">(</span><span class="n">invert_permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_perms</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">):</span>

        <span class="n">block_perms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">block_structure</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_perms</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_structure</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_perms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">block_structure</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="n">current_perm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">block_perm_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_perms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block_structure</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_perm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_perm</span><span class="p">)</span>
                <span class="n">current_perm</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">block_perm_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
                <span class="c"># print block_structure, self.block_perms, block_perms</span>
                <span class="k">raise</span> <span class="ne">Exception</span>

            <span class="n">block_perms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">current_perm</span><span class="p">))</span>
            <span class="n">current_perm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">,</span> <span class="n">block_perms</span><span class="p">))</span>



    <span class="k">def</span> <span class="nf">_factorize_for_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factorize a channel permutation circuit according the block structure of the upstream circuit.</span>
<span class="sd">        This allows to move as much of the permutation as possible *around* a reducible circuit upstream.</span>
<span class="sd">        It basically decomposes</span>

<span class="sd">            ``permutation &lt;&lt; rhs --&gt; permutation&#39; &lt;&lt; rhs&#39; &lt;&lt; residual&#39;``</span>

<span class="sd">        where rhs&#39; is just a block permutated version of rhs and residual&#39;</span>
<span class="sd">        is the maximal part of the permutation that one may move around rhs.</span>

<span class="sd">        :param rhs: An upstream circuit object</span>
<span class="sd">        :type rhs: Circuit</span>
<span class="sd">        :return: new_lhs_circuit, permuted_rhs_circuit, new_rhs_circuit</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        :raise: BadPermutationError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_structure</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">block_structure</span>

        <span class="n">block_perm</span><span class="p">,</span> <span class="n">perms_within_blocks</span> <span class="o">=</span> <span class="n">block_perm_and_perms_within_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">)</span>
        <span class="n">fblockp</span> <span class="o">=</span> <span class="n">full_block_perm</span><span class="p">(</span><span class="n">block_perm</span><span class="p">,</span> <span class="n">block_structure</span><span class="p">)</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fblockp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">BadPermutationError</span><span class="p">()</span>


        <span class="n">new_rhs_circuit</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">fblockp</span><span class="p">)</span>
        <span class="n">within_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">within_block</span><span class="p">)</span> <span class="k">for</span> <span class="n">within_block</span> <span class="ow">in</span> <span class="n">perms_within_blocks</span><span class="p">]</span>
        <span class="n">within_perm_circuit</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">within_blocks</span><span class="p">,</span> <span class="n">cid</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">rhs_blocks</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">block_structure</span><span class="p">)</span>

        <span class="n">permuted_rhs_circuit</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">within_blocks</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">rhs_blocks</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> \
                                                                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">invert_permutation</span><span class="p">(</span><span class="n">block_perm</span><span class="p">)])</span>

        <span class="n">new_lhs_circuit</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">within_perm_circuit</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">new_rhs_circuit</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span>


        <span class="k">return</span> <span class="n">new_lhs_circuit</span><span class="p">,</span> <span class="n">permuted_rhs_circuit</span><span class="p">,</span> <span class="n">new_rhs_circuit</span>




    <span class="k">def</span> <span class="nf">_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span>
        <span class="n">new_perm_circuit</span> <span class="o">=</span> <span class="n">map_signals_circuit</span><span class="p">(</span> <span class="p">{</span><span class="n">out_index</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)},</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">in_index</span><span class="p">},</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_perm_circuit</span> <span class="o">==</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_perm_circuit</span><span class="o">.</span><span class="n">permutation</span><span class="p">)</span>
        <span class="n">n_inv</span> <span class="o">=</span> <span class="n">new_perm</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_perm</span><span class="p">[</span><span class="n">n_inv</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_perm</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_perm</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>


    <span class="k">def</span> <span class="nf">_factor_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With::</span>

<span class="sd">            n           := self.cdim</span>
<span class="sd">            in_im       := self.permutation[in_index]</span>
<span class="sd">            m_{k-&gt;l}    := map_signals_circuit({k:l}, n)</span>

<span class="sd">        solve the equation (I) containing ``self``::</span>

<span class="sd">            self &lt;&lt; m_{(n-1) -&gt; in_index} == m_{(n-1) -&gt; in_im} &lt;&lt; (red_self + cid(1))          (I)</span>

<span class="sd">        for the (n-1) channel CPermutation ``red_self``.</span>
<span class="sd">        Return in_im, red_self.</span>

<span class="sd">        This is useful when ``self`` is the RHS in a SeriesProduct Object that is within a Feedback loop</span>
<span class="sd">        as it allows to extract the feedback channel from the permutation and moving the</span>
<span class="sd">        remaining part of the permutation (``red_self``) outside of the feedback loop.</span>

<span class="sd">        :param int in_index: The index for which to factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">in_index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="n">in_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">[</span><span class="n">in_index</span><span class="p">]</span>
        <span class="c"># (I) is equivalent to</span>
        <span class="c">#       m_{in_im -&gt; (n-1)} &lt;&lt;  self &lt;&lt; m_{(n-1) -&gt; in_index} == (red_self + cid(1))     (I&#39;)</span>
        <span class="n">red_self_plus_cid1</span> <span class="o">=</span> <span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">in_im</span><span class="p">:(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)},</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="n">in_index</span><span class="p">},</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">red_self_plus_cid1</span><span class="p">,</span> <span class="n">CPermutation</span><span class="p">):</span>

            <span class="c">#make sure we can factor</span>
            <span class="c">#noinspection PyUnresolvedReferences</span>
            <span class="k">assert</span> <span class="n">red_self_plus_cid1</span><span class="o">.</span><span class="n">permutation</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c">#form reduced permutation object</span>
            <span class="n">red_self</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">red_self_plus_cid1</span><span class="o">.</span><span class="n">permutation</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">in_im</span><span class="p">,</span> <span class="n">red_self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># &#39;red_self_plus_cid1&#39; must be the identity for n channels.</span>
            <span class="c"># Actually, this case can only occur</span>
            <span class="c"># when self == m_{in_index -&gt;  in_im}</span>

            <span class="k">return</span> <span class="n">in_im</span><span class="p">,</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_factor_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With::</span>

<span class="sd">            n           := self.cdim</span>
<span class="sd">            out_inv     := invert_permutation(self.permutation)[out_index]</span>
<span class="sd">            m_{k-&gt;l}    := map_signals_circuit({k:l}, n)</span>

<span class="sd">        solve the equation (I) containing ``self``::</span>

<span class="sd">            m_{out_index -&gt; (n-1)} &lt;&lt; self == (red_self + cid(1)) &lt;&lt; m_{out_inv -&gt; (n-1)}           (I)</span>

<span class="sd">        for the (n-1) channel CPermutation ``red_self``.</span>
<span class="sd">        Return out_inv, red_self.</span>

<span class="sd">        This is useful when &#39;self&#39; is the LHS in a SeriesProduct Object that is within a Feedback loop</span>
<span class="sd">        as it allows to extract the feedback channel from the permutation and moving the</span>
<span class="sd">        remaining part of the permutation (``red_self``) outside of the feedback loop.</span>

<span class="sd">        :param out_index: The index for which to factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">out_index</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">print</span> <span class="bp">self</span><span class="p">,</span> <span class="n">out_index</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="n">out_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">out_index</span><span class="p">)</span>

        <span class="c"># (I) is equivalent to</span>
        <span class="c">#       m_{out_index -&gt; (n-1)} &lt;&lt;  self &lt;&lt; m_{(n-1) -&gt; out_inv} == (red_self + cid(1))     (I&#39;)</span>

        <span class="n">red_self_plus_cid1</span> <span class="o">=</span> <span class="n">map_signals_circuit</span><span class="p">({</span><span class="n">out_index</span><span class="p">:(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)},</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">map_signals_circuit</span><span class="p">({(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="n">out_inv</span><span class="p">},</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">red_self_plus_cid1</span><span class="p">,</span> <span class="n">CPermutation</span><span class="p">):</span>

            <span class="c">#make sure we can factor</span>
            <span class="k">assert</span> <span class="n">red_self_plus_cid1</span><span class="o">.</span><span class="n">permutation</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c">#form reduced permutation object</span>
            <span class="n">red_self</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">red_self_plus_cid1</span><span class="o">.</span><span class="n">permutation</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">out_inv</span><span class="p">,</span> <span class="n">red_self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># &#39;red_self_plus_cid1&#39; must be the identity for n channels.</span>
            <span class="c"># Actually, this case can only occur</span>
            <span class="c"># when self == m_{in_index -&gt;  in_im}</span>

            <span class="k">return</span> <span class="n">out_inv</span><span class="p">,</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrivialSpace</span>


</div>
<div class="viewcode-block" id="P_sigma"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.P_sigma">[docs]</a><span class="k">def</span> <span class="nf">P_sigma</span><span class="p">(</span><span class="o">*</span><span class="n">permutation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a channel permutation circuit for the given index image values.</span>
<span class="sd">    :param permutation: image points</span>
<span class="sd">    :type permutation: int</span>
<span class="sd">    :return: CPermutation.create(permutation)</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="extract_signal"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.extract_signal">[docs]</a><span class="k">def</span> <span class="nf">extract_signal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a permutation that maps the k-th (zero-based) element to the last element,</span>
<span class="sd">    while preserving the relative order of all other elements.</span>
<span class="sd">    :param k: The index to extract</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :param n: The total number of elements</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: Permutation image tuple</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="extract_signal_circuit"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.extract_signal_circuit">[docs]</a><span class="k">def</span> <span class="nf">extract_signal_circuit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">cdim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a channel permutation circuit that maps the k-th (zero-based) input to the last output,</span>
<span class="sd">    while preserving the relative order of all other channels.</span>
<span class="sd">    :param k: Extracted channel index</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :param cdim: The channel dimension</span>
<span class="sd">    :type cdim: int</span>
<span class="sd">    :return: Permutation circuit</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">extract_signal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">cdim</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="map_signals"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.map_signals">[docs]</a><span class="k">def</span> <span class="nf">map_signals</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given {input:output} mapping in form of a dictionary,</span>
<span class="sd">    generate the permutation that achieves the specified mapping</span>
<span class="sd">    while leaving the relative order of all non-specified elements intact.</span>
<span class="sd">    :param mapping: Input-output mapping of indices (zero-based) {in1:out1, in2:out2,...}</span>
<span class="sd">    :type mapping: dict</span>
<span class="sd">    :param n: total number of elements</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: Signal mapping permutation image tuple</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    :raise: ValueError</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">free_values</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;the mapping cannot take on values larger than cdim - 1&#39;</span><span class="p">)</span>
        <span class="n">free_values</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;the mapping cannot map keys larger than cdim - 1&#39;</span><span class="p">)</span>
    <span class="c"># sorted(set(range(n)).difference(set(mapping.values())))</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># print free_values, mapping, n</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
            <span class="n">permutation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">permutation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">free_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="c"># print permutation</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="map_signals_circuit"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.map_signals_circuit">[docs]</a><span class="k">def</span> <span class="nf">map_signals_circuit</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given {input:output} mapping in form of a dictionary,</span>
<span class="sd">    generate the channel permutating circuit that achieves the specified mapping</span>
<span class="sd">    while leaving the relative order of all non-specified channels intact.</span>
<span class="sd">    :param mapping: Input-output mapping of indices (zero-based) {in1:out1, in2:out2,...}</span>
<span class="sd">    :type mapping: dict</span>
<span class="sd">    :param n: total number of elements</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: Signal mapping permutation image tuple</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">map_signals</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>


</div>
<div class="viewcode-block" id="pad_with_identity"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.pad_with_identity">[docs]</a><span class="k">def</span> <span class="nf">pad_with_identity</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad a circuit by &#39;inserting&#39; an n-channel identity circuit at index k.</span>
<span class="sd">    I.e., a circuit of channel dimension N is extended to one of channel dimension N+n, where the channels</span>
<span class="sd">    k, k+1, ...k+n-1, just pass through the system unaffected.</span>
<span class="sd">    E.g. let A, B be two single channel systems</span>

<span class="sd">        &gt;&gt;&gt; A = CircuitSymbol(&#39;A&#39;, 1)</span>
<span class="sd">        &gt;&gt;&gt; B = CircuitSymbol(&#39;B&#39;, 1)</span>
<span class="sd">        &gt;&gt;&gt; pad_with_identity(A+B, 1, 2)</span>
<span class="sd">            (A + cid(2) + B)</span>

<span class="sd">    This method can also be applied to irreducible systems, but in that case the result can not be decomposed as nicely.</span>

<span class="sd">    :type circuit: Circuit</span>
<span class="sd">    :param k: The index at which to insert the circuit</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :param n: The number of channels to pass through</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :return: An extended circuit that passes through the channels k, k+1, ..., k+n-1</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuit_n</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span>
    <span class="n">combined_circuit</span> <span class="o">=</span> <span class="n">circuit</span> <span class="o">+</span> <span class="n">circuit_identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">circuit_n</span><span class="p">,</span> <span class="n">circuit_n</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">circuit_n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">invert_permutation</span><span class="p">(</span><span class="n">permutation</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">combined_circuit</span> <span class="o">&lt;&lt;</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>


</div>
<span class="nd">@match_replace</span>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="Feedback"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Feedback">[docs]</a><span class="k">class</span> <span class="nc">Feedback</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The circuit feedback operation applied to a circuit of channel dimension &gt; 1</span>
<span class="sd">    and an from an output port index to an input port index.</span>

<span class="sd">        ``Feedback(circuit, out_index, in_index)``</span>

<span class="sd">    :param circuit: The circuit that undergoes self-feedback</span>
<span class="sd">    :type circuit: Circuit</span>
<span class="sd">    :param out_index: The output port index.</span>
<span class="sd">    :type out_index: int</span>
<span class="sd">    :param in_index: The input port index.</span>
<span class="sd">    :type in_index: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delegate_to_method</span> <span class="o">=</span> <span class="p">(</span><span class="n">Concatenation</span><span class="p">,</span> <span class="n">SLH</span><span class="p">,</span> <span class="n">CPermutation</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span>

    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Feedback.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Feedback.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The circuit that undergoes feedback</span>
<span class="sd">        :rtype: Circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Feedback.out_in_pair"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Feedback.out_in_pair">[docs]</a>    <span class="k">def</span> <span class="nf">out_in_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zero-based feedback port indices (out_index, in_index)</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operands</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c">#noinspection PyUnresolvedReferences</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Feedback.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.Feedback.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See :py:class:Feedback: documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">delegate_to_method</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_feedback</span><span class="p">(</span><span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Feedback</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span><span class="o">.</span><span class="n">feedback</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># TODO implement Feedback._toABCD()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">creduce</span><span class="p">()</span><span class="o">.</span><span class="n">feedback</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span><span class="p">)</span>


<span class="c">#    def substitute(self, var_map):</span>
<span class="c">#        op = substitute(self.operand, var_map)</span>
<span class="c">#        return op.feedback(*self.out_in_pair)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&quot;FB(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span>
        <span class="n">o</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span>
        <span class="k">return</span> <span class="s">&quot;FB(</span><span class="si">%s</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">o</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdim</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&quot;\left\lfloor</span><span class="si">%s</span><span class="se">\\</span><span class="s">right</span><span class="se">\\</span><span class="s">rfloor&quot;</span> <span class="o">%</span> <span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;\left\lfloor</span><span class="si">%s</span><span class="se">\\</span><span class="s">right</span><span class="se">\\</span><span class="s">rfloor_{</span><span class="si">%d</span><span class="se">\\</span><span class="s">to</span><span class="si">%d</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">),</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_series_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">(),</span> <span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_in_pair</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">space</span>


<span class="c">#noinspection PyRedeclaration</span></div>
<div class="viewcode-block" id="FB"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.FB">[docs]</a><span class="k">def</span> <span class="nf">FB</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">out_index</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">in_index</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for :py:class:Feedback: but with additional default values.</span>

<span class="sd">        ``FB(circuit, out_index = None, in_index = None)``</span>

<span class="sd">    :param circuit: The circuit that undergoes self-feedback</span>
<span class="sd">    :type circuit: Circuit</span>
<span class="sd">    :param out_index: The output port index, default = None --&gt; last port</span>
<span class="sd">    :type out_index: int</span>
<span class="sd">    :param in_index: The input port index, default = None --&gt; last port</span>
<span class="sd">    :type in_index: int</span>
<span class="sd">    :return: The circuit with applied feedback operation.</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out_index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out_index</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">in_index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">in_index</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>
</div>
<span class="nd">@check_signature</span>
<div class="viewcode-block" id="SeriesInverse"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SeriesInverse">[docs]</a><span class="k">class</span> <span class="nc">SeriesInverse</span><span class="p">(</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Symbolic series product inversion operation.</span>

<span class="sd">        ``SeriesInverse(circuit)``</span>

<span class="sd">    One generally has</span>

<span class="sd">        &gt;&gt;&gt; SeriesInverse(circuit) &lt;&lt; circuit == cid(circuit.cdim)</span>
<span class="sd">            True</span>

<span class="sd">    and</span>

<span class="sd">        &gt;&gt;&gt; circuit &lt;&lt; SeriesInverse(circuit) == cid(circuit.cdim)</span>
<span class="sd">            True</span>

<span class="sd">    :param Circuit circuit: The circuit system to invert.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">,</span>

    <span class="n">delegate_to_method</span> <span class="o">=</span> <span class="p">(</span><span class="n">SeriesProduct</span><span class="p">,</span> <span class="n">Concatenation</span><span class="p">,</span> <span class="n">Feedback</span><span class="p">,</span> <span class="n">SLH</span><span class="p">,</span> <span class="n">CPermutation</span><span class="p">,</span> <span class="n">CIdentity</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SeriesInverse.operand"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SeriesInverse.operand">[docs]</a>    <span class="k">def</span> <span class="nf">operand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The un-inverted circuit</span>

<span class="sd">        :rtype: Circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SeriesInverse.create"><a class="viewcode-back" href="../../../qnet.algebra.html#qnet.algebra.circuit_algebra.SeriesInverse.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">circuit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See documentation for :py:class:`SeriesProduct`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">SeriesInverse</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">circuit</span><span class="o">.</span><span class="n">operand</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">delegate_to_method</span><span class="p">):</span>
            <span class="c">#noinspection PyUnresolvedReferences</span>
            <span class="k">return</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_series_inverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SeriesInverse</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">cdim</span>


    <span class="k">def</span> <span class="nf">_toSLH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">toSLH</span><span class="p">()</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_toABCD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AlgebraError</span><span class="p">(</span><span class="s">&quot;SeriesInverse not well-defined in ABCD model context&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_creduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">creduce</span><span class="p">()</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_map</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_map</span><span class="p">)</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">space</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;[{!s}]^(-1)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">r&quot;\left[ {} \right]^{{\lhd -1}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>

</div>
<span class="k">def</span> <span class="nf">_tensor_decompose_series</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplification method for lhs &lt;&lt; rhs</span>
<span class="sd">    Decompose a series product of two reducible circuits with compatible block structures into</span>
<span class="sd">    a concatenation of individual series products between subblocks.</span>
<span class="sd">    This method raises CannotSimplify when rhs is a CPermutation in order not to conflict with other _rules.</span>
<span class="sd">    :type lhs: Circuit</span>
<span class="sd">    :type rhs: Circuit</span>
<span class="sd">    :return: The combined reducible circuit</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    :raise: CannotSimplify</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">CPermutation</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>
    <span class="n">res_struct</span> <span class="o">=</span> <span class="n">get_common_block_structure</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">block_structure</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">block_structure</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_struct</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">oblocks</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">res_struct</span><span class="p">),</span> <span class="n">rhs</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">res_struct</span><span class="p">)</span>
        <span class="n">parallel_series</span> <span class="o">=</span> <span class="p">[</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">rb</span><span class="p">)</span>  <span class="k">for</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">rb</span><span class="p">)</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">oblocks</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">Concatenation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">parallel_series</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_factor_permutation_for_blocks</span><span class="p">(</span><span class="n">cperm</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplification method for cperm &lt;&lt; rhs.</span>
<span class="sd">    Decompose a series product of a channel permutation and a reducible circuit with appropriate block structure</span>
<span class="sd">    by decomposing the permutation into a permutation within each block of rhs and a block permutation and a residual part.</span>
<span class="sd">    This allows for achieving something close to a normal form for circuit expression.</span>
<span class="sd">    :type cperm: CPermutation</span>
<span class="sd">    :type rhs: Circuit</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    :raise: CannotSimplify</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rbs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">block_structure</span>
    <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">cdim</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cperm</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">residual_lhs</span><span class="p">,</span> <span class="n">transformed_rhs</span><span class="p">,</span> <span class="n">carried_through_lhs</span> <span class="o">=</span> <span class="n">cperm</span><span class="o">.</span><span class="n">_factorize_for_rhs</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">residual_lhs</span> <span class="o">==</span> <span class="n">cperm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">residual_lhs</span><span class="p">,</span> <span class="n">transformed_rhs</span><span class="p">,</span> <span class="n">carried_through_lhs</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_pull_out_perm_lhs</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pull out a permutation from the Feedback of a SeriesProduct with itself.</span>

<span class="sd">    :param lhs: The permutation circuit</span>
<span class="sd">    :type lhs: CPermutation</span>
<span class="sd">    :param rest: The other SeriesProduct operands</span>
<span class="sd">    :type rest: OperandsTuple</span>
<span class="sd">    :param out_index: The feedback output port index</span>
<span class="sd">    :type out_index: int</span>
<span class="sd">    :param in_index: The feedback input port index</span>
<span class="sd">    :type in_index: int</span>
<span class="sd">    :return: The simplified circuit</span>
<span class="sd">    :rtype: Circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_inv</span> <span class="p">,</span> <span class="n">lhs_red</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">_factor_lhs</span><span class="p">(</span><span class="n">out_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lhs_red</span> <span class="o">&lt;&lt;</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">),</span> <span class="n">out_inv</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_pull_out_unaffected_blocks_lhs</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rest</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In a self-Feedback of a series product, where the left-most operand is reducible,</span>
<span class="sd">    pull all non-trivial blocks outside of the feedback.</span>

<span class="sd">   :param lhs: The reducible circuit</span>
<span class="sd">   :type lhs: Circuit</span>
<span class="sd">   :param rest: The other SeriesProduct operands</span>
<span class="sd">   :type rest: OperandsTuple</span>
<span class="sd">   :param out_index: The feedback output port index</span>
<span class="sd">   :type out_index: int</span>
<span class="sd">   :param in_index: The feedback input port index</span>
<span class="sd">   :type in_index: int</span>
<span class="sd">   :return: The simplified circuit</span>
<span class="sd">   :rtype: Circuit</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">index_in_block</span><span class="p">(</span><span class="n">out_index</span><span class="p">)</span>

    <span class="n">bs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">block_structure</span>

    <span class="n">nbefore</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">nafter</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">[:</span><span class="n">block_index</span><span class="p">]),</span> <span class="n">bs</span><span class="p">[</span><span class="n">block_index</span><span class="p">],</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">((</span><span class="n">nbefore</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">nafter</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">before</span> <span class="o">!=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nbefore</span><span class="p">)</span> <span class="ow">or</span> <span class="n">after</span> <span class="o">!=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nafter</span><span class="p">):</span>
        <span class="n">outer_lhs</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">after</span>
        <span class="n">inner_lhs</span> <span class="o">=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nbefore</span><span class="p">)</span> <span class="o">+</span> <span class="n">block</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nafter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outer_lhs</span> <span class="o">&lt;&lt;</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">inner_lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">),</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">block</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span><span class="p">):</span>
        <span class="n">outer_lhs</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">after</span>
        <span class="k">return</span> <span class="n">outer_lhs</span> <span class="o">&lt;&lt;</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">),</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>


<span class="c">#noinspection PyDocstring</span>
<span class="k">def</span> <span class="nf">_pull_out_perm_rhs</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similar to :py:func:_pull_out_perm_lhs: but on the RHS of a series product self-feedback.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in_im</span><span class="p">,</span> <span class="n">rhs_red</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">_factor_rhs</span><span class="p">(</span><span class="n">in_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">),</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_im</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">rhs_red</span>

<span class="k">def</span> <span class="nf">_pull_out_unaffected_blocks_rhs</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Similar to :py:func:_pull_out_unaffected_blocks_lhs: but on the RHS of a series product self-feedback.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">index_in_block</span><span class="p">(</span><span class="n">in_index</span><span class="p">)</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">block_structure</span>
    <span class="n">nbefore</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">nafter</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">[:</span><span class="n">block_index</span><span class="p">]),</span> <span class="n">bs</span><span class="p">[</span><span class="n">block_index</span><span class="p">],</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">((</span><span class="n">nbefore</span><span class="p">,</span> <span class="n">nblock</span><span class="p">,</span> <span class="n">nafter</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">before</span> <span class="o">!=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nbefore</span><span class="p">)</span> <span class="ow">or</span> <span class="n">after</span> <span class="o">!=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nafter</span><span class="p">):</span>
        <span class="n">outer_rhs</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">after</span>
        <span class="n">inner_rhs</span> <span class="o">=</span> <span class="n">cid</span><span class="p">(</span><span class="n">nbefore</span><span class="p">)</span> <span class="o">+</span> <span class="n">block</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nafter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">rest</span> <span class="o">+</span> <span class="p">(</span><span class="n">inner_rhs</span><span class="p">,))),</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">outer_rhs</span>
    <span class="k">elif</span> <span class="n">block</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span><span class="p">):</span>
        <span class="n">outer_rhs</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">nblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">after</span>
        <span class="k">return</span> <span class="n">Feedback</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">),</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">outer_rhs</span>
    <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>


<span class="c">#noinspection PyDocstring</span>
<span class="k">def</span> <span class="nf">_series_feedback</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invert a series self-feedback twice to get rid of unnecessary permutations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">series_s</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">series_s</span> <span class="o">==</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CannotSimplify</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">series_s</span><span class="o">.</span><span class="n">feedback</span><span class="p">(</span><span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

<span class="n">A_CPermutation</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="p">)</span>
<span class="n">B_CPermutation</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="p">)</span>
<span class="n">C_CPermutation</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="p">)</span>
<span class="n">D_CPermutation</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">CPermutation</span><span class="p">)</span>

<span class="n">A_Concatenation</span><span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="p">)</span>
<span class="n">B_Concatenation</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Concatenation</span><span class="p">)</span>

<span class="n">A_SeriesProduct</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">SeriesProduct</span><span class="p">)</span>

<span class="n">A_Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>
<span class="n">B_Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>
<span class="n">C_Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>

<span class="n">A__Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A__&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>
<span class="n">B__Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B__&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>
<span class="n">C__Circuit</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;C__&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">)</span>

<span class="n">A_SLH</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">SLH</span><span class="p">)</span>
<span class="n">B_SLH</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">SLH</span><span class="p">)</span>

<span class="n">A_ABCD</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">ABCD</span><span class="p">)</span>
<span class="n">B_ABCD</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="n">ABCD</span><span class="p">)</span>

<span class="n">j_int</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">k_int</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">SeriesProduct</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">A_CPermutation</span><span class="p">,</span> <span class="n">B_CPermutation</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">series_with_permutation</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_SLH</span><span class="p">,</span> <span class="n">B_SLH</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">series_with_slh</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_ABCD</span><span class="p">,</span> <span class="n">B_ABCD</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">series_with_abcd</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_Circuit</span><span class="p">,</span> <span class="n">B_Circuit</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">_tensor_decompose_series</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_CPermutation</span><span class="p">,</span> <span class="n">B_Circuit</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">_factor_permutation_for_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">Concatenation</span><span class="o">.</span><span class="n">_binary_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">A_SLH</span><span class="p">,</span> <span class="n">B_SLH</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenate_slh</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_ABCD</span><span class="p">,</span> <span class="n">B_ABCD</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenate_abcd</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">A_CPermutation</span><span class="p">,</span> <span class="n">B_CPermutation</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">concatenate_permutations</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span>
    <span class="p">((</span><span class="n">A_CPermutation</span><span class="p">,</span> <span class="n">CIdentity</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">concatenate_permutations</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)))),</span>
    <span class="p">((</span><span class="n">CIdentity</span><span class="p">,</span> <span class="n">B_CPermutation</span> <span class="p">),</span> <span class="k">lambda</span> <span class="n">B</span><span class="p">:</span> <span class="n">CPermutation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">concatenate_permutations</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">B</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A__Circuit</span><span class="p">,</span> <span class="n">B_CPermutation</span><span class="p">),</span> <span class="n">SeriesProduct</span><span class="p">(</span><span class="n">C__Circuit</span><span class="p">,</span> <span class="n">D_CPermutation</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">:</span> <span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">C</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="n">D</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A__Circuit</span><span class="p">,</span> <span class="n">B_CPermutation</span><span class="p">),</span> <span class="n">C_Circuit</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">+</span> <span class="n">cid</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">cdim</span><span class="p">))),</span>
    <span class="p">((</span><span class="n">A_Circuit</span><span class="p">,</span> <span class="n">SeriesProduct</span><span class="p">(</span><span class="n">B__Circuit</span><span class="p">,</span> <span class="n">C_CPermutation</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">SeriesProduct</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">*</span><span class="n">B</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cid</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">Feedback</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">A_SeriesProduct</span><span class="p">,</span> <span class="n">j_int</span><span class="p">,</span> <span class="n">k_int</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_series_feedback</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A_CPermutation</span><span class="p">,</span> <span class="n">B__Circuit</span><span class="p">),</span><span class="n">j_int</span><span class="p">,</span> <span class="n">k_int</span> <span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_pull_out_perm_lhs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A_Concatenation</span><span class="p">,</span> <span class="n">B__Circuit</span><span class="p">),</span><span class="n">j_int</span><span class="p">,</span> <span class="n">k_int</span> <span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_pull_out_unaffected_blocks_lhs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A__Circuit</span><span class="p">,</span> <span class="n">B_CPermutation</span><span class="p">),</span><span class="n">j_int</span><span class="p">,</span> <span class="n">k_int</span> <span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_pull_out_perm_rhs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)),</span>
    <span class="p">((</span><span class="n">SeriesProduct</span><span class="p">(</span><span class="n">A__Circuit</span><span class="p">,</span> <span class="n">B_Concatenation</span><span class="p">),</span><span class="n">j_int</span><span class="p">,</span> <span class="n">k_int</span> <span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_pull_out_unaffected_blocks_rhs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)),</span>
<span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">QNET 0.9 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Nikolas Tezak.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>