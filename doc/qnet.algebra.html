

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>algebra Package &mdash; QNET 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/mycss.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/mathjax_cancel.js"></script>
    <link rel="top" title="QNET 1.0 documentation" href="index.html" />
    <link rel="up" title="The qnet API" href="qnet.html" />
    <link rel="next" title="circuit_components Package" href="qnet.circuit_components.html" />
    <link rel="prev" title="The qnet API" href="qnet.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qnet.circuit_components.html" title="circuit_components Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="qnet.html" title="The qnet API"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="qnet.html" accesskey="U">The <tt class="docutils literal docutils literal docutils literal"><span class="pre">qnet</span></tt> API</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">algebra Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">algebra</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-qnet.algebra.abstract_algebra"><tt class="docutils literal"><span class="pre">abstract_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#abstract-algebra">Abstract Algebra</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qnet.algebra.hilbert_space_algebra"><tt class="docutils literal"><span class="pre">hilbert_space_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#the-hilbert-space-algebra">The Hilbert Space Algebra</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qnet.algebra.operator_algebra"><tt class="docutils literal"><span class="pre">operator_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#operator-algebra">Operator Algebra</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qnet.algebra.permutations"><tt class="docutils literal"><span class="pre">permutations</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-qnet.algebra.circuit_algebra"><tt class="docutils literal"><span class="pre">circuit_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#circuit-algebra">Circuit Algebra</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qnet.algebra.state_algebra"><tt class="docutils literal"><span class="pre">state_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#state-algebra">State Algebra</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qnet.algebra.super_operator_algebra"><tt class="docutils literal"><span class="pre">super_operator_algebra</span></tt> Module</a><ul>
<li><a class="reference internal" href="#super-operator-algebra">Super-Operator Algebra</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="qnet.html"
                        title="previous chapter">The <tt class="docutils literal docutils literal"><span class="pre">qnet</span></tt> API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="qnet.circuit_components.html"
                        title="next chapter">circuit_components Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/qnet.algebra.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="algebra-package">
<h1>algebra Package<a class="headerlink" href="#algebra-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">algebra</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-qnet.algebra"></span></div>
<div class="section" id="module-qnet.algebra.abstract_algebra">
<span id="abstract-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">abstract_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.abstract_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="abstract-algebra">
<h3>Abstract Algebra<a class="headerlink" href="#abstract-algebra" title="Permalink to this headline">¶</a></h3>
<p>The abstract algebra package provides a basic interface for defining custom Algebras.</p>
<p>See <a class="reference internal" href="symbolic_algebra.html#abstract-algebra"><em>The Abstract Algebra module</em></a> for more details.</p>
<dl class="exception">
<dt id="qnet.algebra.abstract_algebra.AlgebraError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">AlgebraError</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#AlgebraError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.AlgebraError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
<p>Base class for all errors concerning the mathematical definitions and rules of an algebra.</p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.abstract_algebra.AlgebraException">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">AlgebraException</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#AlgebraException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.AlgebraException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Base class for all errors concerning the mathematical definitions and rules of an algebra.</p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.abstract_algebra.CannotSimplify">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">CannotSimplify</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#CannotSimplify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.CannotSimplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
<p>Raised when an expression cannot be further simplified</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.Expression">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">Expression</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Expression"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Basic class defining the basic methods any Expression object should implement.</p>
<dl class="method">
<dt id="qnet.algebra.abstract_algebra.Expression.all_symbols">
<tt class="descname">all_symbols</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Expression.all_symbols"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Expression.all_symbols" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The set of all_symbols contained within the expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.abstract_algebra.Expression.substitute">
<tt class="descname">substitute</tt><big>(</big><em>var_map</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Expression.substitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Expression.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute all_symbols for other expressions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>var_map</strong> (<em>dict</em>) &#8211; Dictionary with entries of the form <tt class="docutils literal"><span class="pre">{symbol:</span> <span class="pre">substitution}</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.abstract_algebra.Expression.tex">
<tt class="descname">tex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Expression.tex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Expression.tex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string containing a TeX-representation of self.
Note that this needs to be wrapped by &#8216;$&#8217; characters for &#8216;inline&#8217; LaTeX use.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.Match">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">Match</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Match" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></p>
<p>Subclass of dict that overloads the + operator
to create a new dictionary combining the entries.
It fails when there are duplicate keys.</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.NamedPattern">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">NamedPattern</tt><big>(</big><em>name</em>, <em>pattern</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#NamedPattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.NamedPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Create a named (sub-)pattern for later use in processing elements of a matched expression.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NamedPattern</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Pattern identifier</li>
<li><strong>pattern</strong> (<em>Expression, PatternTuple</em>) &#8211; Pattern expression</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.OperandsTuple">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">OperandsTuple</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#OperandsTuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.OperandsTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></p>
<p>Specialized tuple to store expression operands for the purpose of matching them to patterns.</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.Operation">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">Operation</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Operation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.Expression" title="qnet.algebra.abstract_algebra.Expression"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Expression</span></tt></a></p>
<p>Abstract base class for all operations,
where the operands themselves are also expressions.</p>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.abstract_algebra.Operation.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Operation.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Operation.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Operation.operands">
<tt class="descname">operands</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Operation.operands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Operation.operands" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The operands of the operation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.abstract_algebra.Operation.order_key">
<em class="property">classmethod </em><tt class="descname">order_key</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Operation.order_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Operation.order_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a default ordering mechanism for achieving canonical ordering of expressions sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj</strong> &#8211; The object to create a key for.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.PatternTuple">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">PatternTuple</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#PatternTuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.PatternTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></p>
<p>Specialized tuple to store expression pattern operands.</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.abstract_algebra.Wildcard">
<em class="property">class </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">Wildcard</tt><big>(</big><em>name=''</em>, <em>mode=1</em>, <em>head=None</em>, <em>condition=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#Wildcard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.Expression" title="qnet.algebra.abstract_algebra.Expression"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Expression</span></tt></a></p>
<p>Basic wildcard expression that can match a single expression or in the context of
matching the operands of an Operation object one may match one_or_more or zero_or_more operands
with the same wildcards. If the wildcard has a name, a successful match leads to a Match object in which the
object that matched the wildcard is stored under that name. One can also restrict the type of the matched Expression
by providing a head argument and the condition argument allows for passing a function that performs additional tests
on a potential match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Wildcard name, (default = &#8220;&#8221;)</li>
<li><strong>mode</strong> (One of <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.single" title="qnet.algebra.abstract_algebra.Wildcard.single"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.single</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.one_or_more" title="qnet.algebra.abstract_algebra.Wildcard.one_or_more"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.one_or_more</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.zero_or_more" title="qnet.algebra.abstract_algebra.Wildcard.zero_or_more"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.zero_or_more</span></tt></a>) &#8211; The matching mode, i.e. how many objects/operands can the wildcard match.</li>
<li><strong>head</strong> (<em>tuple or type or None</em>) &#8211; Restriction of the type of the matched expression</li>
<li><strong>condition</strong> (<em>FunctionType or None</em>) &#8211; An additional function that returns True if match should be accepted.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.condition">
<tt class="descname">condition</tt><em class="property"> = None</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.condition" title="Permalink to this definition">¶</a></dt>
<dd><p>extra condition that has to be satisfied for a successful match (default = <tt class="docutils literal"><span class="pre">None</span></tt>, corresponding to no restriction).</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.head">
<tt class="descname">head</tt><em class="property"> = None</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.head" title="Permalink to this definition">¶</a></dt>
<dd><p>head/type of the object that is matched (default = <tt class="docutils literal"><span class="pre">None</span></tt>, corresponding to no restriction).</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.mode">
<tt class="descname">mode</tt><em class="property"> = 1</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>mode of the wildcard, i.e. how many operands it can match (default = <tt class="docutils literal"><span class="pre">single</span></tt>).</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.name">
<tt class="descname">name</tt><em class="property"> = ''</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.name" title="Permalink to this definition">¶</a></dt>
<dd><p>name/identifier of the wildcard (default = &#8220;&#8221;).</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.one_or_more">
<tt class="descname">one_or_more</tt><em class="property"> = 2</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.one_or_more" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.mode" title="qnet.algebra.abstract_algebra.Wildcard.mode"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.mode</span></tt></a> for matching one or more operands/objects</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.single">
<tt class="descname">single</tt><em class="property"> = 1</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.single" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.mode" title="qnet.algebra.abstract_algebra.Wildcard.mode"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.mode</span></tt></a> for matching single operands/objects</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.abstract_algebra.Wildcard.zero_or_more">
<tt class="descname">zero_or_more</tt><em class="property"> = 3</em><a class="headerlink" href="#qnet.algebra.abstract_algebra.Wildcard.zero_or_more" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard.mode" title="qnet.algebra.abstract_algebra.Wildcard.mode"><tt class="xref py py-attr docutils literal"><span class="pre">Wildcard.mode</span></tt></a> for matching zero or more operands/objects</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.abstract_algebra.WrongSignatureError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">WrongSignatureError</tt><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#WrongSignatureError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.WrongSignatureError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
<p>Raise when an operation is instantiated with operands of the wrong signature.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.all_symbols">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">all_symbols</tt><big>(</big><em>expr</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#all_symbols"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.all_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all all_symbols featured within an expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>expr</strong> &#8211; The expression to find all_symbols in.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A set of all_symbols within expr.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.assoc">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">assoc</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.assoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Associatively expand out nested arguments of the flat class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Plus</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Plus</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Plus</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">    Plus(1,2,3)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._assoc_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.check_signature">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">check_signature</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.check_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the operands passed to the create classmethod of an Operation type conform to certain types.
For each allowed argument/operand, provide a tuple of types (or one of <tt class="docutils literal"><span class="pre">CLS,</span> <span class="pre">DCLS</span></tt>, see extended_isinstance docs).
E.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@check_signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">    X(&quot;1&quot;, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
<span class="go">    X(&quot;1&quot;, &quot;2&quot;)</span>
</pre></div>
</div>
<p>The following all raise <a class="reference internal" href="#qnet.algebra.abstract_algebra.WrongSignatureError" title="qnet.algebra.abstract_algebra.WrongSignatureError"><tt class="xref py py-class docutils literal"><span class="pre">WrongSignatureError</span></tt></a> exception.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._check_signature_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.check_signature_assoc">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">check_signature_assoc</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.check_signature_assoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#qnet.algebra.abstract_algebra.check_signature" title="qnet.algebra.abstract_algebra.check_signature"><tt class="xref py py-func docutils literal"><span class="pre">check_signature()</span></tt></a> but for <a class="reference internal" href="#qnet.algebra.abstract_algebra.assoc" title="qnet.algebra.abstract_algebra.assoc"><tt class="xref py py-func docutils literal"><span class="pre">assoc()</span></tt></a>-decorated Operations. In this case the signature need only contain a single entry.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@assoc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@check_signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;you&quot;</span><span class="p">)</span>
<span class="go">    X(&quot;hello&quot;, &quot;you&quot;)</span>
</pre></div>
</div>
<p>The following then raises a <a class="reference internal" href="#qnet.algebra.abstract_algebra.WrongSignatureError" title="qnet.algebra.abstract_algebra.WrongSignatureError"><tt class="xref py py-class docutils literal"><span class="pre">WrongSignatureError</span></tt></a> because the third argument is no string</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;you&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._check_signature_assoc_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.extended_isinstance">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">extended_isinstance</tt><big>(</big><em>obj</em>, <em>class_info</em>, <em>dcls</em>, <em>cls</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#extended_isinstance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.extended_isinstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Like isinstance but with two extra arguments to allow for placeholder objects <tt class="docutils literal"><span class="pre">(DCLS,</span> <span class="pre">CLS)</span></tt>
to stand for the class objects passed as extra arguments <tt class="docutils literal"><span class="pre">dcls</span></tt>, <tt class="docutils literal"><span class="pre">cls</span></tt>. This allows one to specify a self-referential
<cite>signature</cite> class attribute to allow for recursive Operation signatures.
E.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@check_signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">X</span>
</pre></div>
</div>
<p>will yield an exception, because X within the class body refers to a class object that has not been defined yet.
Instead, one can do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@check_signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">CLS</span>
</pre></div>
</div>
<p>to refer to the class of the object being instantiated (could be a subclass of <tt class="docutils literal"><span class="pre">X</span></tt>), or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@check_signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">signature</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">DCLS</span>
</pre></div>
</div>
<p>to always refer to <tt class="docutils literal"><span class="pre">X</span></tt> itself and not a subclass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> (<em>object</em>) &#8211; The instance</li>
<li><strong>class_info</strong> (<em>type or tuple of type-objects</em>) &#8211; A type, <tt class="docutils literal"><span class="pre">DCLS</span></tt>, <tt class="docutils literal"><span class="pre">CLS</span></tt>, or a tuple of these</li>
<li><strong>dcls</strong> (<em>type</em>) &#8211; The (super-)class that the signature is defined for.</li>
<li><strong>cls</strong> (<em>type</em>) &#8211; The concrete (sub-)class whose instance is being initialized.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.filter_neutral">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">filter_neutral</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.filter_neutral" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove occurrences of a neutral element from the argument/operand list, if that list has at least two elements.
To use this, one must also specify a neutral element, which can be anything that allows for an equality check with each argument.
E.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@filter_neutral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">neutral_element</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    X(2,3)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._filter_neutral_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.idem">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">idem</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.idem" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicate arguments and order them via the cls&#8217;s order_key key object/function.
E.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@idem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Set</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Set</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">    Set(1,2,3)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._idem_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.make_classmethod">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">make_classmethod</tt><big>(</big><em>method</em>, <em>cls</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#make_classmethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.make_classmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a bound classmethod from an unbound method taking an additional first argument <tt class="docutils literal"><span class="pre">cls</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>FunctionType</em>) &#8211; The unbound method</li>
<li><strong>cls</strong> (<em>type</em>) &#8211; The class to bind it to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Bound class method</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">MethodType</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.match">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">match</tt><big>(</big><em>pattern</em>, <em>expr</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match a pattern against an expression and return a Match object if successful or False, if not.
Works recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> (<em>Expression or PatternTuple</em>) &#8211; Pattern expression</li>
<li><strong>expr</strong> (<em>Expression or OperandsTuple</em>) &#8211; Expression to match against the pattern.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Match object or False</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Match or False</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.match_range">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">match_range</tt><big>(</big><em>pattern</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#match_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.match_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute how many objects/operands a given pattern can minimally and maximally match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pattern</strong> &#8211; The pattern object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">min_number, max_number</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body">ValueError, if unknown pattern mode for Wildcard object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.match_replace">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">match_replace</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.match_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Match and replace a full operand specification to a function that provides a replacement for the whole expression
or raises a <a class="reference internal" href="#qnet.algebra.abstract_algebra.CannotSimplify" title="qnet.algebra.abstract_algebra.CannotSimplify"><tt class="xref py py-class docutils literal"><span class="pre">CannotSimplify</span></tt></a> exception.
E.g.</p>
<p>First define wildcards:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_float</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<p>Then an operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@match_replace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Invert</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Then some _rules:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Invert</span><span class="o">.</span><span class="n">_rules</span> <span class="o">+=</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">((</span><span class="n">Invert</span><span class="p">(</span><span class="n">A</span><span class="p">),),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">((</span><span class="n">A_float</span><span class="p">,),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">A</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">]</span>
</pre></div>
</div>
<p>Check rule application:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Invert</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;hallo&quot;</span><span class="p">)</span>              <span class="c"># matches no rule</span>
<span class="go">    Invert(&quot;hallo&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Invert</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">Invert</span><span class="p">(</span><span class="s">&quot;hallo&quot;</span><span class="p">))</span>      <span class="c"># matches first rule</span>
<span class="go">    &quot;hallo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Invert</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">.</span><span class="mi">2</span><span class="p">)</span>                   <span class="c"># matches second rule</span>
<span class="go">    5.</span>
</pre></div>
</div>
<p>A pattern can also have the same wildcard appear twice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@match_replace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">    X(1,2)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._match_replace_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.match_replace_binary">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">match_replace_binary</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.match_replace_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#qnet.algebra.abstract_algebra.match_replace" title="qnet.algebra.abstract_algebra.match_replace"><tt class="xref py py-func docutils literal"><span class="pre">match_replace()</span></tt></a>, but for arbitrary length operations, such that each two pairs of subsequent operands are matched pairwise.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">wc</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@match_replace_binary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FilterDupes</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">_rules</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="p">((</span><span class="n">A</span><span class="p">,</span><span class="n">A</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FilterDupes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>         <span class="c"># No subsequent duplicates present</span>
<span class="go">    FilterDupes(1,2,3,4)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FilterDupes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>       <span class="c"># Some duplicates</span>
<span class="go">    FilterDupes(1,2,3,4)</span>
</pre></div>
</div>
<p>Note that this only works for <em>subsequent</em> duplicate entries:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FilterDupes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>       <span class="c"># Some duplicates, but not subsequent</span>
<span class="go">    FilterDupes(1,2,3,2,4)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._match_replace_binary_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.mathematica">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">mathematica</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.mathematica" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.orderby">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">orderby</tt><big>(</big><em>dcls</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.orderby" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-order arguments via the class&#8217;s <tt class="docutils literal"><span class="pre">order_key</span></tt> key object/function.
Use this for commutative operations:
E.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@orderless</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Times</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Times</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    Times(1,2)</span>
</pre></div>
</div>
<p>Automatically generated class decorator based on the method <tt class="docutils literal"><span class="pre">qnet.algebra.abstract_algebra._orderless_mtd()</span></tt> using
<a class="reference internal" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="qnet.algebra.abstract_algebra.preprocess_create_with"><tt class="xref py py-func docutils literal"><span class="pre">preprocess_create_with()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.preprocess_create_with">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">preprocess_create_with</tt><big>(</big><em>method</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#preprocess_create_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.preprocess_create_with" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a factory method that allows for adding argument pre-processing decorators the a class&#8217;s <tt class="docutils literal"><span class="pre">create</span></tt> classmethod.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>method</strong> (<em>FunctionType</em>) &#8211; A decorating create classmethod <tt class="docutils literal"><span class="pre">f()</span></tt> with signature:
<tt class="docutils literal"><span class="pre">f(decorated_class,</span> <span class="pre">decorated_method,</span> <span class="pre">cls,</span> <span class="pre">*args)</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A class decorator function that decorates the &#8216;create&#8217; classmethod of the decorated class.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">FunctionType</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.prod">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">prod</tt><big>(</big><em>sequence</em>, <em>neutral=1</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Analog of the builtin <cite>sum()</cite> method.
:param sequence: Sequence of objects that support being multiplied to each other.
:type sequence: Any object that implements __mul__()
:param neutral: The initial return value, which is also returned for zero-length sequence arguments.
:type neutral: Any object that implements __mul__()
:return: The product of the elements of <cite>sequence</cite></p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.set_union">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">set_union</tt><big>(</big><em>*sets</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#set_union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.set_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <tt class="docutils literal"><span class="pre">sum()</span></tt>, but for sets. Generate the union of an arbitrary number of set arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sets</strong> (<em>set</em>) &#8211; Sets to for the union of.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Union set.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.singleton">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">singleton</tt><big>(</big><em>cls</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#singleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Singleton class decorator. Turns a class object into a unique instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cls</strong> (<em>type</em>) &#8211; Class to decorate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The singleton instance of that class</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">cls</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.substitute">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">substitute</tt><big>(</big><em>expr</em>, <em>var_map</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#substitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>(Safe) substitute, substitute objects for all symbols.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>expr</strong> &#8211; The expression in which to perform the substitution</li>
<li><strong>var_map</strong> (<em>dict</em>) &#8211; The substitution dictionary. See <a class="reference internal" href="#qnet.algebra.abstract_algebra.substitute" title="qnet.algebra.abstract_algebra.substitute"><tt class="xref py py-meth docutils literal"><span class="pre">qnet.algebra.abstract_algebra.substitute()</span></tt></a> documentation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.tex">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">tex</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#tex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.tex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj</strong> &#8211; Object to represent in LaTeX.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Return a LaTeX string-representation of obj.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.unequals">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">unequals</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#qnet.algebra.abstract_algebra.unequals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.update_pattern">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">update_pattern</tt><big>(</big><em>expr</em>, <em>match_obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#update_pattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.update_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all wildcards in the pattern expression with their matched values as specified in a Match object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expr</strong> (<em>Expression or PatternTuple</em>) &#8211; Pattern expression</li>
<li><strong>match_obj</strong> (<em>Match</em>) &#8211; Match object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Expression with replaced wildcards</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Expression or PatternTuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.abstract_algebra.wc">
<tt class="descclassname">qnet.algebra.abstract_algebra.</tt><tt class="descname">wc</tt><big>(</big><em>name_mode='_'</em>, <em>head=None</em>, <em>condition=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/abstract_algebra.html#wc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.abstract_algebra.wc" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to create a Wildcard object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name_mode</strong> (<em>str</em>) &#8211; <p>Combined name and mode (cf <a class="reference internal" href="#qnet.algebra.abstract_algebra.Wildcard" title="qnet.algebra.abstract_algebra.Wildcard"><tt class="xref py py-class docutils literal"><span class="pre">Wildcard</span></tt></a>) argument.</p>
<ul>
<li><tt class="docutils literal"><span class="pre">&quot;A&quot;</span></tt> -&gt; <tt class="docutils literal"><span class="pre">name=&quot;A&quot;,</span> <span class="pre">mode</span> <span class="pre">=</span> <span class="pre">Wildcard.single</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&quot;A_&quot;</span></tt> -&gt; <tt class="docutils literal"><span class="pre">name=&quot;A&quot;,</span> <span class="pre">mode</span> <span class="pre">=</span> <span class="pre">Wildcard.single</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&quot;B__&quot;</span></tt> -&gt; <tt class="docutils literal"><span class="pre">name=&quot;B&quot;,</span> <span class="pre">mode</span> <span class="pre">=</span> <span class="pre">Wildcard.one_or_more</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&quot;B___&quot;</span></tt> -&gt; <tt class="docutils literal"><span class="pre">name=&quot;C&quot;,</span> <span class="pre">mode</span> <span class="pre">=</span> <span class="pre">Wildcard.zero_or_more</span></tt></li>
</ul>
</li>
<li><strong>head</strong> (<em>tuple or ClassType or None</em>) &#8211; See Wildcard doc</li>
<li><strong>condition</strong> (<em>FunctionType or None</em>) &#8211; See Wildcard doc</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Wildcard object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Wildcard</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qnet.algebra.hilbert_space_algebra">
<span id="hilbert-space-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">hilbert_space_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.hilbert_space_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-hilbert-space-algebra">
<h3>The Hilbert Space Algebra<a class="headerlink" href="#the-hilbert-space-algebra" title="Permalink to this headline">¶</a></h3>
<p>This module defines some simple classes to describe simple and <em>composite/tensor</em> (i.e., multiple degree of freedom)
Hilbert spaces of quantum systems.</p>
<p>For more details see <a class="reference internal" href="symbolic_algebra.html#hilbert-space-algebra"><em>Hilbert Space Algebra</em></a>.</p>
<dl class="exception">
<dt id="qnet.algebra.hilbert_space_algebra.BasisNotSetError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">BasisNotSetError</tt><big>(</big><em>local_space</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#BasisNotSetError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.BasisNotSetError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
<p>Is raised when the basis states of a LocalSpace are requested before being defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>local_space</strong> &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace">
<em class="property">class </em><tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">HilbertSpace</tt><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Basic Hilbert space class from which concrete classes are derived.</p>
<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.dimension">
<tt class="descname">dimension</tt><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.dimension"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.dimension" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The full dimension of the Hilbert space</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.intersect">
<tt class="descname">intersect</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.intersect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the mutual tensor <em>factors</em> of two Hilbert spaces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>HilbertSpace</em>) &#8211; Other Hilbert space</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.is_strict_subfactor_of">
<tt class="descname">is_strict_subfactor_of</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.is_strict_subfactor_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.is_strict_subfactor_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a Hilbert space occures as a strict sub-factor in (larger) Hilbert space
:type other: HilbertSpace</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.is_strict_tensor_factor_of">
<tt class="descname">is_strict_tensor_factor_of</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.is_strict_tensor_factor_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.is_strict_tensor_factor_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a space is included within a larger tensor product space. Not <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span> <span class="pre">==</span> <span class="pre">other</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>HilbertSpace</em>) &#8211; Other Hilbert space</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.is_tensor_factor_of">
<tt class="descname">is_tensor_factor_of</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.is_tensor_factor_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.is_tensor_factor_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a space is included within a larger tensor product space. Also <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self</span> <span class="pre">==</span> <span class="pre">other</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>HilbertSpace</em>) &#8211; Other Hilbert space</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.local_factors">
<tt class="descname">local_factors</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.local_factors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.local_factors" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A sequence of LocalSpace objects that tensored together yield this Hilbert space.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple of LocalSpace objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.remove">
<tt class="descname">remove</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a particular factor from a tensor product space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>HilbertSpace</em>) &#8211; Space to remove</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Hilbert space for remaining degrees of freedom.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.hilbert_space_algebra.HilbertSpace.tensor">
<tt class="descname">tensor</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#HilbertSpace.tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor product between Hilbert spaces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>HilbertSpace</em>) &#8211; Other Hilbert space</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Tensor product space.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.hilbert_space_algebra.LocalSpace">
<em class="property">class </em><tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">LocalSpace</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#LocalSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.LocalSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace" title="qnet.algebra.hilbert_space_algebra.HilbertSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.HilbertSpace</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Basic class to instantiate a local Hilbert space, i.e., for a single degree of freedom.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">LocalSpace(name,</span> <span class="pre">namespace)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; The identifier of the local space / degree of freedom</li>
<li><strong>namespace</strong> (<em>str</em>) &#8211; The namespace for the degree of freedom, useful in hierarchical system models.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.LocalSpace.basis">
<tt class="descname">basis</tt><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#LocalSpace.basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.LocalSpace.basis" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The set of basis states of the local Hilbert space</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">sequence of int or str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.hilbert_space_algebra.LocalSpace.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.LocalSpace.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.LocalSpace.dimension">
<tt class="descname">dimension</tt><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.LocalSpace.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The local state space dimension.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.LocalSpace.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'str'&gt;, &lt;type 'str'&gt;)</em><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.LocalSpace.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.hilbert_space_algebra.ProductSpace">
<em class="property">class </em><tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">ProductSpace</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#ProductSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.ProductSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.hilbert_space_algebra.HilbertSpace" title="qnet.algebra.hilbert_space_algebra.HilbertSpace"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.hilbert_space_algebra.HilbertSpace</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Tensor product space class for an arbitrary number of local space factors.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">ProductSpace(*factor_spaces)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>factor_spaces</strong> (<em>HilbertSpace</em>) &#8211; The Hilbert spaces to be tensored together.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.hilbert_space_algebra.ProductSpace.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#ProductSpace.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.ProductSpace.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.ProductSpace.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = TrivialSpace</em><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.ProductSpace.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.hilbert_space_algebra.ProductSpace.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;,)</em><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.ProductSpace.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.hilbert_space_algebra.convert_to_spaces_mtd">
<tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">convert_to_spaces_mtd</tt><big>(</big><em>dcls</em>, <em>clsmtd</em>, <em>cls</em>, <em>*ops</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#convert_to_spaces_mtd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.convert_to_spaces_mtd" title="Permalink to this definition">¶</a></dt>
<dd><p>For all operands that are merely of type str or int, substitute LocalSpace objects with corresponding labels:
For a string, just itself, for an int, a string version of that int.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.hilbert_space_algebra.local_space">
<tt class="descclassname">qnet.algebra.hilbert_space_algebra.</tt><tt class="descname">local_space</tt><big>(</big><em>name</em>, <em>namespace=''</em>, <em>dimension=None</em>, <em>basis=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/hilbert_space_algebra.html#local_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.hilbert_space_algebra.local_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a LocalSpace with by default empty namespace string.
If one also provides a set of basis states, these get stored via the BasisRegistry object.
ALternatively, one may provide a dimension such that the states are simply labeled by a range of integers:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">dimension</span> <span class="pre">-1]</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str or int</em>) &#8211; Local space identifier</li>
<li><strong>namespace</strong> (<em>str</em>) &#8211; Local space namespace, see LocalSpace documentation</li>
<li><strong>dimension</strong> (<em>int</em>) &#8211; Dimension of local space (optional)</li>
<li><strong>basis</strong> (<em>sequence of int or sequence of str</em>) &#8211; Basis state labels for local space</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qnet.algebra.operator_algebra">
<span id="operator-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">operator_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.operator_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="operator-algebra">
<h3>Operator Algebra<a class="headerlink" href="#operator-algebra" title="Permalink to this headline">¶</a></h3>
<p>This module features classes and functions to define and manipulate symbolic Operator expressions.
For more details see <a class="reference internal" href="symbolic_algebra.html#operator-algebra"><em>The Operator Algebra module</em></a>.</p>
<p>For a list of all properties and methods of an operator object, see the documentation for the basic <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">Operator</span></tt></a> class.</p>
<dl class="class">
<dt id="qnet.algebra.operator_algebra.Adjoint">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Adjoint</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorOperation" title="qnet.algebra.operator_algebra.OperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorOperation</span></tt></a></p>
<p>The symbolic Adjoint of an operator.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Adjoint(op)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>op</strong> (<em>Operator</em>) &#8211; The operator to take the adjoint of.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Adjoint.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Adjoint.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Adjoint.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Adjoint.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Adjoint.operand" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Create">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Create</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Create" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p><tt class="docutils literal"><span class="pre">Create(space)</span></tt> yields a bosonic creation operator acting on a particular local space/degree of freedom.
Its adjoint is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span>
<span class="go">    Destroy(1)</span>
</pre></div>
</div>
<p>and it obeys the bosonic commutation relation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Create.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Create.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Create.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;),)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Create.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Destroy">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Destroy</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p><tt class="docutils literal"><span class="pre">Destroy(space)</span></tt> yields a bosonic annihilation operator acting on a particular local space/degree of freedom.
Its adjoint is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()</span>
<span class="go">    Create(1)</span>
</pre></div>
</div>
<p>and it obeys the bosonic commutation relation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Create</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">    1</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Destroy.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Destroy.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Destroy.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;),)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Destroy.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Displace">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Displace</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Displace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p>Unitary coherent displacement operator</p>
<div class="math">
\[D_{\rm s}(\alpha) := \exp\left({\alpha a_{\rm s}^\dagger - \alpha^* a_{\rm s}}\right)\]</div>
<p>where <span class="math">\(a_{\rm s}\)</span> is the annihilation operator acting on the local space s.
Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Displace(space,</span> <span class="pre">alpha)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</li>
<li><strong>alpha</strong> (Any from <cite>Operator.scalar_types</cite>) &#8211; Displacement amplitude.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Displace.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Displace.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Displace.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;))</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Displace.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.IdentityMatrix">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">IdentityMatrix</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.IdentityMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the N-dimensional identity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>N</strong> (<em>int</em>) &#8211; Dimension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Identity matrix in N dimensions</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.Im">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Im</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Im"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Im" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of a number or operator. Acting on OperatorMatrices, it produces the element-wise imaginary parts.
:param op: Anything that has a conjugate method.
:type op: Operator or Matrix or any of Operator.scalar_types
:return: The imaginary part of the operand.
:rtype: Same as type of <cite>op</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.ImAdjoint">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">ImAdjoint</tt><big>(</big><em>opmatrix</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ImAdjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ImAdjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of an OperatorMatrix, i.e. a hermitian OperatorMatrix
:param opmatrix: The operand.
:type opmatrix: Matrix
:return: The matrix imaginary part of the operand.
:rtype: Matrix</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.LocalOperator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">LocalOperator</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#LocalOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Base class for all kinds of operators that act <em>locally</em>,
i.e. only on a single degree of freedom.</p>
<dl class="method">
<dt id="qnet.algebra.operator_algebra.LocalOperator.to_qutip_local_factor">
<tt class="descname">to_qutip_local_factor</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#LocalOperator.to_qutip_local_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalOperator.to_qutip_local_factor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Return a qutip representation for the local operator only on its local space.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">qutip.Qobj</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.LocalProjector">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">LocalProjector</tt><big>(</big><em>spc</em>, <em>state</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalProjector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.LocalSigma">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">LocalSigma</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#LocalSigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p>A local level flip operator operator acting on a particular local space/degree of freedom.</p>
<div class="math">
\[\sigma_{jk}^{\rm s} := \left| j\right\rangle_{\rm s} \left \langle k \right |_{\rm s}\]</div>
<p>Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">LocalSigma(space,</span> <span class="pre">j,</span> <span class="pre">k)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</li>
<li><strong>j</strong> (<em>int or str</em>) &#8211; State label j.</li>
<li><strong>k</strong> (<em>int or str</em>) &#8211; State label k.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.LocalSigma.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalSigma.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.LocalSigma.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'int'&gt;, &lt;type 'str'&gt;), (&lt;type 'int'&gt;, &lt;type 'str'&gt;))</em><a class="headerlink" href="#qnet.algebra.operator_algebra.LocalSigma.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Matrix">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Matrix</tt><big>(</big><em>m</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.Expression" title="qnet.algebra.abstract_algebra.Expression"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Expression</span></tt></a></p>
<p>Matrix with Operator (or scalar-) valued elements.</p>
<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.H">
<tt class="descname">H</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.H"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.H" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjoint operator matrix, i.e. transpose and the Hermitian adjoint operators of all elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.T">
<tt class="descname">T</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.T"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.T" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Transpose matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.adjoint">
<tt class="descname">adjoint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjoint operator matrix, i.e. transpose and the Hermitian adjoint operators of all elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.block_structure">
<tt class="descname">block_structure</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.block_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.block_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>For square matrices this gives the block (-diagonal) structure of the matrix as a
tuple of integers that sum up to the full dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.conjugate">
<tt class="descname">conjugate</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-wise conjugate matrix, i.e., if an element is an operator this means the adjoint operator,
but no transposition of matrix elements takes place.
:return: Element-wise hermitian conjugate matrix.
:rtype: Matrix</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.dag">
<tt class="descname">dag</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjoint operator matrix, i.e. transpose and the Hermitian adjoint operators of all elements.</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.element_wise">
<tt class="descname">element_wise</tt><big>(</big><em>method</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.element_wise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.element_wise" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a method to each matrix element and return the result in a new operator matrix of the same shape.
:param method: A method taking a single argument.
:type method: FunctionType
:return: Operator matrix with results of method applied element-wise.
:rtype: Matrix</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand each matrix element distributively.
:return: Expanded matrix.
:rtype: Matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.matrix">
<tt class="descname">matrix</tt><em class="property"> = None</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.shape">
<tt class="descname">shape</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the matrix <tt class="docutils literal"><span class="pre">(nrows,</span> <span class="pre">ncols)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.simplify_scalar">
<tt class="descname">simplify_scalar</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.simplify_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify all scalar expressions appearing in the Matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Matrix.space">
<tt class="descname">space</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.space" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the combined Hilbert space of all matrix elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.trace">
<tt class="descname">trace</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.trace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Matrix.transpose">
<tt class="descname">transpose</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Matrix.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Matrix.transpose" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The transpose matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.operator_algebra.NonSquareMatrix">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">NonSquareMatrix</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#NonSquareMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.NonSquareMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.NullSpaceProjector">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">NullSpaceProjector</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#NullSpaceProjector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.NullSpaceProjector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorOperation" title="qnet.algebra.operator_algebra.OperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorOperation</span></tt></a></p>
<p>Returns a projection operator <span class="math">\(\mathcal{P}_{{\rm Ker} X}\)</span> that projects onto the nullspace of its operand</p>
<div class="math">
\[\begin{split}X \mathcal{P}_{{\rm Ker} X} = 0 \Leftrightarrow  X (1 - \mathcal{P}_{{\rm Ker} X}) = X\\
\mathcal{P}_{{\rm Ker} X}^\dagger = \mathcal{P}_{{\rm Ker} X} = \mathcal{P}_{{\rm Ker} X}^2\end{split}\]</div>
<p>Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">NullSpaceProjector(X)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> (<em>Operator</em>) &#8211; Operator argument</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.NullSpaceProjector.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.NullSpaceProjector.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.NullSpaceProjector.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#NullSpaceProjector.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.NullSpaceProjector.operand" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.NullSpaceProjector.to_qutip">
<tt class="descname">to_qutip</tt><big>(</big><em>full_space=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#NullSpaceProjector.to_qutip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.NullSpaceProjector.to_qutip" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Operator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Operator</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The basic operator class, which fixes the abstract interface of operator objects 
and where possible also defines the default behavior under operations.
Any operator contains an associated HilbertSpace object, 
on which it is taken to act non-trivially.</p>
<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.adjoint">
<tt class="descname">adjoint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Hermitian adjoint of the operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.conjugate">
<tt class="descname">conjugate</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Hermitian adjoint of the operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.dag">
<tt class="descname">dag</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.dag" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Hermitian adjoint of the operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand out distributively all products of sums. Note that this does not expand out sums of scalar coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A fully expanded sum of operators.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.pseudo_inverse">
<tt class="descname">pseudo_inverse</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.pseudo_inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.pseudo_inverse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The pseudo-Inverse of the Operator, i.e., it inverts the operator on the orthogonal complement of its nullspace</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Operator.scalar_types">
<tt class="descname">scalar_types</tt><em class="property"> = (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.scalar_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.series_expand">
<tt class="descname">series_expand</tt><big>(</big><em>param</em>, <em>about</em>, <em>order</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.series_expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.series_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the operator expression as a truncated power series in a scalar parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>param</strong> (<em>sympy.core.symbol.Symbol</em>) &#8211; Expansion parameter.</li>
<li><strong>about</strong> (<em>Any one of Operator.scalar_types</em>) &#8211; Point about which to expand.</li>
<li><strong>order</strong> (<em>int &gt;= 0</em>) &#8211; Maximum order of expansion.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tuple of length (order+1), where the entries are the expansion coefficients.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple of Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.simplify_scalar">
<tt class="descname">simplify_scalar</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.simplify_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify all scalar coefficients within the Operator expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The simplified expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Operator.space">
<tt class="descname">space</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.space" title="Permalink to this definition">¶</a></dt>
<dd><p>The Hilbert space associated with the operator on which it acts non-trivially</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.Operator.to_qutip">
<tt class="descname">to_qutip</tt><big>(</big><em>full_space=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Operator.to_qutip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Operator.to_qutip" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a numerical representation of the operator as a QuTiP object.
Note that all symbolic scalar parameters need to be replaced by numerical values before calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>full_space</strong> (<em>HilbertSpace</em>) &#8211; The full Hilbert space in which to represent the operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The matrix representation of the operator.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">qutip.Qobj (<tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt>)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorMatrixInstance">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorMatrixInstance</tt><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorMatrixInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#qnet.algebra.operator_algebra.Matrix" title="qnet.algebra.operator_algebra.Matrix"><tt class="xref py py-class docutils literal"><span class="pre">Matrix</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorOperation">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorOperation</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Base class for Operations acting only on Operator arguments.</p>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorOperation.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.Operator'&gt;,)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorOperation.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorPlus">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorPlus</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorPlus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorOperation" title="qnet.algebra.operator_algebra.OperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorOperation</span></tt></a></p>
<p>A sum of Operators</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">OperatorPlus(*summands)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>summands</strong> (<em>Operator</em>) &#8211; Operator summands.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.OperatorPlus.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorPlus.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorPlus.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = ZeroOperator</em><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorPlus.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.OperatorPlus.order_key">
<em class="property">classmethod </em><tt class="descname">order_key</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorPlus.order_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorPlus.order_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorSymbol">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorSymbol</tt><big>(</big><em>name</em>, <em>hs</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorSymbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Operator Symbol class, parametrized by an identifier string and an associated Hilbert space.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">OperatorSymbol(name,</span> <span class="pre">hs)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Symbol identifier</li>
<li><strong>hs</strong> (<em>HilbertSpace</em>) &#8211; Associated Hilbert space.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.OperatorSymbol.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorSymbol.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorSymbol.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'str'&gt;, (&lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;, &lt;type 'tuple'&gt;))</em><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorSymbol.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorTimes">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorTimes</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorTimes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorOperation" title="qnet.algebra.operator_algebra.OperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorOperation</span></tt></a></p>
<p>A product of Operators that serves both as a product within a Hilbert space as well as a tensor product.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">OperatorTimes(*factors)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>factors</strong> (<em>Operator</em>) &#8211; Operator factors.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorTimes.OperatorOrderKey">
<em class="property">class </em><tt class="descname">OperatorOrderKey</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorTimes.OperatorOrderKey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes.OperatorOrderKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Auxiliary class that generates the correct pseudo-order relation for operator products.
Only operators acting on different Hilbert spaces are commuted to achieve the order specified in the full HilbertSpace.
I.e., sorted(factors, key = OperatorOrderKey) achieves this ordering.</p>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.OperatorTimes.create">
<em class="property">classmethod </em><tt class="descclassname">OperatorTimes.</tt><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorTimes.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.operator_algebra.OperatorTimes.factor_for_space">
<tt class="descclassname">OperatorTimes.</tt><tt class="descname">factor_for_space</tt><big>(</big><em>spc</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorTimes.factor_for_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes.factor_for_space" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorTimes.neutral_element">
<tt class="descclassname">OperatorTimes.</tt><tt class="descname">neutral_element</tt><em class="property"> = IdentityOperator</em><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorTimes.order_key">
<tt class="descclassname">OperatorTimes.</tt><tt class="descname">order_key</tt><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTimes.order_key" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorTimes.OperatorOrderKey" title="qnet.algebra.operator_algebra.OperatorTimes.OperatorOrderKey"><tt class="xref py py-class docutils literal"><span class="pre">OperatorOrderKey</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.OperatorTrace">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">OperatorTrace</tt><big>(</big><em>space</em>, <em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#OperatorTrace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Take the (partial) trace of an operator <span class="math">\(X\)</span> over the degrees of freedom given by a Hilbert space <span class="math">\(\mathcal{H}\)</span>:</p>
<div class="math">
\[{\rm Tr}_{\mathcal{H}} X\]</div>
<p>Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">OperatorTrace(space,</span> <span class="pre">X)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>space</strong> (<em>HilbertSpace</em>) &#8211; The degrees of freedom to trace over</li>
<li><strong>X</strong> (<em>Operator</em>) &#8211; The operator to take the trace of.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.OperatorTrace.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTrace.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.OperatorTrace.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;, &lt;class 'qnet.algebra.operator_algebra.Operator'&gt;)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.OperatorTrace.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Phase">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Phase</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p>The unitary Phase operator acting on a particular local space/degree of freedom:</p>
<div class="math">
\[P_{\rm s}(\phi):= \exp\left(i \phi a_{\rm s}^\dagger a_{\rm s}\right)\]</div>
<p>where <span class="math">\(a_{\rm s}\)</span> is the annihilation operator acting on the local space s.
Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Phase(space,</span> <span class="pre">phi)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</li>
<li><strong>phi</strong> (Any from <cite>Operator.scalar_types</cite>) &#8211; Displacement amplitude.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Phase.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Phase.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Phase.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;))</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Phase.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.PseudoInverse">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">PseudoInverse</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#PseudoInverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.PseudoInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.OperatorOperation" title="qnet.algebra.operator_algebra.OperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.OperatorOperation</span></tt></a></p>
<p>The symbolic pseudo-inverse <span class="math">\(X^+\)</span> of an operator <span class="math">\(X\)</span>. It is defined via the relationship</p>
<div class="math">
\[\begin{split}X X^+ X =  X  \\
X^+ X X^+ =  X^+  \\
(X^+ X)^\dagger = X^+ X  \\
(X X^+)^\dagger = X X^+\end{split}\]</div>
<p>Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">PseudoInverse(X)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> (<em>Operator</em>) &#8211; The operator to take the adjoint of.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.PseudoInverse.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#PseudoInverse.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.PseudoInverse.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.PseudoInverse.delegate_to_method">
<tt class="descname">delegate_to_method</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.ScalarTimesOperator'&gt;, &lt;class 'qnet.algebra.operator_algebra.Squeeze'&gt;, &lt;class 'qnet.algebra.operator_algebra.Displace'&gt;, &lt;class 'qnet.algebra.abstract_algebra.ZeroOperator'&gt;, &lt;class 'qnet.algebra.abstract_algebra.IdentityOperator'&gt;, &lt;class 'qnet.algebra.operator_algebra.PseudoInverse'&gt;)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.PseudoInverse.delegate_to_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.PseudoInverse.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#PseudoInverse.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.PseudoInverse.operand" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.Re">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Re</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Re"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Re" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of a number or operator. Acting on OperatorMatrices, it produces the element-wise real parts.
:param op: Anything that has a conjugate method.
:type op: Operator or Matrix or any of Operator.scalar_types
:return: The real part of the operand.
:rtype: Same as type of <cite>op</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.ReAdjoint">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">ReAdjoint</tt><big>(</big><em>opmatrix</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ReAdjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ReAdjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of an OperatorMatrix, i.e. a hermitian OperatorMatrix
:param opmatrix: The operand.
:type opmatrix: Matrix
:return: The matrix real part of the operand.
:rtype: Matrix</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">ScalarTimesOperator</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ScalarTimesOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Multiply an operator by a scalar coefficient.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">ScalarTimesOperator(coefficient,</span> <span class="pre">term)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coefficient</strong> (<em>Any of Operator.scalar_types</em>) &#8211; Scalar coefficient.</li>
<li><strong>term</strong> (<em>Operator</em>) &#8211; The operator that is multiplied.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator.coeff">
<tt class="descname">coeff</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ScalarTimesOperator.coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator.coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator.has_minus_prefactor">
<em class="property">static </em><tt class="descname">has_minus_prefactor</tt><big>(</big><em>c</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ScalarTimesOperator.has_minus_prefactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator.has_minus_prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p>For a scalar object c, determine whether it is prepended by a &#8220;-&#8221; sign.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;), &lt;class 'qnet.algebra.operator_algebra.Operator'&gt;)</em><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.ScalarTimesOperator.term">
<tt class="descname">term</tt><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#ScalarTimesOperator.term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.ScalarTimesOperator.term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.operator_algebra.Squeeze">
<em class="property">class </em><tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Squeeze</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalOperator" title="qnet.algebra.operator_algebra.LocalOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.LocalOperator</span></tt></a></p>
<p>A unitary Squeezing operator acting on a particular local space/degree of freedom:</p>
<div class="math">
\[S_{\rm s}(\eta) := \exp {\left( \frac{\eta}{2} {a_{\rm s}^\dagger}^2 - \frac{\eta^*}{2} {a_{\rm s}}^2 \right)}\]</div>
<p>where <span class="math">\(a_{\rm s}\)</span> is the annihilation operator acting on the local space s.
Use as:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Squeeze(space,</span> <span class="pre">eta)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>space</strong> (<em>LocalSpace or str</em>) &#8211; Associated local Hilbert space.</li>
<li><strong>eta</strong> (Any from <cite>Operator.scalar_types</cite>) &#8211; Squeeze parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.operator_algebra.Squeeze.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.Squeeze.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.operator_algebra.Squeeze.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;))</em><a class="headerlink" href="#qnet.algebra.operator_algebra.Squeeze.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.X">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">X</tt><big>(</big><em>local_space</em>, <em>states=('h'</em>, <em>'g')</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#X"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.X" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli-type X-operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>local_space</strong> (<em>LocalSpace</em>) &#8211; Associated Hilbert space.</li>
<li><strong>states</strong> (<em>tuple with two elements of type int or str</em>) &#8211; The qubit state labels for the basis states <span class="math">\(\left\{|0\rangle, |1\rangle \right\}\)</span>, where <span class="math">\(Z|0\rangle = +|0\rangle\)</span>, default = <tt class="docutils literal"><span class="pre">('h',</span> <span class="pre">'g')</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Local X-operator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.Y">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Y</tt><big>(</big><em>local_space</em>, <em>states=('h'</em>, <em>'g')</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Y" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli-type Y-operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>local_space</strong> (<em>LocalSpace</em>) &#8211; Associated Hilbert space.</li>
<li><strong>states</strong> (<em>tuple with two elements of type int or str</em>) &#8211; The qubit state labels for the basis states <span class="math">\(\left\{|0\rangle, |1\rangle \right\}\)</span>, where <span class="math">\(Z|0\rangle = +|0\rangle\)</span>, default = <tt class="docutils literal"><span class="pre">('h',</span> <span class="pre">'g')</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Local Y-operator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.Z">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">Z</tt><big>(</big><em>local_space</em>, <em>states=('h'</em>, <em>'g')</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#Z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.Z" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli-type Z-operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>local_space</strong> (<em>LocalSpace</em>) &#8211; Associated Hilbert space.</li>
<li><strong>states</strong> (<em>tuple with two elements of type int or str</em>) &#8211; The qubit state labels for the basis states <span class="math">\(\left\{|0\rangle, |1\rangle \right\}\)</span>, where <span class="math">\(Z|0\rangle = +|0\rangle\)</span>, default = <tt class="docutils literal"><span class="pre">('h',</span> <span class="pre">'g')</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Local Z-operator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.adjoint">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">adjoint</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjoint of an obj.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.block_matrix">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">block_matrix</tt><big>(</big><em>A</em>, <em>B</em>, <em>C</em>, <em>D</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#block_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.block_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the operator matrix with quadrants</p>
<div class="math">
\[\begin{split}\begin{pmatrix} A B \\ C D \end{pmatrix}\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>Matrix</em>) &#8211; Matrix of shape <tt class="docutils literal"><span class="pre">(n,</span> <span class="pre">m)</span></tt></li>
<li><strong>B</strong> (<em>Matrix</em>) &#8211; Matrix of shape <tt class="docutils literal"><span class="pre">(n,</span> <span class="pre">k)</span></tt></li>
<li><strong>C</strong> (<em>Matrix</em>) &#8211; Matrix of shape <tt class="docutils literal"><span class="pre">(l,</span> <span class="pre">m)</span></tt></li>
<li><strong>D</strong> (<em>Matrix</em>) &#8211; Matrix of shape <tt class="docutils literal"><span class="pre">(l,</span> <span class="pre">k)</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The combined block matrix [[A, B], [C, D]].</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><p class="first last">OperatorMatrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.decompose_space">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">decompose_space</tt><big>(</big><em>H</em>, <em>A</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#decompose_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.decompose_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies OperatorTrace expressions over tensor-product spaces by turning it into iterated partial traces.
:param H: The full space.
:type H: ProductSpace
:type A: Operator
:return: Iterative partial trace expression
:rtype: Operator</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.diag">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">diag</tt><big>(</big><em>v</em>, <em>k=0</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#diag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalizes the diagonal matrix creation capabilities of <cite>numpy.diag</cite> to OperatorMatrix objects.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.factor_for_trace">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">factor_for_trace</tt><big>(</big><em>ls</em>, <em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#factor_for_trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.factor_for_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a local space ls to take the partial trace over and an operator, factor the trace such that operators acting on
disjoint degrees of freedom are pulled out of the trace. If the operator acts trivially on ls the trace yields only
a pre-factor equal to the dimension of ls. If there are LocalSigma operators among a product, the trace&#8217;s cyclical property
is used to move to sandwich the full product by <a class="reference internal" href="#qnet.algebra.operator_algebra.LocalSigma" title="qnet.algebra.operator_algebra.LocalSigma"><tt class="xref py py-class docutils literal"><span class="pre">LocalSigma</span></tt></a> operators:</p>
<div class="math">
\[{\rm Tr} A \sigma_{jk} B = {\rm Tr} \sigma_{jk} B A \sigma_{jj}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ls</strong> (<em>HilbertSpace</em>) &#8211; Degree of Freedom to trace over</li>
<li><strong>op</strong> (<em>Operator</em>) &#8211; Operator to take the trace of</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The (partial) trace over the operator&#8217;s spc-degrees of freedom</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.format_number_for_tex">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">format_number_for_tex</tt><big>(</big><em>num</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#format_number_for_tex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.format_number_for_tex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.hstack">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">hstack</tt><big>(</big><em>matrices</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#hstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.hstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalizes <cite>numpy.hstack</cite> to OperatorMatrix objects.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.identifier_to_tex">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">identifier_to_tex</tt><big>(</big><em>identifier</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#identifier_to_tex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.identifier_to_tex" title="Permalink to this definition">¶</a></dt>
<dd><p>If an identifier contains a greek symbol name as a separate word, (e.g. <tt class="docutils literal"><span class="pre">my_alpha_1</span></tt> contains <tt class="docutils literal"><span class="pre">alpha</span></tt> as a separate word, but <tt class="docutils literal"><span class="pre">alphaman</span></tt> doesn&#8217;t) add a backslash in front.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>identifier</strong> (<em>str</em>) &#8211; The string to prepare for LaTeX printing</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An improved version where greek letter symbols can be correctly rendered.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.identity_matrix">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">identity_matrix</tt><big>(</big><em>N</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#identity_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.identity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the N-dimensional identity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>N</strong> (<em>int</em>) &#8211; Dimension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Identity matrix in N dimensions</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.permutation_matrix">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">permutation_matrix</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#permutation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.permutation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orthogonal permutation matrix
<span class="math">\(M_\sigma\)</span>
for a permutation <span class="math">\(\sigma\)</span> defined by the image tuple
<span class="math">\((\sigma(1), \sigma(2),\dots \sigma(n))\)</span>,
such that</p>
<div class="math">
\[M_\sigma \vec{e}_i = \vec{e}_{\sigma(i)}\]</div>
<p>where <span class="math">\(\vec{e}_k\)</span> is the k-th standard basis vector.
This definition ensures a composition law:</p>
<div class="math">
\[M_{\sigma \cdot \tau} = M_\sigma M_\tau.\]</div>
<p>The column form of <span class="math">\(M_\sigma\)</span> is thus given by</p>
<div class="math">
\[M = (\vec{e}_{\sigma(1)}, \vec{e}_{\sigma(2)}, \dots \vec{e}_{\sigma(n)}).\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutation</strong> (<em>tuple</em>) &#8211; A permutation image tuple (zero-based indices!)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.safe_tex">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">safe_tex</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#safe_tex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.safe_tex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.simplify_scalar">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">simplify_scalar</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.simplify_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify all occurences of scalar expressions in s</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s</strong> (<em>Expression or SympyBasic</em>) &#8211; The expression to simplify.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The simplified version.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Expression or SympyBasic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.space">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">space</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.space" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the associated HilbertSpace with an object. Also works for <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator.scalar_types" title="qnet.algebra.operator_algebra.Operator.scalar_types"><tt class="xref py py-attr docutils literal"><span class="pre">Operator.scalar_types</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.tex">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">tex</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#qnet.algebra.operator_algebra.tex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.tuple_sum">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">tuple_sum</tt><big>(</big><em>tuples</em>, <em>inital=0</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#tuple_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.tuple_sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.vstack">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">vstack</tt><big>(</big><em>matrices</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#vstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.vstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalizes <cite>numpy.vstack</cite> to OperatorMatrix objects.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.operator_algebra.zeros">
<tt class="descclassname">qnet.algebra.operator_algebra.</tt><tt class="descname">zeros</tt><big>(</big><em>shape</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/operator_algebra.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.operator_algebra.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalizes <tt class="docutils literal"><span class="pre">numpy.zeros</span></tt> to <a class="reference internal" href="#qnet.algebra.operator_algebra.Matrix" title="qnet.algebra.operator_algebra.Matrix"><tt class="xref py py-class docutils literal"><span class="pre">Matrix</span></tt></a> objects.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-qnet.algebra.permutations">
<span id="permutations-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">permutations</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.permutations" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="qnet.algebra.permutations.BadPermutationError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">BadPermutationError</tt><a class="reference internal" href="_modules/qnet/algebra/permutations.html#BadPermutationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.BadPermutationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.ValueError</span></tt></p>
<p>Can be raised to signal that a permutation does not pass the :py:func:check_permutation test.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.block_perm_and_perms_within_blocks">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">block_perm_and_perms_within_blocks</tt><big>(</big><em>permutation</em>, <em>block_structure</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#block_perm_and_perms_within_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.block_perm_and_perms_within_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a permutation into a block permutation and into permutations acting within each block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>permutation</strong> (<em>tuple</em>) &#8211; The overall permutation to be factored.</li>
<li><strong>block_structure</strong> (<em>tuple</em>) &#8211; The channel dimensions of the blocks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">(block_permutation,</span> <span class="pre">permutations_within_blocks)</span></tt>
Where <tt class="docutils literal"><span class="pre">block_permutations</span></tt> is an image tuple for a permutation of the block indices
and <tt class="docutils literal"><span class="pre">permutations_within_blocks</span></tt> is a list of image tuples for the permutations of the channels
within each block</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.check_permutation">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">check_permutation</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#check_permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.check_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that a tuple of permutation image points <tt class="docutils literal"><span class="pre">(sigma(1),</span> <span class="pre">sigma(2),</span> <span class="pre">...,</span> <span class="pre">sigma(n))</span></tt>
is a valid permutation, i.e. each number from 0 and n-1 occurs exactly once. I.e. the following <strong>set</strong>-equality must hold:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">{sigma(1),</span> <span class="pre">sigma(2),</span> <span class="pre">...,</span> <span class="pre">sigma(n)}</span> <span class="pre">==</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span> <span class="pre">n-1}</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutation</strong> (<em>tuple</em>) &#8211; Tuple of permutation image points</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.compose_permutations">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">compose_permutations</tt><big>(</big><em>alpha</em>, <em>beta</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#compose_permutations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.compose_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the composite permutation</p>
<div class="math">
\[\begin{split}\sigma := \alpha \cdot \beta \\
\Leftrightarrow \sigma(j) = \alpha\left(\beta(j)\right) \\\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> &#8211; first permutation image tuple</li>
<li><strong>beta</strong> (<em>tuple</em>) &#8211; second permutation image tuple</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">permutation image tuple of the composition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.concatenate_permutations">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">concatenate_permutations</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#concatenate_permutations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.concatenate_permutations" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Concatenate two permutations:</dt>
<dd>s = a [+] b</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<em>tuple</em>) &#8211; first permutation image tuple</li>
<li><strong>b</strong> (<em>tuple</em>) &#8211; second permutation image tuple</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">permutation image tuple of the concatenation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.full_block_perm">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">full_block_perm</tt><big>(</big><em>block_permutation</em>, <em>block_structure</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#full_block_perm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.full_block_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend a permutation of blocks to a permutation for the internal signals of all blocks.
E.g., say we have two blocks of sizes (&#8216;block structure&#8217;) <tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">3)</span></tt>,
then a block permutation that switches the blocks would be given by the image tuple <tt class="docutils literal"><span class="pre">(1,0)</span></tt>.
However, to get a permutation of all 2+3 = 5 channels that realizes that block permutation we would need
<tt class="docutils literal"><span class="pre">(2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">1)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_permutation</strong> (<em>tuple</em>) &#8211; permutation image tuple of block indices</li>
<li><strong>block_structure</strong> (<em>tuple</em>) &#8211; The block channel dimensions, block structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A single permutation for all channels of all blocks.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.invert_permutation">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">invert_permutation</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#invert_permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.invert_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the image tuple of the inverse permutation.
:param permutation: A valid (cf. :py:func:check_permutation) permutation.
:return: The inverse permutation tuple
:rtype: tuple</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.permutation_from_block_permutations">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">permutation_from_block_permutations</tt><big>(</big><em>permutations</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#permutation_from_block_permutations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.permutation_from_block_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse operation to <a class="reference internal" href="#qnet.algebra.permutations.permutation_to_block_permutations" title="qnet.algebra.permutations.permutation_to_block_permutations"><tt class="xref py py-func docutils literal"><span class="pre">permutation_to_block_permutations()</span></tt></a>
Compute the concatenation of permutations</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">(1,2,0)</span> <span class="pre">[+]</span> <span class="pre">(0,2,1)</span> <span class="pre">--&gt;</span> <span class="pre">(1,2,0,3,5,4)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutations</strong> (<em>list of tuples</em>) &#8211; A list of permutation tuples
<tt class="docutils literal"><span class="pre">[t</span> <span class="pre">=</span> <span class="pre">(t_0,...,t_n1),</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">(u_0,...,u_n2),...,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">(z_0,...,z_nm)]</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">permutation image tuple
<tt class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">[+]</span> <span class="pre">u</span> <span class="pre">[+]</span> <span class="pre">...</span> <span class="pre">[+]</span> <span class="pre">z</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.permutation_from_disjoint_cycles">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">permutation_from_disjoint_cycles</tt><big>(</big><em>cycles</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#permutation_from_disjoint_cycles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.permutation_from_disjoint_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a permutation image tuple from a list of disjoint cycles
:param cycles: sequence of disjoint cycles
:type cycles: list or tuple
:param offset: Offset to subtract from the resulting permutation image points
:type offset: int
:return: permutation image tuple
:rtype: tuple</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.permutation_to_block_permutations">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">permutation_to_block_permutations</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#permutation_to_block_permutations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.permutation_to_block_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>If possible, decompose a permutation into a sequence of permutations
each acting on individual ranges of the full range of indices.
E.g.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">(1,2,0,3,5,4)</span> <span class="pre">--&gt;</span> <span class="pre">(1,2,0)</span> <span class="pre">[+]</span> <span class="pre">(0,2,1)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutation</strong> (<em>tuple</em>) &#8211; A valid permutation image tuple <tt class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">(s_0,...s_n)</span></tt> with <tt class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of permutation tuples <tt class="docutils literal"><span class="pre">[t</span> <span class="pre">=</span> <span class="pre">(t_0,...,t_n1),</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">(u_0,...,u_n2),...,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">(z_0,...,z_nm)]</span></tt> such that <tt class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">[+]</span> <span class="pre">u</span> <span class="pre">[+]</span> <span class="pre">...</span> <span class="pre">[+]</span> <span class="pre">z</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of tuples</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body">ValueError</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.permutation_to_disjoint_cycles">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">permutation_to_disjoint_cycles</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#permutation_to_disjoint_cycles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.permutation_to_disjoint_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Any permutation sigma can be represented as a product of cycles.
A cycle (c_1, .. c_n) is a closed sequence of indices such that</p>
<blockquote>
<div>sigma(c_1) == c_2, sigma(c_2) == sigma^2(c_1)== c_3, ..., sigma(c_(n-1)) == c_n, sigma(c_n) == c_1</div></blockquote>
<p>Any single length-n cycle admits n equivalent representations in correspondence with which element one defines as c_1.</p>
<blockquote>
<div>(0,1,2) == (1,2,0) == (2,0,1)</div></blockquote>
<p>A decomposition into <em>disjoint</em> cycles can be made unique, by requiring that the cycles are sorted by their smallest element,
which is also the left-most element of each cycle. Note that permutations generated by disjoint cycles commute.
E.g.,</p>
<blockquote>
<div>(1, 0, 3, 2) == ((1,0),(3,2)) &#8211;&gt; ((0,1),(2,3)) normal form</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutation</strong> (<em>tuple</em>) &#8211; A valid permutation image tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of disjoint cycles, that when comb</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body">BadPermutationError</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.permutations.permute">
<tt class="descclassname">qnet.algebra.permutations.</tt><tt class="descname">permute</tt><big>(</big><em>sequence</em>, <em>permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/permutations.html#permute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.permutations.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a permutation sigma({j}) to an arbitrary sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sequence</strong> &#8211; Any finite length sequence <tt class="docutils literal"><span class="pre">[l_1,l_2,...l_n]</span></tt>. If it is a list, tuple or str, the return type will be the same.</li>
<li><strong>permutation</strong> (<em>tuple</em>) &#8211; permutation image tuple</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The permuted sequence <tt class="docutils literal"><span class="pre">[l_sigma(1),</span> <span class="pre">l_sigma(2),</span> <span class="pre">...,</span> <span class="pre">l_sigma(n)]</span></tt></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raise :</th><td class="field-body"><p class="first last">BadPermutationError or ValueError</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qnet.algebra.circuit_algebra">
<span id="circuit-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">circuit_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.circuit_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="circuit-algebra">
<h3>Circuit Algebra<a class="headerlink" href="#circuit-algebra" title="Permalink to this headline">¶</a></h3>
<p>This module defines the circuit algebra for quantum optical feedback and feedforward circuits in the zero-internal time-delay limit.
For more details see <a class="reference internal" href="symbolic_algebra.html#circuit-algebra"><em>The Circuit Algebra module</em></a>.</p>
<p>References:</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Gough, James &amp; Nurdin (2010). Squeezing components in linear quantum feedback networks. Physical Review A, 81(2). doi:10.1103/PhysRevA.81.023804</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[2]</a></td><td>Gough &amp; James (2008). Quantum Feedback Networks: Hamiltonian Formulation. Communications in Mathematical Physics, 287(3), 1109-1132. doi:10.1007/s00220-008-0698-8</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td>Gough &amp; James (2009). The Series Product and Its Application to Quantum Feedforward and Feedback Networks. IEEE Transactions on Automatic Control, 54(11), 2530-2544. doi:10.1109/TAC.2009.2031205</td></tr>
</tbody>
</table>
<dl class="class">
<dt id="qnet.algebra.circuit_algebra.ABCD">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">ABCD</tt><big>(</big><em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>w</em>, <em>space</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>ABCD model class in amplitude representation.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">ABCD(A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">D,</span> <span class="pre">w,</span> <span class="pre">space)</span></tt></div></blockquote>
<p>I.e. for a doubled up vector a = (a_1, ..., a_n, a_1^*, ... a_n^*)^T = double_up((a_1, ..., a_n)^T)
and doubled up noises dA = (dA_1, ..., dA_m, dA_1^*, ..., dA_m^*)^T = double_up((dA_1, ..., dA_n)^T)
The equation of motion for a is</p>
<div class="math">
\[da = A a dt + B (dA + double_up(w) dt)\]</div>
<p>The output field dA&#8217; is given by</p>
<div class="math">
\[dA' = C a dt + D (dA + double_up(w) dt)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>Matrix</em>) &#8211; Coupling matrix: internal to internal, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*n,2*n)</span></tt></li>
<li><strong>B</strong> (<em>Matrix</em>) &#8211; Coupling matrix external input to internal, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*n,2*m)</span></tt></li>
<li><strong>C</strong> (<em>Matrix</em>) &#8211; Coupling matrix internal to external output, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*m,2*n)</span></tt></li>
<li><strong>D</strong> (<em>Matrix</em>) &#8211; Coupling matrix external input to output, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*m,2*m)</span></tt></li>
<li><strong>w</strong> (<em>Matrix</em>) &#8211; Coherent input amplitude vector, <strong>NOT DOUBLED UP</strong>, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(m,1)</span></tt></li>
<li><strong>space</strong> (<em>HilbertSpace</em>) &#8211; Hilbert space with exactly n local factor spaces corresponding to the n internal degrees of freedom.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.A">
<tt class="descname">A</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.A"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling matrix: internal to internal, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*n,2*n)</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.B">
<tt class="descname">B</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.B" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling matrix external input to internal, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*n,2*m)</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.C">
<tt class="descname">C</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.C"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.C" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling matrix internal to external output, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*m,2*n)</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.D">
<tt class="descname">D</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.D" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling matrix external input to output, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(2*m,2*m)</span></tt></p>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.ABCD.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.create" title="Permalink to this definition">¶</a></dt>
<dd><p>See ABCD documentation</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.m">
<tt class="descname">m</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.m"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.m" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of external fields.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.n">
<tt class="descname">n</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.n"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.n" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of oscillators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.Matrix'&gt;, &lt;class 'qnet.algebra.operator_algebra.Matrix'&gt;, &lt;class 'qnet.algebra.operator_algebra.Matrix'&gt;, &lt;class 'qnet.algebra.operator_algebra.Matrix'&gt;, &lt;class 'qnet.algebra.operator_algebra.Matrix'&gt;, &lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.ABCD.w">
<tt class="descname">w</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#ABCD.w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.ABCD.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherent input amplitude vector, <strong>NOT DOUBLED UP</strong>, scalar valued elements, <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(m,1)</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.CPermutation">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CPermutation</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CPermutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The channel permuting circuit. This circuit expression is only a rearrangement of input and output fields.
A channel permutation is given as a tuple of image points. Permutations are usually represented as</p>
<p>A permutation <span class="math">\(\sigma \in \Sigma_n\)</span> of <span class="math">\(n\)</span> elements  is often represented in the following form</p>
<div class="math">
\[\begin{split}\begin{pmatrix}
        1           &amp;       2   &amp; \dots &amp;   n       \\
        \sigma(1)   &amp; \sigma(2) &amp; \dots &amp; \sigma(n)
\end{pmatrix},\end{split}\]</div>
<p>but obviously it is fully sufficient to specify the tuple of images <span class="math">\((\sigma(1), \sigma(2), \dots, \sigma(n))\)</span>.
We thus parametrize our permutation circuits only in terms of the image tuple.
Moreover, we will be working with <em>zero-based indices</em>!</p>
<p>A channel permutation circuit for a given permutation (represented as a python tuple of image indices)
scatters the <span class="math">\(j\)</span>-th input field to the <span class="math">\(\sigma(j)\)</span>-th output field.</p>
<p>It is instantiated as</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">CPermutation(permutation)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutation</strong> (<em>tuple</em>) &#8211; Channel permutation image tuple.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.CPermutation.block_perms">
<tt class="descname">block_perms</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CPermutation.block_perms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation.block_perms" title="Permalink to this definition">¶</a></dt>
<dd><p>If the circuit is reducible into permutations within subranges of the full range of channels,
this yields a tuple with the internal permutations for each such block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.CPermutation.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CPermutation.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation.create" title="Permalink to this definition">¶</a></dt>
<dd><p>See CPermutation docs.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.CPermutation.permutation">
<tt class="descname">permutation</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CPermutation.permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation.permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>The permutation image tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.CPermutation.series_with_permutation">
<tt class="descname">series_with_permutation</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CPermutation.series_with_permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation.series_with_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the series product with another channel permutation circuit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The composite permutation circuit (could also be the identity circuit for n channels)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Circuit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.CPermutation.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'tuple'&gt;,)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.CPermutation.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.CannotConvertToABCD">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CannotConvertToABCD</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CannotConvertToABCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CannotConvertToABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
<p>Is raised when a circuit algebra object cannot be converted to a concrete ABCD object.</p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.CannotConvertToSLH">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CannotConvertToSLH</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CannotConvertToSLH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CannotConvertToSLH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
<p>Is raised when a circuit algebra object cannot be converted to a concrete SLH object.</p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.CannotFactorize">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CannotFactorize</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CannotFactorize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CannotFactorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.CannotVisualize">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CannotVisualize</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CannotVisualize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CannotVisualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
<p>Is raised when a circuit algebra object cannot be visually represented.</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.Circuit">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">Circuit</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract base class for the circuit algebra elements.</p>
<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Circuit.block_structure">
<tt class="descname">block_structure</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.block_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.block_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>If the circuit is <em>reducible</em> (i.e., it can be represented as a :py:class:Concatenation: of individual circuit expressions),
this gives a tuple of cdim values of the subblocks.
E.g. if A and B are irreducible and have <tt class="docutils literal"><span class="pre">A.cdim</span> <span class="pre">=</span> <span class="pre">2</span></tt>, <tt class="docutils literal"><span class="pre">B.cdim</span> <span class="pre">=</span> <span class="pre">3</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the block structure of their Concatenation is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">block_structure</span>
<span class="go">    (2,3),</span>
</pre></div>
</div>
<p>while</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">block_structure</span>
<span class="go">    (2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">block_structure</span>
<span class="go">    (3,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Circuit.cdim">
<tt class="descname">cdim</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.cdim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.cdim" title="Permalink to this definition">¶</a></dt>
<dd><p>The channel dimension of the circuit expression,
i.e. the number of external bosonic noises/inputs that the circuit couples to.</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.coherent_input">
<tt class="descname">coherent_input</tt><big>(</big><em>*input_amps</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.coherent_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.coherent_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Feed coherent input amplitudes into the circuit.
E.g. For a circuit with channel dimension of two,
<cite>C.coherent_input(0,1)</cite> leads to an input amplitude of zero into the first and one into the second port.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_amps</strong> (any of <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator.scalar_types" title="qnet.algebra.operator_algebra.Operator.scalar_types"><tt class="xref py py-attr docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator.scalar_types</span></tt></a>) &#8211; The coherent input amplitude for each port</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The circuit including the coherent inputs.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Circuit</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body">WrongCDimError</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.creduce">
<tt class="descname">creduce</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.creduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.creduce" title="Permalink to this definition">¶</a></dt>
<dd><p>If the circuit is reducible, try to reduce each subcomponent once.
Depending on whether the components at the next hierarchy-level are themselves reducible,
successive <tt class="docutils literal"><span class="pre">circuit.creduce()</span></tt> operations yields an increasingly fine-grained decomposition of a circuit into its most primitive elements.</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.feedback">
<tt class="descname">feedback</tt><big>(</big><em>out_index=None</em>, <em>in_index=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.feedback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.feedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a circuit with self-feedback from the output port (zero-based) <tt class="docutils literal"><span class="pre">out_index</span></tt> to the input port <tt class="docutils literal"><span class="pre">in_index</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>out_index</strong> (<em>int or NoneType</em>) &#8211; The output port from which the feedback connection leaves (zero-based, default = <tt class="docutils literal"><span class="pre">None</span></tt> corresponds to the <em>last</em> port).</li>
<li><strong>in_index</strong> (<em>int or NoneType</em>) &#8211; The input port into which the feedback connection goes (zero-based, default = <tt class="docutils literal"><span class="pre">None</span></tt> corresponds to the <em>last</em> port).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.get_blocks">
<tt class="descname">get_blocks</tt><big>(</big><em>block_structure=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.get_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.get_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>For a reducible circuit, get a sequence of subblocks that when concatenated again yield the original circuit.
The block structure given has to be compatible with the circuits actual block structure,
i.e. it can only be more coarse-grained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>block_structure</strong> (<em>tuple</em>) &#8211; The block structure according to which the subblocks are generated (default = <tt class="docutils literal"><span class="pre">None</span></tt>, corresponds to the circuit&#8217;s own block structure)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple of subblocks that the circuit consists of.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">IncompatibleBlockStructures</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.index_in_block">
<tt class="descname">index_in_block</tt><big>(</big><em>channel_index</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.index_in_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.index_in_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the index a channel has within the subblock it belongs to.
I.e., only for reducible circuits, this gives a result different from the argument itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_index</strong> (<em>int</em>) &#8211; The index of the external channel</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The index of the external channel within the subblock it belongs to.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body">ValueError</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.render">
<tt class="descname">render</tt><big>(</big><em>fname=''</em><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the circuit expression and store the result in a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>basestring</em>) &#8211; Path to an image file to store the result in.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return (str):</th><td class="field-body">The path to the image file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.series_inverse">
<tt class="descname">series_inverse</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.series_inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.series_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse object (under the series product) for a circuit.
In general for any X</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span> <span class="o">==</span> <span class="n">X</span><span class="o">.</span><span class="n">series_inverse</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">X</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span>
<span class="go">    True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the circuit expression in an IPython notebook.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Circuit.space">
<tt class="descname">space</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.space" title="Permalink to this definition">¶</a></dt>
<dd><p>All Hilbert space degree of freedoms associated with a given circuit component.</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.toABCD">
<tt class="descname">toABCD</tt><big>(</big><em>linearize=False</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.toABCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.toABCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ABCD representation of a circuit expression. If <cite>linearize=True</cite> all operator expressions giving rise to non-linear equations of motion are dropped.
This can fail if there are un-substituted pure circuit all_symbols (<a class="reference internal" href="#qnet.algebra.circuit_algebra.CircuitSymbol" title="qnet.algebra.circuit_algebra.CircuitSymbol"><tt class="xref py py-class docutils literal"><span class="pre">CircuitSymbol</span></tt></a>) left in the expression or if <cite>linearize = False</cite> and the circuit includes non-linear SLH models.
(cf. <a class="footnote-reference" href="#id2" id="id5">[1]</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>linearize</strong> (<em>bool</em>) &#8211; Whether or not to explicitly neglect non-linear contributions (default = False)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">ABCD model for the circuit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ABCD</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.Circuit.toSLH">
<tt class="descname">toSLH</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Circuit.toSLH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Circuit.toSLH" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the SLH representation of a circuit. This can fail if there are un-substituted pure circuit all_symbols (<a class="reference internal" href="#qnet.algebra.circuit_algebra.CircuitSymbol" title="qnet.algebra.circuit_algebra.CircuitSymbol"><tt class="xref py py-class docutils literal"><span class="pre">CircuitSymbol</span></tt></a>) left
in the expression or if the circuit includes <em>non-passive</em> ABCD models (cf. <a class="footnote-reference" href="#id2" id="id6">[1]</a>)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.CircuitSymbol">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">CircuitSymbol</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CircuitSymbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CircuitSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Circuit Symbol object, parametrized by an identifier and channel dimension.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">CircuitSymbol(identifier,</span> <span class="pre">cdim)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.CircuitSymbol.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.CircuitSymbol.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.CircuitSymbol.identifier">
<tt class="descname">identifier</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#CircuitSymbol.identifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.CircuitSymbol.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The symbol identifier</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.CircuitSymbol.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'str'&gt;, &lt;type 'int'&gt;)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.CircuitSymbol.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.Concatenation">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">Concatenation</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Concatenation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Concatenation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The concatenation product circuit operation. It can be applied to any sequence of circuit objects.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Concatenation(*operands)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>Circuit</em>) &#8211; Circuits in parallel configuration.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.Concatenation.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.Concatenation.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Concatenation.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = CircuitZero</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.Concatenation.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Concatenation.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.Circuit'&gt;,)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.Concatenation.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.FB">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">FB</tt><big>(</big><em>circuit</em>, <em>out_index=None</em>, <em>in_index=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#FB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.FB" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for :py:class:Feedback: but with additional default values.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">FB(circuit,</span> <span class="pre">out_index</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">in_index</span> <span class="pre">=</span> <span class="pre">None)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>circuit</strong> (<em>Circuit</em>) &#8211; The circuit that undergoes self-feedback</li>
<li><strong>out_index</strong> (<em>int</em>) &#8211; The output port index, default = None &#8211;&gt; last port</li>
<li><strong>in_index</strong> (<em>int</em>) &#8211; The input port index, default = None &#8211;&gt; last port</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The circuit with applied feedback operation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Circuit</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.Feedback">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">Feedback</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Feedback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The circuit feedback operation applied to a circuit of channel dimension &gt; 1
and an from an output port index to an input port index.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Feedback(circuit,</span> <span class="pre">out_index,</span> <span class="pre">in_index)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>circuit</strong> (<em>Circuit</em>) &#8211; The circuit that undergoes self-feedback</li>
<li><strong>out_index</strong> (<em>int</em>) &#8211; The output port index.</li>
<li><strong>in_index</strong> (<em>int</em>) &#8211; The input port index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.Feedback.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Feedback.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback.create" title="Permalink to this definition">¶</a></dt>
<dd><p>See :py:class:Feedback: documentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Feedback.delegate_to_method">
<tt class="descname">delegate_to_method</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.Concatenation'&gt;, &lt;class 'qnet.algebra.circuit_algebra.SLH'&gt;, &lt;class 'qnet.algebra.circuit_algebra.CPermutation'&gt;)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback.delegate_to_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Feedback.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Feedback.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback.operand" title="Permalink to this definition">¶</a></dt>
<dd><p>The circuit that undergoes feedback
:rtype: Circuit</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Feedback.out_in_pair">
<tt class="descname">out_in_pair</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#Feedback.out_in_pair"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback.out_in_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-based feedback port indices (out_index, in_index)
:rtype: tuple</p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.Feedback.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.Circuit'&gt;, &lt;type 'int'&gt;, &lt;type 'int'&gt;)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.Feedback.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.IncompatibleBlockStructures">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">IncompatibleBlockStructures</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#IncompatibleBlockStructures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.IncompatibleBlockStructures" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
<p>Is raised when a circuit decomposition into a block-structure is requested
that is icompatible with the actual block structure of the circuit expression.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.P_sigma">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">P_sigma</tt><big>(</big><em>*permutation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#P_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.P_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a channel permutation circuit for the given index image values.
:param permutation: image points
:type permutation: int
:return: CPermutation.create(permutation)
:rtype: Circuit</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.SLH">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">SLH</tt><big>(</big><em>S</em>, <em>L</em>, <em>H</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>SLH class to encapsulate an open system model that is parametrized as described in <a class="footnote-reference" href="#id3" id="id7">[2]</a> , <a class="footnote-reference" href="#id4" id="id8">[3]</a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SLH</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>S</strong> (<em>Matrix</em>) &#8211; The scattering matrix (with in general Operator-valued elements)</li>
<li><strong>L</strong> (<em>Matrix</em>) &#8211; The coupling vector (with in general Operator-valued elements)</li>
<li><strong>H</strong> (<em>Operator</em>) &#8211; The internal Hamilton operator</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raise :</th><td class="field-body"><p class="first last">ValueError</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SLH.H">
<tt class="descname">H</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.H"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.H" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal Hamilton operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.HL_to_qutip">
<tt class="descname">HL_to_qutip</tt><big>(</big><em>full_space=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.HL_to_qutip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.HL_to_qutip" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return QuTiP representation matrices for the Hamiltonian and the collapse operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>full_space</strong> (<em>HilbertSpace or None</em>) &#8211; The Hilbert space in which to represent the operators.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return tuple:</th><td class="field-body">(H, [L1, L2, ...]) as numerical qutip.Qobj representations.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SLH.L">
<tt class="descname">L</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.L"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.L" title="Permalink to this definition">¶</a></dt>
<dd><p>The coupling vector (with in general Operator-valued elements) of shape <tt class="docutils literal"><span class="pre">(cdim,</span> <span class="pre">1)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SLH.S">
<tt class="descname">S</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.S" title="Permalink to this definition">¶</a></dt>
<dd><p>The scattering matrix (with in general Operator-valued elements) of shape <tt class="docutils literal"><span class="pre">(cdim,</span> <span class="pre">cdim)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.concatenate_slh">
<tt class="descname">concatenate_slh</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.concatenate_slh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.concatenate_slh" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the concatenation product with another SLH object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>SLH</em>) &#8211; Another SLH object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The combined system</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SLH</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand out all operator expressions within S, L and H and return a new SLH object with these expanded expressions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SLH</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.series_with_slh">
<tt class="descname">series_with_slh</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.series_with_slh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.series_with_slh" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the series product with another :py:class:<tt class="docutils literal"><span class="pre">SLH</span></tt> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<em>SLH</em>) &#8211; An upstream SLH circuit.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The combines system.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SLH</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.simplify_scalar">
<tt class="descname">simplify_scalar</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.simplify_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify all scalar expressions within S, L and H and return a new SLH object with the simplified expressions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SLH</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.symbolic_heisenberg_eom">
<tt class="descname">symbolic_heisenberg_eom</tt><big>(</big><em>X=None</em>, <em>noises=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.symbolic_heisenberg_eom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.symbolic_heisenberg_eom" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the symbolic Heisenberg equations of motion of a system operator X.
If no X is given, an OperatorSymbol is created in its place.
If no noises are given, this correspnds to the ensemble-averaged Heisenberg equation of motion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>Operator</em>) &#8211; A system operator</li>
<li><strong>noises</strong> (<em>Operator</em>) &#8211; A vector of noise inputs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The RHS of the Heisenberg equations of motion of X.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Operator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.symbolic_liouvillian">
<tt class="descname">symbolic_liouvillian</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.symbolic_liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.symbolic_liouvillian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.circuit_algebra.SLH.symbolic_master_equation">
<tt class="descname">symbolic_master_equation</tt><big>(</big><em>rho=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SLH.symbolic_master_equation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SLH.symbolic_master_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the symbolic Liouvillian acting on a state rho.
If no rho is given, an OperatorSymbol is created in its place.
This correspnds to the RHS of the master equation
in which an average is taken over the external noise degrees of freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rho</strong> (<em>Operator</em>) &#8211; A symbolic density matrix operator</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The RHS of the master equation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.SeriesInverse">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">SeriesInverse</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SeriesInverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Symbolic series product inversion operation.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">SeriesInverse(circuit)</span></tt></div></blockquote>
<p>One generally has</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SeriesInverse</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">circuit</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">&lt;&lt;</span> <span class="n">SeriesInverse</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span> <span class="o">==</span> <span class="n">cid</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">cdim</span><span class="p">)</span>
<span class="go">    True</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>circuit</strong> (<em>Circuit</em>) &#8211; The circuit system to invert.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.SeriesInverse.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SeriesInverse.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesInverse.create" title="Permalink to this definition">¶</a></dt>
<dd><p>See documentation for <a class="reference internal" href="#qnet.algebra.circuit_algebra.SeriesProduct" title="qnet.algebra.circuit_algebra.SeriesProduct"><tt class="xref py py-class docutils literal"><span class="pre">SeriesProduct</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SeriesInverse.delegate_to_method">
<tt class="descname">delegate_to_method</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.SeriesProduct'&gt;, &lt;class 'qnet.algebra.circuit_algebra.Concatenation'&gt;, &lt;class 'qnet.algebra.circuit_algebra.Feedback'&gt;, &lt;class 'qnet.algebra.circuit_algebra.SLH'&gt;, &lt;class 'qnet.algebra.circuit_algebra.CPermutation'&gt;, &lt;class 'qnet.algebra.abstract_algebra.CIdentity'&gt;)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesInverse.delegate_to_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SeriesInverse.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SeriesInverse.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesInverse.operand" title="Permalink to this definition">¶</a></dt>
<dd><p>The un-inverted circuit</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Circuit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SeriesInverse.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.Circuit'&gt;,)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesInverse.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.circuit_algebra.SeriesProduct">
<em class="property">class </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">SeriesProduct</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SeriesProduct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.circuit_algebra.Circuit" title="qnet.algebra.circuit_algebra.Circuit"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.circuit_algebra.Circuit</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The series product circuit operation. It can be applied to any sequence of circuit objects that have equal channel dimension.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">SeriesProduct(*operands)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; Circuits in feedforward configuration.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.circuit_algebra.SeriesProduct.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesProduct.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SeriesProduct.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = neutral_element</em><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#SeriesProduct.neutral_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesProduct.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.circuit_algebra.SeriesProduct.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.circuit_algebra.Circuit'&gt;,)</em><a class="headerlink" href="#qnet.algebra.circuit_algebra.SeriesProduct.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.circuit_algebra.WrongCDimError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">WrongCDimError</tt><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#WrongCDimError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.WrongCDimError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
<p>Is raised when two object are tried to joined together in series but have different channel dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.check_cdims_mtd">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">check_cdims_mtd</tt><big>(</big><em>dcls</em>, <em>clsmtd</em>, <em>cls</em>, <em>*ops</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#check_cdims_mtd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.check_cdims_mtd" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that all operands (<cite>ops</cite>) have equal channel dimension.</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.cid">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">cid</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#qnet.algebra.circuit_algebra.cid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the circuit identity for n channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; The channel dimension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">n-channel identity circuit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Circuit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.circuit_identity">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">circuit_identity</tt><big>(</big><em>n</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#circuit_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.circuit_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the circuit identity for n channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; The channel dimension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">n-channel identity circuit</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Circuit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.extract_signal">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">extract_signal</tt><big>(</big><em>k</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#extract_signal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.extract_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a permutation that maps the k-th (zero-based) element to the last element,
while preserving the relative order of all other elements.
:param k: The index to extract
:type k: int
:param n: The total number of elements
:type n: int
:return: Permutation image tuple
:rtype: tuple</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.extract_signal_circuit">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">extract_signal_circuit</tt><big>(</big><em>k</em>, <em>cdim</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#extract_signal_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.extract_signal_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a channel permutation circuit that maps the k-th (zero-based) input to the last output,
while preserving the relative order of all other channels.
:param k: Extracted channel index
:type k: int
:param cdim: The channel dimension
:type cdim: int
:return: Permutation circuit
:rtype: Circuit</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.get_common_block_structure">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">get_common_block_structure</tt><big>(</big><em>lhs_bs</em>, <em>rhs_bs</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#get_common_block_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.get_common_block_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>For two block structures <tt class="docutils literal"><span class="pre">aa</span> <span class="pre">=</span> <span class="pre">(a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">an)</span></tt>, <tt class="docutils literal"><span class="pre">bb</span> <span class="pre">=</span> <span class="pre">(b1,</span> <span class="pre">b2,</span> <span class="pre">...,</span> <span class="pre">bm)</span></tt>
generate the maximal common block structure so that every block from aa and bb
is contained in exactly one block of the resulting structure.
This is useful for determining how to apply the distributive law when feeding
two concatenated Circuit objects into each other.</p>
<dl class="docutils">
<dt>Examples:</dt>
<dd><tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1),</span> <span class="pre">(2,</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">(2,</span> <span class="pre">1)</span></tt>
<tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">1),</span> <span class="pre">(2,</span> <span class="pre">1,</span> <span class="pre">2)</span> <span class="pre">-&gt;</span> <span class="pre">(2,</span> <span class="pre">3)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lhs_bs</strong> (<em>tuple</em>) &#8211; first block structure</li>
<li><strong>rhs_bs</strong> (<em>tuple</em>) &#8211; second block structure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.map_signals">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">map_signals</tt><big>(</big><em>mapping</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#map_signals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.map_signals" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given {input:output} mapping in form of a dictionary,
generate the permutation that achieves the specified mapping
while leaving the relative order of all non-specified elements intact.
:param mapping: Input-output mapping of indices (zero-based) {in1:out1, in2:out2,...}
:type mapping: dict
:param n: total number of elements
:type n: int
:return: Signal mapping permutation image tuple
:rtype: tuple
:raise: ValueError</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.map_signals_circuit">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">map_signals_circuit</tt><big>(</big><em>mapping</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#map_signals_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.map_signals_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given {input:output} mapping in form of a dictionary,
generate the channel permutating circuit that achieves the specified mapping
while leaving the relative order of all non-specified channels intact.
:param mapping: Input-output mapping of indices (zero-based) {in1:out1, in2:out2,...}
:type mapping: dict
:param n: total number of elements
:type n: int
:return: Signal mapping permutation image tuple
:rtype: Circuit</p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.circuit_algebra.pad_with_identity">
<tt class="descclassname">qnet.algebra.circuit_algebra.</tt><tt class="descname">pad_with_identity</tt><big>(</big><em>circuit</em>, <em>k</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/circuit_algebra.html#pad_with_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.circuit_algebra.pad_with_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad a circuit by &#8216;inserting&#8217; an n-channel identity circuit at index k.
I.e., a circuit of channel dimension N is extended to one of channel dimension N+n, where the channels
k, k+1, ...k+n-1, just pass through the system unaffected.
E.g. let A, B be two single channel systems</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">CircuitSymbol</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pad_with_identity</span><span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">    (A + cid(2) + B)</span>
</pre></div>
</div>
<p>This method can also be applied to irreducible systems, but in that case the result can not be decomposed as nicely.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<em>int</em>) &#8211; The index at which to insert the circuit</li>
<li><strong>n</strong> (<em>int</em>) &#8211; The number of channels to pass through</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An extended circuit that passes through the channels k, k+1, ..., k+n-1</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Circuit</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qnet.algebra.state_algebra">
<span id="state-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">state_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.state_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="state-algebra">
<h3>State Algebra<a class="headerlink" href="#state-algebra" title="Permalink to this headline">¶</a></h3>
<p>This module implements a basic Hilbert space state algebra.</p>
<p>For more details see <a class="reference internal" href="symbolic_algebra.html#state-algebra"><em>The State (Ket-) Algebra module</em></a>.</p>
<dl class="class">
<dt id="qnet.algebra.state_algebra.BasisKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">BasisKet</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#BasisKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.BasisKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.LocalKet" title="qnet.algebra.state_algebra.LocalKet"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.LocalKet</span></tt></a></p>
<p>Local basis state, labeled by an integer or a string.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BasisKet</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">rep</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hs</strong> (<em>LocalSpace</em>) &#8211; The local Hilbert space degree of freedom.</li>
<li><strong>or int) rep</strong> (<em>(str</em>) &#8211; The basis state label.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.BasisKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.BasisKet.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.BasisKet.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'str'&gt;, &lt;type 'int'&gt;))</em><a class="headerlink" href="#qnet.algebra.state_algebra.BasisKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.Bra">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">Bra</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Bra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The associated dual/adjoint state for any <tt class="docutils literal"><span class="pre">Ket</span></tt> object <tt class="docutils literal"><span class="pre">k</span></tt> is given by <tt class="docutils literal"><span class="pre">Bra(k)</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<em>Ket</em>) &#8211; The state to represent as Bra.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qnet.algebra.state_algebra.Bra.adjoint">
<tt class="descname">adjoint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Bra.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Bra.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The adjoint of a <tt class="docutils literal"><span class="pre">Bra</span></tt> is just the original <tt class="docutils literal"><span class="pre">Ket</span></tt> again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ket</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.Bra.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.Bra.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.state_algebra.Bra.dag">
<tt class="descname">dag</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.Bra.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>The adjoint of a <tt class="docutils literal"><span class="pre">Bra</span></tt> is just the original <tt class="docutils literal"><span class="pre">Ket</span></tt> again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ket</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.Bra.ket">
<tt class="descname">ket</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Bra.ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Bra.ket" title="Permalink to this definition">¶</a></dt>
<dd><p>The state that is represented as a Bra.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ket</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.Bra.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.state_algebra.Ket'&gt;,)</em><a class="headerlink" href="#qnet.algebra.state_algebra.Bra.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.BraKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">BraKet</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#BraKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.BraKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>The symbolic inner product between two states, represented as Bra and Ket:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BraKet</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>In math notation this corresponds to:</p>
<div class="math">
\[\langle b | k \rangle\]</div>
<p>which we define to be linear in the state <span class="math">\(k\)</span> and anti-linear in <span class="math">\(b\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>b</strong> (<em>Ket</em>) &#8211; The anti-linear state argument.</li>
<li><strong>k</strong> (<em>Ket</em>) &#8211; The linear state argument.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.state_algebra.BraKet.bra">
<tt class="descname">bra</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#BraKet.bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.BraKet.bra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.BraKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.BraKet.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.BraKet.ket">
<tt class="descname">ket</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#BraKet.ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.BraKet.ket" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.BraKet.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.state_algebra.Ket'&gt;, &lt;class 'qnet.algebra.state_algebra.Ket'&gt;)</em><a class="headerlink" href="#qnet.algebra.state_algebra.BraKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.CoherentStateKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">CoherentStateKet</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#CoherentStateKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.CoherentStateKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.LocalKet" title="qnet.algebra.state_algebra.LocalKet"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.LocalKet</span></tt></a></p>
<p>Local coherent state, labeled by a scalar amplitude.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CoherentStateKet</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">amp</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hs</strong> (<em>LocalSpace</em>) &#8211; The local Hilbert space degree of freedom.</li>
<li><strong>amp</strong> (<em>Ket.scalar_types</em>) &#8211; The coherent displacement amplitude.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.CoherentStateKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.CoherentStateKet.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.CoherentStateKet.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;class 'qnet.algebra.hilbert_space_algebra.LocalSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;), (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;))</em><a class="headerlink" href="#qnet.algebra.state_algebra.CoherentStateKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.Ket">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">Ket</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Basic Ket algebra class to represent Hilbert Space states</p>
<dl class="method">
<dt id="qnet.algebra.state_algebra.Ket.adjoint">
<tt class="descname">adjoint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Ket.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The adjoint of a Ket state, i.e., the corresponding Bra.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Bra</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.state_algebra.Ket.dag">
<tt class="descname">dag</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>The adjoint of a Ket state, i.e., the corresponding Bra.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Bra</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.state_algebra.Ket.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Ket.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand out distributively all products of sums. Note that this does not expand out sums of scalar coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A fully expanded sum of states.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Ket</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.Ket.scalar_types">
<tt class="descname">scalar_types</tt><em class="property"> = (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;)</em><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.scalar_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.Ket.space">
<tt class="descname">space</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Ket.space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.space" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated Hilbert space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HilbertSpace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.state_algebra.Ket.to_qutip">
<tt class="descname">to_qutip</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#Ket.to_qutip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.Ket.to_qutip" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a numerical representation of the ket as a QuTiP object.
Note that all symbolic scalar parameters need to be replaced by numerical values before calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The numerical representation of the operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">qutip.Qobj</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.KetBra">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">KetBra</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetBra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetBra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>A symbolic operator formed by the outer product of two states:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">KetBra</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> (<em>Ket</em>) &#8211; The first state that defines the range of the operator.</li>
<li><strong>b</strong> (<em>ket</em>) &#8211; The second state that defines the Kernel of the operator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetBra.bra">
<tt class="descname">bra</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetBra.bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetBra.bra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.KetBra.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.KetBra.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetBra.ket">
<tt class="descname">ket</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetBra.ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetBra.ket" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetBra.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.state_algebra.Ket'&gt;, &lt;class 'qnet.algebra.state_algebra.Ket'&gt;)</em><a class="headerlink" href="#qnet.algebra.state_algebra.KetBra.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.KetPlus">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">KetPlus</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetPlus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>A sum of Ket states.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">KetPlus</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>summands</strong> (<em>Ket</em>) &#8211; State summands.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.KetPlus.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.KetPlus.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetPlus.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = KetZero</em><a class="headerlink" href="#qnet.algebra.state_algebra.KetPlus.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.KetPlus.order_key">
<em class="property">classmethod </em><tt class="descname">order_key</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetPlus.order_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetPlus.order_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetPlus.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.state_algebra.Ket'&gt;,)</em><a class="headerlink" href="#qnet.algebra.state_algebra.KetPlus.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.KetSymbol">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">KetSymbol</tt><big>(</big><em>name</em>, <em>hs</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#KetSymbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.KetSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Ket symbol class, parametrized by an identifier string and an associated Hilbert space.</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">KetSymbol(name,</span> <span class="pre">hs)</span></tt></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Symbol identifier</li>
<li><strong>hs</strong> (<em>HilbertSpace</em>) &#8211; Associated Hilbert space.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.KetSymbol.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.KetSymbol.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.KetSymbol.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'str'&gt;, (&lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;))</em><a class="headerlink" href="#qnet.algebra.state_algebra.KetSymbol.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.LocalKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">LocalKet</tt><big>(</big><em>hs</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#LocalKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.LocalKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Base class for atomic (non-composite) ket states of single degrees of freedom.</p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.OperatorTimesKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">OperatorTimesKet</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#OperatorTimesKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.OperatorTimesKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Multiply an operator by a scalar coefficient.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OperatorTimesKet</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ket</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> (<em>Operator</em>) &#8211; The multiplying operator.</li>
<li><strong>ket</strong> (<em>Ket</em>) &#8211; The ket that is multiplied.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.state_algebra.OperatorTimesKet.coeff">
<tt class="descname">coeff</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#OperatorTimesKet.coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.OperatorTimesKet.coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.OperatorTimesKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#OperatorTimesKet.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.OperatorTimesKet.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.OperatorTimesKet.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.Operator'&gt;, &lt;class 'qnet.algebra.state_algebra.Ket'&gt;)</em><a class="headerlink" href="#qnet.algebra.state_algebra.OperatorTimesKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.OperatorTimesKet.term">
<tt class="descname">term</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#OperatorTimesKet.term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.OperatorTimesKet.term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.state_algebra.OverlappingSpaces">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">OverlappingSpaces</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#OverlappingSpaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.OverlappingSpaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.ScalarTimesKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">ScalarTimesKet</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#ScalarTimesKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.ScalarTimesKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Multiply a Ket by a scalar coefficient.</p>
<dl class="docutils">
<dt>Instantiate as::</dt>
<dd>ScalarTimesKet(coefficient, term)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coefficient</strong> (<em>Operator.scalar_types</em>) &#8211; Scalar coefficient.</li>
<li><strong>term</strong> (<em>Ket</em>) &#8211; The ket that is multiplied.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.state_algebra.ScalarTimesKet.coeff">
<tt class="descname">coeff</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#ScalarTimesKet.coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.ScalarTimesKet.coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.ScalarTimesKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.state_algebra.ScalarTimesKet.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.ScalarTimesKet.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;), &lt;class 'qnet.algebra.state_algebra.Ket'&gt;)</em><a class="headerlink" href="#qnet.algebra.state_algebra.ScalarTimesKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.ScalarTimesKet.term">
<tt class="descname">term</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#ScalarTimesKet.term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.ScalarTimesKet.term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.state_algebra.SpaceTooLargeError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">SpaceTooLargeError</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#SpaceTooLargeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.SpaceTooLargeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.state_algebra.TensorKet">
<em class="property">class </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">TensorKet</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#TensorKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.TensorKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.state_algebra.Ket" title="qnet.algebra.state_algebra.Ket"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.state_algebra.Ket</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>A tensor product of kets each belonging to different degrees of freedom.
Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">TensorKet</span><span class="p">(</span><span class="o">*</span><span class="n">factors</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>factors</strong> (<em>Ket</em>) &#8211; Ket factors.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.state_algebra.TensorKet.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#TensorKet.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.TensorKet.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.state_algebra.TensorKet.factor_for_space">
<tt class="descname">factor_for_space</tt><big>(</big><em>space</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#TensorKet.factor_for_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.TensorKet.factor_for_space" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.TensorKet.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = TrivialKet</em><a class="headerlink" href="#qnet.algebra.state_algebra.TensorKet.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.state_algebra.TensorKet.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.state_algebra.Ket'&gt;,)</em><a class="headerlink" href="#qnet.algebra.state_algebra.TensorKet.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.state_algebra.UnequalSpaces">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">UnequalSpaces</tt><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#UnequalSpaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.UnequalSpaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.state_algebra.act_locally">
<tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">act_locally</tt><big>(</big><em>op</em>, <em>ket</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#act_locally"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.act_locally" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.state_algebra.act_locally_times_tensor">
<tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">act_locally_times_tensor</tt><big>(</big><em>op</em>, <em>ket</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#act_locally_times_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.act_locally_times_tensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qnet.algebra.state_algebra.tensor_decompose_kets">
<tt class="descclassname">qnet.algebra.state_algebra.</tt><tt class="descname">tensor_decompose_kets</tt><big>(</big><em>a</em>, <em>b</em>, <em>operation</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/state_algebra.html#tensor_decompose_kets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.state_algebra.tensor_decompose_kets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="module-qnet.algebra.super_operator_algebra">
<span id="super-operator-algebra-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">super_operator_algebra</span></tt> Module<a class="headerlink" href="#module-qnet.algebra.super_operator_algebra" title="Permalink to this headline">¶</a></h2>
<div class="section" id="super-operator-algebra">
<h3>Super-Operator Algebra<a class="headerlink" href="#super-operator-algebra" title="Permalink to this headline">¶</a></h3>
<p>The specification of a quantum mechanics symbolic super-operator algebra.
See <a class="reference internal" href="symbolic_algebra.html#super-operator-algebra"><em>The Super-Operator Algebra module</em></a> for more details.</p>
<dl class="exception">
<dt id="qnet.algebra.super_operator_algebra.BadLiouvillianError">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">BadLiouvillianError</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#BadLiouvillianError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.BadLiouvillianError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraError" title="qnet.algebra.abstract_algebra.AlgebraError"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraError</span></tt></a></p>
<p>Raise when a Liouvillian is not of standard Lindblad form.</p>
</dd></dl>

<dl class="exception">
<dt id="qnet.algebra.super_operator_algebra.CannotSymbolicallyDiagonalize">
<em class="property">exception </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">CannotSymbolicallyDiagonalize</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#CannotSymbolicallyDiagonalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.CannotSymbolicallyDiagonalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.abstract_algebra.AlgebraException" title="qnet.algebra.abstract_algebra.AlgebraException"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.AlgebraException</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SPost">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SPost</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SPost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="qnet.algebra.super_operator_algebra.SuperOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Linear post-multiplication operator.</p>
<p>Use as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SPost</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>Acting <tt class="docutils literal"><span class="pre">SPost(A)</span></tt> on an operator <tt class="docutils literal"><span class="pre">B</span></tt> just yields the reversed product <tt class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">A</span></tt>.</p>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SPost.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPost.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SPost.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.Operator'&gt;,)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPost.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SPre">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SPre</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SPre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPre" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="qnet.algebra.super_operator_algebra.SuperOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Linear pre-multiplication operator.</p>
<p>Use as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SPre</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<p>Acting <tt class="docutils literal"><span class="pre">SPre(A)</span></tt> on an operator <tt class="docutils literal"><span class="pre">B</span></tt> just yields the product <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></tt></p>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SPre.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPre.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SPre.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.operator_algebra.Operator'&gt;,)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SPre.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">ScalarTimesSuperOperator</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#ScalarTimesSuperOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="qnet.algebra.super_operator_algebra.SuperOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Multiply an operator by a scalar coefficient:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ScalarTimesOperator</span><span class="p">(</span><span class="n">coefficient</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coefficient</strong> (<em>Any of SuperOperator.scalar_types</em>) &#8211; Scalar coefficient.</li>
<li><strong>term</strong> (<em>SuperOperator</em>) &#8211; The super-operator that is multiplied.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.coeff">
<tt class="descname">coeff</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#ScalarTimesSuperOperator.coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.signature">
<tt class="descname">signature</tt><em class="property"> = ((&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;), &lt;class 'qnet.algebra.super_operator_algebra.SuperOperator'&gt;)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.term">
<tt class="descname">term</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#ScalarTimesSuperOperator.term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.ScalarTimesSuperOperator.term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperAdjoint">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperAdjoint</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperAdjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperAdjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperatorOperation" title="qnet.algebra.super_operator_algebra.SuperOperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperatorOperation</span></tt></a></p>
<p>The symbolic SuperAdjoint of a super-operator.</p>
<p>Use as:</p>
<div class="math">
\[SuperAdjoint(L)``\]\[For the super-operator :math:`\mathcal{L}`, its super-adjoint :math:`\mathcal{L}^*` satisfies for any pair of operators :math:`M,N`:\]</div>
<div class="math">
\[{\rm Tr}(M (LN)) == Tr((SuperAdjoint(L)*M) * N)``\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sop</strong> (<em>SuperOperator</em>) &#8211; The super-operator to take the adjoint of.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperAdjoint.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperAdjoint.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperAdjoint.operand">
<tt class="descname">operand</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperAdjoint.operand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperAdjoint.operand" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperator</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The super-operator abstract base class.</p>
<p>Any super-operator contains an associated HilbertSpace object,
on which it is taken to act non-trivially.</p>
<dl class="method">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperator.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand out distributively all products of sums. Note that this does not expand out sums of scalar coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A fully expanded sum of superoperators.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">SuperOperator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.scalar_types">
<tt class="descname">scalar_types</tt><em class="property"> = (&lt;type 'int'&gt;, &lt;type 'long'&gt;, &lt;type 'float'&gt;, &lt;type 'complex'&gt;, &lt;class 'sympy.core.basic.Basic'&gt;)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.scalar_types" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.simplify_scalar">
<tt class="descname">simplify_scalar</tt><big>(</big><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.simplify_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify all scalar coefficients within the Operator expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The simplified expression.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Operator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.space">
<tt class="descname">space</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperator.space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.space" title="Permalink to this definition">¶</a></dt>
<dd><p>The Hilbert space associated with the operator on which it acts non-trivially</p>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.superadjoint">
<tt class="descname">superadjoint</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperator.superadjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.superadjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The super-operator adjoint (w.r.t to the <tt class="docutils literal"><span class="pre">Tr</span></tt> operation).
See <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperAdjoint" title="qnet.algebra.super_operator_algebra.SuperAdjoint"><tt class="xref py py-class docutils literal"><span class="pre">SuperAdjoint</span></tt></a> documentation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The super-adjoint of the super-operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">SuperOperator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qnet.algebra.super_operator_algebra.SuperOperator.to_qutip">
<tt class="descname">to_qutip</tt><big>(</big><em>full_space=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperator.to_qutip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperator.to_qutip" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a numerical representation of the super-operator as a QuTiP object.
Note that all symbolic scalar parameters need to be replaced by numerical values before calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>full_space</strong> (<em>HilbertSpace</em>) &#8211; The full Hilbert space in which to represent the superoperator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The matrix representation of the superoperator.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">qutip.Qobj</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorOperation">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperatorOperation</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="qnet.algebra.super_operator_algebra.SuperOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Base class for Operations acting only on SuperOperator arguments.</p>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorOperation.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.super_operator_algebra.SuperOperator'&gt;,)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorOperation.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorPlus">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperatorPlus</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorPlus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperatorOperation" title="qnet.algebra.super_operator_algebra.SuperOperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperatorOperation</span></tt></a></p>
<p>A sum of super-operators.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">OperatorPlus</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>summands</strong> (<em>SuperOperator</em>) &#8211; super-operator summands.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorPlus.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorPlus.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorPlus.neutral_element">
<tt class="descname">neutral_element</tt><em class="property"> = ZeroSuperOperator</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorPlus.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorPlus.order_key">
<em class="property">classmethod </em><tt class="descname">order_key</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorPlus.order_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorPlus.order_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorSymbol">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperatorSymbol</tt><big>(</big><em>name</em>, <em>hs</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorSymbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperator" title="qnet.algebra.super_operator_algebra.SuperOperator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Super-operator symbol class, parametrized by an identifier string and an associated Hilbert space.</p>
<p>Instantiate as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SuperOperatorSymbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Symbol identifier</li>
<li><strong>hs</strong> (<em>HilbertSpace</em>) &#8211; Associated Hilbert space.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorSymbol.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorSymbol.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorSymbol.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;type 'str'&gt;, (&lt;class 'qnet.algebra.hilbert_space_algebra.HilbertSpace'&gt;, &lt;type 'str'&gt;, &lt;type 'int'&gt;, &lt;type 'tuple'&gt;))</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorSymbol.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimes">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperatorTimes</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperatorOperation" title="qnet.algebra.super_operator_algebra.SuperOperatorOperation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.super_operator_algebra.SuperOperatorOperation</span></tt></a></p>
<p>A product of super-operators that denotes order of application of super-operators (right to left):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SuperOperatorTimes</span><span class="p">(</span><span class="o">*</span><span class="n">factors</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>factors</strong> (<em>SuperOperator</em>) &#8211; Super-operator factors.</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimes.SuperOperatorOrderKey">
<em class="property">class </em><tt class="descname">SuperOperatorOrderKey</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimes.SuperOperatorOrderKey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes.SuperOperatorOrderKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Auxiliary class that generates the correct pseudo-order relation for operator products.
Only operators acting on different Hilbert spaces are commuted to achieve the order specified in the full HilbertSpace.
I.e., sorted(factors, key = OperatorOrderKey) achieves this ordering.</p>
</dd></dl>

<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimes.create">
<em class="property">classmethod </em><tt class="descclassname">SuperOperatorTimes.</tt><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimes.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimes.neutral_element">
<tt class="descclassname">SuperOperatorTimes.</tt><tt class="descname">neutral_element</tt><em class="property"> = IdentitySuperOperator</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes.neutral_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimes.order_key">
<tt class="descclassname">SuperOperatorTimes.</tt><tt class="descname">order_key</tt><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes.order_key" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimes.SuperOperatorOrderKey" title="qnet.algebra.super_operator_algebra.SuperOperatorTimes.SuperOperatorOrderKey"><tt class="xref py py-class docutils literal"><span class="pre">SuperOperatorOrderKey</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator">
<em class="property">class </em><tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">SuperOperatorTimesOperator</tt><big>(</big><em>*operands</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimesOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#qnet.algebra.operator_algebra.Operator" title="qnet.algebra.operator_algebra.Operator"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.operator_algebra.Operator</span></tt></a>, <a class="reference internal" href="#qnet.algebra.abstract_algebra.Operation" title="qnet.algebra.abstract_algebra.Operation"><tt class="xref py py-class docutils literal"><span class="pre">qnet.algebra.abstract_algebra.Operation</span></tt></a></p>
<p>Application of a super-operator to an operator (result is an Operator).</p>
<p>Use as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SuperOperatorTimesOperator</span><span class="p">(</span><span class="n">sop</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sop</strong> (<em>SuperOperator</em>) &#8211; The super-operator to apply.</li>
<li><strong>op</strong> (<em>Operator</em>) &#8211; The operator it is applied to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a symbolic operation with the given operands.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Operation</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> (<em>object or as defined in the Operation&#8217;s signature</em>) &#8211; The operands of the expression.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of directly instantiating an instance of any subclass of Operation,
it is advised to call the <tt class="docutils literal"><span class="pre">create()</span></tt> classmethod instead.
This method takes the same arguments as the constructor, but can preprocess them and even return an object
of a different type based on the operands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>operands</strong> &#8211; The operands for the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.op">
<tt class="descname">op</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimesOperator.op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.signature">
<tt class="descname">signature</tt><em class="property"> = (&lt;class 'qnet.algebra.super_operator_algebra.SuperOperator'&gt;, &lt;class 'qnet.algebra.operator_algebra.Operator'&gt;)</em><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.signature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.sop">
<tt class="descname">sop</tt><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#SuperOperatorTimesOperator.sop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.SuperOperatorTimesOperator.sop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="qnet.algebra.super_operator_algebra.anti_commutator">
<tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">anti_commutator</tt><big>(</big><em>A</em>, <em>B=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#anti_commutator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.anti_commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">B</span> <span class="pre">!=</span> <span class="pre">None</span></tt>, return the anti-commutator <span class="math">\(\{A,B\}\)</span>, otherwise return the super-operator <span class="math">\(\{A,\cdot\}\)</span>.
The super-operator <span class="math">\(\{A,\cdot\}\)</span> maps any other operator <tt class="docutils literal"><span class="pre">B</span></tt> to the anti-commutator <span class="math">\(\{A, B\} = A B + B A\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>Operator</em>) &#8211; The first operator to form all anti-commutators of.</li>
<li><strong>or None) B</strong> (<em>(Operator</em>) &#8211; The second operator to form the anti-commutator of, or None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The linear superoperator <span class="math">\([A,\cdot]\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">SuperOperator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.super_operator_algebra.commutator">
<tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">commutator</tt><big>(</big><em>A</em>, <em>B=None</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#commutator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">B</span> <span class="pre">!=</span> <span class="pre">None</span></tt>, return the commutator <span class="math">\([A,B]\)</span>, otherwise return the super-operator <span class="math">\([A,\cdot]\)</span>.
The super-operator <span class="math">\([A,\cdot]\)</span> maps any other operator <tt class="docutils literal"><span class="pre">B</span></tt> to the commutator <span class="math">\([A, B] = A B - B A\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>Operator</em>) &#8211; The first operator to form the commutator of.</li>
<li><strong>or None) B</strong> (<em>(Operator</em>) &#8211; The second operator to form the commutator of, or None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The linear superoperator <span class="math">\([A,\cdot]\)</span></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">SuperOperator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.super_operator_algebra.lindblad">
<tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">lindblad</tt><big>(</big><em>C</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#lindblad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.lindblad" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">SPre(C)</span> <span class="pre">*</span> <span class="pre">SPost(C.adjoint())</span> <span class="pre">-</span> <span class="pre">(1/2)</span> <span class="pre">*</span> <span class="pre">santi_commutator(C.adjoint()*C)</span></tt>.
These are the super-operators <span class="math">\(\mathcal{D}[C]\)</span> that form the collapse terms of a Master-Equation.
Applied to an operator <span class="math">\(X\)</span> they yield</p>
<div class="math">
\[\mathcal{D}[C] X = C X C^\dagger - {1\over 2} (C^\dagger C X + X C^\dagger C)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>C</strong> (<em>Operator</em>) &#8211; The associated collapse operator</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Lindblad collapse generator.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SuperOperator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.super_operator_algebra.liouvillian">
<tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">liouvillian</tt><big>(</big><em>H</em>, <em>Ls=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Liouvillian super-operator associated with a Hamilton operator <tt class="docutils literal"><span class="pre">H</span></tt> and a set of collapse-operators <tt class="docutils literal"><span class="pre">Ls</span> <span class="pre">=</span> <span class="pre">[L1,</span> <span class="pre">L2,</span> <span class="pre">...]</span></tt>.</p>
<p>The Liouvillian <span class="math">\(\mathcal{L}\)</span> generates the Markovian-dynamics of a system via the Master equation:</p>
<div class="math">
\[\dot{\rho} = \mathcal{L}\rho = -i[H,\rho] + \sum_{j=1}^n \mathcal{D}[L_j] \rho\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>H</strong> (<em>Operator</em>) &#8211; The associated Hamilton operator</li>
<li><strong>Ls</strong> (<em>sequence or Matrix</em>) &#8211; A sequence of collapse operators.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Liouvillian super-operator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">SuperOperator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qnet.algebra.super_operator_algebra.liouvillian_normal_form">
<tt class="descclassname">qnet.algebra.super_operator_algebra.</tt><tt class="descname">liouvillian_normal_form</tt><big>(</big><em>L</em>, <em>symbolic=False</em><big>)</big><a class="reference internal" href="_modules/qnet/algebra/super_operator_algebra.html#liouvillian_normal_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qnet.algebra.super_operator_algebra.liouvillian_normal_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Hamilton operator <tt class="docutils literal"><span class="pre">H</span></tt> and a minimal list of collapse operators <tt class="docutils literal"><span class="pre">Ls</span></tt> that generate the liouvillian <tt class="docutils literal"><span class="pre">L</span></tt>.</p>
<p>A Liouvillian defined by a hermitian Hamilton operator <span class="math">\(H\)</span> and a vector of collapse operators
<span class="math">\(\mathbf{L} = (L_1, L_2, \dots L_n)^T\)</span> is invariant under the following two operations:</p>
<div class="math">
\[\begin{split}\left(H, \mathbf{L}\right) &amp; \mapsto \left(H + {1\over 2i}\left(\mathbf{w}^\dagger \mathbf{L} - \mathbf{L}^\dagger \mathbf{w}\right), \mathbf{L} + \mathbf{w} \right) \\
\left(H, \mathbf{L}\right) &amp; \mapsto \left(H, \mathbf{U}\mathbf{L}\right)\\\end{split}\]</div>
<p>where <span class="math">\(\mathbf{w}\)</span> is just a vector of complex numbers and <span class="math">\(\mathbf{U}\)</span> is a complex unitary matrix.
It turns out that for quantum optical circuit models the set of collapse operators is linearly dependent.
This routine tries to find a representation of the Liouvillian in terms of a Hamilton operator <tt class="docutils literal"><span class="pre">H</span></tt> with
as few non-zero collapse operators <tt class="docutils literal"><span class="pre">Ls</span></tt> as possible.
Consider the following example, which results from a two-port linear cavity with a coherent input into the first port:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">kappa_1</span><span class="p">,</span> <span class="n">kappa_2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;kappa_1, kappa_2&#39;</span><span class="p">,</span> <span class="n">positive</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Delta</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;Delta&#39;</span><span class="p">,</span> <span class="n">real</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;alpha&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">Delta</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">I</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ls</span> <span class="o">=</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">kappa_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Destroy</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LL</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Ls</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hnf</span><span class="p">,</span> <span class="n">Lsnf</span> <span class="o">=</span> <span class="n">liouvillian_normal_form</span><span class="p">(</span><span class="n">LL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hnf</span>
<span class="go">    Delta * Create(1) * Destroy(1) - I *  sqrt(kappa_1) * (alpha * Create(1) - alpha.conjugate() * Destroy(1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lsnf</span>
<span class="go">    [sqrt(kappa_1 + kappa_2) * Destroy(1)]</span>
</pre></div>
</div>
<p>In terms of the ensemble dynamics this final system is equivalent.
Note that this function will only work for proper Liouvillians.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>L</strong> (<em>SuperOperator</em>) &#8211; The Liouvillian</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">(H,</span> <span class="pre">Ls)</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">BadLiouvillianError</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qnet.circuit_components.html" title="circuit_components Package"
             >next</a> |</li>
        <li class="right" >
          <a href="qnet.html" title="The qnet API"
             >previous</a> |</li>
        <li><a href="index.html">QNET 1.0 documentation</a> &raquo;</li>
          <li><a href="qnet.html" >The <tt class="docutils literal docutils literal docutils literal"><span class="pre">qnet</span></tt> API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Nikolas Tezak.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>