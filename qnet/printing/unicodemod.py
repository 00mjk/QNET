#    This file is part of QNET.
#
#    QNET is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#    QNET is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with QNET.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2012-2017, QNET authors (see AUTHORS file)
#############################################################################
"""Unicode Printer"""
import re

from sympy.printing.pretty.pretty_symbology import modifier_dict
from sympy.printing.conventions import split_super_sub

from .asciimod import QnetAsciiPrinter
from .sympy import SympyUnicodePrinter


class SubSupFmt():
    """A format string that divides into a name, subscript, and superscript

    >>> fmt = SubSupFmt('{name}', sub='({i},{j})', sup='({sup})')
    >>> fmt.format(name='alpha', i='mu', j='nu', sup=1)
    'Œ±_(Œº,ŒΩ)^(1)'
    >>> fmt = SubSupFmt('{name}', sub='{sub}', sup='({sup})')
    >>> fmt.format(name='alpha', sub='1', sup=1)
    'Œ±‚ÇÅ‚ÅΩ¬π‚Åæ'
    """
    def __init__(self, name, sub=None, sup=None, unicode_sub_super=True):
        self.name = name
        self.sub = sub
        self.sup = sup
        self.unicode_sub_super = unicode_sub_super

    def format(self, **kwargs):
        """Format and combine the name, subscript, and superscript"""
        name = self.name.format(**kwargs)

        subs = []
        if self.sub is not None:
            subs = [self.sub.format(**kwargs)]
        supers = []
        if self.sup is not None:
            supers = [self.sup.format(**kwargs)]

        return render_unicode_sub_super(
            name, subs, supers, sub_first=True, translate_symbols=True,
            unicode_sub_super=self.unicode_sub_super)

    def __repr__(self):
        return "%s(%r, sub=%r, sup=%r, unicode_sub_super=%r)" % (
            self.__class__.__name__, self.name, self.sub, self.sup,
            self.unicode_sub_super)


class SubSupFmtNoUni(SubSupFmt):
    """SubSupFmt with default unicode_sub_super=False"""
    def __init__(self, name, sub=None, sup=None, unicode_sub_super=False):
        super().__init__(name, sub, sup, unicode_sub_super)


class QnetUnicodePrinter(QnetAsciiPrinter):
    """Printer for a string (Unicode) representation."""
    sympy_printer_cls = SympyUnicodePrinter
    printmethod = '_unicode'

    _default_settings = {
        'show_hilbert_space': True,  # alternatively: False, 'subscript'
        'local_sigma_as_ketbra': True,
        'unicode_sub_super': True,
        'operator_hats': True,
    }
    # TODO: allow to drop '*' from products

    _dagger_sym = '‚Ä†'
    _tensor_sym = '‚äó'
    _circuit_series_sym = '‚óÅ'
    _circuit_concat_sym = '‚äû'

    def _render_str(self, string):
        """Returned a unicodified version of the string"""
        string = str(string)
        if len(string) == 0:
            return ''
        name, supers, subs = split_super_sub(string)
        return render_unicode_sub_super(
            name, subs, supers, sub_first=True, translate_symbols=True,
            unicode_sub_super=self._settings['unicode_sub_super'])

    def _braket_fmt(self, expr_type):
        """Return a format string for printing an `expr_type`
        ket/bra/ketbra/braket"""
        if self._settings['unicode_sub_super']:
            sub_sup_fmt = SubSupFmt
        else:
            sub_sup_fmt = SubSupFmtNoUni
        mapping = {
            'bra': {
                True: sub_sup_fmt('‚ü®{label}|', sup='({space})'),
                'subscript': sub_sup_fmt('‚ü®{label}|', sub='({space})'),
                False:  sub_sup_fmt('‚ü®{label}|')},
            'ket': {
                True: sub_sup_fmt('|{label}‚ü©', sup='({space})'),
                'subscript': sub_sup_fmt('|{label}', sub='({space})'),
                False:  sub_sup_fmt('|{label}‚ü©')},
            'ketbra': {
                True: sub_sup_fmt('|{label_i}‚ü©‚ü®{label_j}|', sup='({space})'),
                'subscript': sub_sup_fmt(
                    '|{label_i}‚ü©‚ü®{label_j}|', sub='({space})'),
                False:  sub_sup_fmt('|{label_i}‚ü©‚ü®{label_j}|')},
            'braket': {
                True: sub_sup_fmt('‚ü®{label_i}|{label_j}‚ü©', sup='({space})'),
                'subscript': sub_sup_fmt(
                    '‚ü®{label_i}|{label_j}‚ü©', sub='({space})'),
                False:  sub_sup_fmt('‚ü®{label_i}|{label_j}‚ü©')},
        }
        hs_setting = bool(self._settings['show_hilbert_space'])
        if self._settings['show_hilbert_space'] == 'subscript':
            hs_setting = 'subscript'
        return mapping[expr_type][hs_setting]

    def _render_op(
            self, identifier, hs=None, dagger=False, args=None, superop=False):
        """Render an operator

        Args:
            identifier (str): The identifier (name/symbol) of the operator. May
                include a subscript, denoted by '_'.
            hs (qnet.algebra.hilbert_space_algebra.HilbertSpace): The Hilbert
                space in which the operator is defined
            dagger (bool): Whether the operator should be daggered
            args (list): A list of expressions that will be rendered with
                :meth:`doprint`, joined with commas, enclosed in parenthesis
            superop (bool): Whether the operator is a super-operator
        """
        hs_label = None
        if hs is not None and self._settings['show_hilbert_space']:
            hs_label = self._render_hs_label(hs)
        name, total_subscript, total_superscript, args_str \
            = self._split_op(identifier, hs_label, dagger, args)
        if self._settings['operator_hats'] and len(name) == 1:
            if superop:
                res = name
            else:
                res = modifier_dict['hat'](name)
        else:
            res = name
        res = render_unicode_sub_super(
            res, [total_subscript], [total_superscript], sub_first=True,
            translate_symbols=True,
            unicode_sub_super=self._settings['unicode_sub_super'])
        res += args_str
        return res

    def _print_Feedback(self, expr):
        operand = self.doprint(expr.operand)
        o, i = expr.out_in_pair
        if self._settings['unicode_sub_super']:
            return render_unicode_sub_super(
                '[%s]' % operand, subs=['%s-%s' % (o, i)],
                translate_symbols=False, subscript_max_len=9)
        else:
            return '[%s]_%s‚Üí%s' % (operand, o, i)

    def _print_SeriesInverse(self, expr):
        return r'[{operand}]‚Åª¬π'.format(
            operand=self.doprint(expr.operand))

    def _print_HilbertSpace(self, expr):
        return render_unicode_sub_super(
            '‚Ñå', subs=[self._render_hs_label(expr)])

    def _print_IdentityOperator(self, expr):
        return "ùüô"

    def _print_IdentitySuperOperator(self, expr):
        return "ùüô"


def unicode(expr, cache=None, **settings):
    """Return a unicode textual representation of the given object /
    expression"""
    try:
        if cache is None and len(settings) == 0:
            return unicode.printer.doprint(expr)
        else:
            printer = unicode._printer_cls(cache, settings)
            return printer.doprint(expr)
    except AttributeError:
        # init_printing was not called. Setting up defaults
        unicode._printer_cls = QnetUnicodePrinter
        unicode.printer = unicode._printer_cls()
        return unicode(expr, cache, **settings)


_GREEK_DICTIONARY = {
    'Alpha': 'Œë', 'Beta': 'Œí', 'Gamma': r'Œì', 'Delta': r'Œî', 'Epsilon': 'Œï',
    'Zeta': 'Œñ', 'Eta': 'Œó', 'Theta': r'Œ§', 'Iota': 'Œô', 'Kappa': 'Œö',
    'Lambda': r'Œõ', 'Mu': 'Œú', 'Nu': 'Œù', 'Xi': r'Œû', 'Omicron': 'Œü',
    'Pi': r'Œ†', 'Rho': 'Œ°', 'Sigma': r'Œ£', 'Tau': 'Œ§', 'Upsilon': r'Œ•',
    'Ypsilon': r'Œ•', 'Phi': r'Œ¶', 'Chi': 'Œß', 'Psi': r'Œ®', 'Omega': r'Œ©',
    'alpha': 'Œ±', 'beta': 'Œ≤', 'gamma': r'Œ≥', 'delta': r'Œ¥', 'epsilon': 'Œµ',
    'zeta': 'Œ∂', 'eta': 'Œ∑', 'theta': r'Œ∏', 'iota': 'Œπ', 'kappa': 'Œ∫',
    'lambda': r'Œª', 'mu': 'Œº', 'nu': 'ŒΩ', 'xi': r'Œæ', 'omicron': 'Œø',
    'pi': r'œÄ', 'rho': 'œÅ', 'sigma': r'œÉ', 'tau': 'œÑ', 'upsilon': r'œÖ',
    'ypsilon': r'œÖ', 'phi': r'œÜ', 'chi': 'œá', 'psi': r'Œ®', 'omega': r'œâ',
    'khi': r'œá', 'Khi': r'Œß', 'varepsilon': r'Œµ', 'varkappa': r'Œ∫',
    'varphi': r'œÜ', 'varpi': r'œÄ', 'varrho': r'œÅ', 'varsigma': r'œÇ',
    'vartheta': r'Œ∏',
}

_SUBSCRIPT_MAPPING = {
    '0': '‚ÇÄ', '1': '‚ÇÅ', '2': '‚ÇÇ', '3': '‚ÇÉ', '4': '‚ÇÑ', '5': '‚ÇÖ', '6': '‚ÇÜ',
    '7': '‚Çá', '8': '‚Çà', '9': '‚Çâ', '(': '‚Çç', ')': '‚Çé', '+': '‚Çä', '-': '‚Çã',
    '=': '‚Çå', 'a': '‚Çê', 'e': '‚Çë', 'o': '‚Çí', 'x': '‚Çì', 'h': '‚Çï', 'k': '‚Çñ',
    'l': '‚Çó', 'm': '‚Çò', 'n': '‚Çô', 'p': '‚Çö', 's': '‚Çõ', 't': '‚Çú',
    'Œ≤': '·µ¶', 'Œ≥': '·µß', 'œÅ': '·µ®', 'œÜ': '·µ©', 'œá': '·µ™'
}


_SUPERSCRIPT_MAPPING = {
    '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥', '5': '‚Åµ', '6': '‚Å∂',
    '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ', '+': '‚Å∫', '-': '‚Åª', '=': '‚Åº', '(': '‚ÅΩ',
    ')': '‚Åæ', 'a': '·µÉ', 'b': '·µá', 'c': '·∂ú', 'd': '·µà', 'e': '·µâ', 'f': '·∂†',
    'g': '·µç', 'h': ' ∞', 'i': '‚Å±', 'j': ' ≤', 'k': '·µè', 'l': 'À°', 'm': '·µê',
    'n': '‚Åø', 'o': '·µí', 'p': '·µñ', 'r': ' ≥', 's': 'À¢', 't': '·µó', 'u': '·µò',
    'v': '·µõ', 'w': ' ∑', 'x': 'À£', 'y': ' ∏', 'z': '·∂ª', 'A': '·¥¨', 'B': '·¥Æ',
    'D': '·¥∞', 'E': '·¥±', 'G': '·¥≥', 'H': '·¥¥', 'I': '·¥µ', 'J': '·¥∂', 'K': '·¥∑',
    'L': '·¥∏', 'M': '·¥π', 'N': '·¥∫', 'O': '·¥º', 'P': '·¥æ', 'R': '·¥ø', 'T': '·µÄ',
    'U': '·µÅ', 'V': '‚±Ω', 'W': '·µÇ', 'Œ≤': '·µù', 'Œ≥': '·µû', 'Œ¥': '·µü', 'Œµ': '·µã',
    'Œ∏': '·∂ø', 'Œπ': '·∂•', 'œÜ': '·µ†', 'œá': '·µ°'
}


def render_unicode_sub_super(
        name, subs=None, supers=None, sub_first=True, translate_symbols=True,
        unicode_sub_super=True, sep=',', subscript_max_len=1):
    """Assemble a string from the primary name and the given sub- and
    superscripts::

    >>> render_unicode_sub_super(name='alpha', subs=['mu', 'nu'], supers=[2])
    'Œ±_Œº,ŒΩ^2'

    >>> render_unicode_sub_super(
    ...     name='alpha', subs=['1', '2'], supers=['(1)'], sep='')
    'Œ±‚ÇÅ‚ÇÇ‚ÅΩ¬π‚Åæ'

    >>> render_unicode_sub_super(
    ...     name='alpha', subs=['1', '2'], supers=['(1)'], sep='',
    ...     unicode_sub_super=False)
    'Œ±_12^(1)'

    Args:
        name (str):  the string without the subscript/superscript
        subs (list or None): list of subscripts
        supers (list or None): list of superscripts
        translate_symbols (bool): If True, try to translate (Greek) symbols in
            `name, `subs`, and `supers` to unicode
        unicode_sub_super (bool): It True, try to use unicode
            subscript/superscript symbols
        sep (str): Separator to use if there are multiple
            subscripts/superscripts
        subscript_max_len (int): Maximum character length of subscript that is
            eligible to be rendered in unicode. This defaults to 1, because
            spelling out enire words as a unicode subscript looks terrible in
            monospace (letter spacing too large)
    """
    if subs is None:
        subs = []
    if supers is None:
        supers = []
    if translate_symbols:
        supers = [_translate_symbols(sup) for sup in supers]
        subs = [_translate_symbols(sub) for sub in subs]
        name = _translate_symbols(name)
    res = name
    try:
        if unicode_sub_super:
            supers_modified = [
                    _unicode_sub_super(s, _SUPERSCRIPT_MAPPING)
                    for s in supers]
            subs_modified = [
                    _unicode_sub_super(
                        s, _SUBSCRIPT_MAPPING, max_len=subscript_max_len)
                    for s in subs]
            if sub_first:
                if len(subs_modified) > 0:
                    res += sep.join(subs_modified)
                if len(supers_modified) > 0:
                    res += sep.join(supers_modified)
            else:
                if len(supers_modified) > 0:
                    res += sep.join(supers_modified)
                if len(subs_modified) > 0:
                    res += sep.join(subs_modified)
    except KeyError:
        unicode_sub_super = False
    if not unicode_sub_super:
        sub = sep.join(subs)
        sup = sep.join(supers)
        if sub_first:
            if len(sub) > 0:
                res += "_%s" % sub
            if len(sup) > 0:
                res += "^%s" % sup
        else:
            if len(sup) > 0:
                res += "^%s" % sup
            if len(sub) > 0:
                res += "_%s" % sub
    return res


def _unicode_sub_super(string, mapping, max_len=None):
    """Try to render a subscript or superscript string in unicode, fall back on
    ascii if this is not possible"""
    string = str(string)
    if max_len is not None:
        if len(string) > max_len:
            raise KeyError("max_len exceeded")
    unicode_letters = []
    for letter in string:
        unicode_letters.append(mapping[letter])
    return ''.join(unicode_letters)


def _translate_symbols(string):
    """Given a description of a Greek letter or other special character,
    return the appropriate unicode letter."""
    res = []
    string = str(string)
    for s in re.split(r'(\W+)', string, flags=re.UNICODE):
        tex_str = _GREEK_DICTIONARY.get(s)
        if tex_str:
            res.append(tex_str)
        elif s.lower() in _GREEK_DICTIONARY:
            res.append(_GREEK_DICTIONARY[s])
        else:
            res.append(s)
    return "".join(res)
