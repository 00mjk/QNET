#    This file is part of QNET.
#
#    QNET is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#    QNET is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with QNET.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2012-2017, QNET authors (see AUTHORS file)
#Œû###########################################################################
"""
Routines for rendering expressions to Unicode
"""
import re

from numpy import complex128
import sympy
from sympy.printing.conventions import split_super_sub
from sympy.printing.pretty.pretty_symbology import modifier_dict

from .base import Printer
from ..algebra.singleton import Singleton, singleton_object
from ..algebra.scalar_types import SCALAR_TYPES


class _circuit_fb_fmt():
    @staticmethod
    def format(operand, output, input):
        try:
            return r'[{operand}]{output}‚Çã{input}'.format(
                    operand=operand,
                    output=unicode_sub_super(output, subscript_mapping),
                    input=unicode_sub_super(input, subscript_mapping))
        except KeyError:
            return r'[{operand}]_{output}‚Üí{input}'.format(
                    operand=operand, output=output, input=input)


class _hilbert_space_fmt():
    @staticmethod
    def format(label):
        try:
            return r'‚Ñå{label}'.format(
                    label=unicode_sub_super(label, subscript_mapping, 1))
        except KeyError:
            return r'‚Ñå_{label}'.format(label=label)


class _bra_fmt():
    @staticmethod
    def format(label, space):
        try:
            return r'‚ü®{label}|{space}'.format(
                    label=label,
                    space=unicode_sub_super("("+space+")",
                                            subscript_mapping, 3))
        except KeyError:
            return r'‚ü®{label}|_({space})'.format(label=label, space=space)


class _ket_fmt():
    @staticmethod
    def format(label, space):
        try:
            return r'|{label}‚ü©{space}'.format(
                    label=label,
                    space=unicode_sub_super("("+space+")",
                                            subscript_mapping, 3))
        except KeyError:
            return r'|{label}‚ü©_({space})'.format(label=label, space=space)


class _ketbra_fmt():
    @staticmethod
    def format(label_i, label_j, space):
        try:
            return r'|{label_i}‚ü©‚ü®{label_j}|{space}'.format(
                    label_i=label_i, label_j=label_j,
                    space=unicode_sub_super("("+space+")",
                                            subscript_mapping, 3))
        except KeyError:
            return r'|{label_i}‚ü©‚ü®{label_j}|_({space})'.format(
                    label_i=label_i, label_j=label_j, space=space)


class _braket_fmt():
    @staticmethod
    def format(label_i, label_j, space):
        try:
            return r'‚ü®{label_i}|{label_j}‚ü©{space}'.format(
                    label_i=label_i, label_j=label_j,
                    space=unicode_sub_super("("+space+")",
                                            subscript_mapping, 3))
        except KeyError:
            return r'‚ü®{label_i}|{label_j}‚ü©_({space})'.format(
                    label_i=label_i, label_j=label_j, space=space)


@singleton_object
class UnicodePrinter(Printer, metaclass=Singleton):
    """Printer that renders greek latters and sub-/superscripts in unicode. See
    :class:`Printer` for details"""

    head_repr_fmt = r'{head}({args}{kwargs})'
    identity_sym = 'ùüô'
    zero_sym = '0'
    dagger_sym = r'‚Ä†'
    daggered_sym = r'^‚Ä†'
    scalar_product_sym = r'*'
    tensor_sym = r'‚äó'
    inner_product_sym = r'¬∑'
    op_product_sym = r' '
    circuit_series_sym = '‚óÅ'
    circuit_concat_sym = '‚äû'
    circuit_fb_fmt = _circuit_fb_fmt
    null_space_proj_sym = "P_Ker"
    hilbert_space_fmt = _hilbert_space_fmt
    bra_fmt = _bra_fmt
    ket_fmt = _ket_fmt
    ketbra_fmt = _ketbra_fmt
    braket_fmt = _braket_fmt

    _registry = {}

    @classmethod
    def _render(cls, expr, adjoint=False):
        return expr._unicode_(adjoint=adjoint)

    @classmethod
    def render_string(cls, ascii_str):
        """Render an ascii string to unicode by replacing e.g. greek letters"""
        if len(ascii_str) == 0:
            return ''
        name, supers, subs = split_super_sub(ascii_str)
        name = _translate_symbols(name)
        supers = [_translate_symbols(sup) for sup in supers]
        subs = [_translate_symbols(sub) for sub in subs]
        try:
            supers_modified = [
                    unicode_sub_super(s, superscript_mapping)
                    for s in supers]
            subs_modified = [
                    unicode_sub_super(s, subscript_mapping, 1)
                    for s in subs]
            if len(supers_modified) > 0:
                name += " ".join(supers_modified)
            if len(subs_modified) > 0:
                name += " ".join(subs_modified)
        except KeyError:
            if len(supers) > 0:
                name += "^%s" % " ".join(supers)
            if len(subs) > 0:
                name += "_%s" % " ".join(subs)
        return name

    @classmethod
    def render_op(cls, identifier, hs=None, dagger=False, args=None,
                  superop=False):
        """Render an operator"""
        hs_label = None
        if hs is not None:
            hs_label = cls.render_hs_label(hs)
        name, total_subscript, total_superscript, args_str \
            = cls._split_op(identifier, hs_label, dagger, args)
        if len(name) == 1:
            if superop:
                res = name
            else:
                res = modifier_dict['hat'](name)
        else:
            res = name
        try:
            sub_super = ''
            if len(total_subscript) > 0:
                sub_super += unicode_sub_super(
                             total_subscript, subscript_mapping, 1)
            if len(total_superscript) > 0:
                sub_super += unicode_sub_super(
                             total_superscript, superscript_mapping)
            res += sub_super
        except KeyError:
            if len(total_subscript) > 0:
                res += "_" + total_subscript
            if len(total_superscript) > 0:
                res += "^" + total_superscript
        if len(args_str) > 0:
            res += args_str
        return res

    @classmethod
    def render_scalar(cls, value, adjoint=False):
        """Render a scalar value (numeric or symbolic)"""
        if adjoint:
            value = sympy.conjugate(value)
        res = sympy.pretty(
                value, use_unicode=True, wrap_line=False)
        if "\n" in res:
            res = str(value)
            for string in re.findall(r'[A-Za-z]+', res):
                if string in _greek_dictionary:
                    res = res.replace(string, _greek_dictionary[string])
        return res


_greek_dictionary = {
    'Alpha': 'Œë', 'Beta': 'Œí', 'Gamma': r'Œì', 'Delta': r'Œî', 'Epsilon': 'Œï',
    'Zeta': 'Œñ', 'Eta': 'Œó', 'Theta': r'Œ§', 'Iota': 'Œô', 'Kappa': 'Œö',
    'Lambda': r'Œõ', 'Mu': 'Œú', 'Nu': 'Œù', 'Xi': r'Œû', 'Omicron': 'Œü',
    'Pi': r'Œ†', 'Rho': 'Œ°', 'Sigma': r'Œ£', 'Tau': 'Œ§', 'Upsilon': r'Œ•',
    'Ypsilon': r'Œ•', 'Phi': r'Œ¶', 'Chi': 'Œß', 'Psi': r'Œ®', 'Omega': r'Œ©',
    'alpha': 'Œ±', 'beta': 'Œ≤', 'gamma': r'Œ≥', 'delta': r'Œ¥', 'epsilon': 'Œµ',
    'zeta': 'Œ∂', 'eta': 'Œ∑', 'theta': r'Œ∏', 'iota': 'Œπ', 'kappa': 'Œ∫',
    'lambda': r'Œª', 'mu': 'Œº', 'nu': 'ŒΩ', 'xi': r'Œæ', 'omicron': 'Œø',
    'pi': r'œÄ', 'rho': 'œÅ', 'sigma': r'œÉ', 'tau': 'œÑ', 'upsilon': r'œÖ',
    'ypsilon': r'œÖ', 'phi': r'œÜ', 'chi': 'œá', 'psi': r'Œ®', 'omega': r'œâ',
    'khi': r'œá', 'Khi': r'Œß', 'varepsilon': r'Œµ', 'varkappa': r'Œ∫',
    'varphi': r'œÜ', 'varpi': r'œÄ', 'varrho': r'œÅ', 'varsigma': r'œÇ',
    'vartheta': r'Œ∏',
}


def _translate_symbols(string):
    """Given a description of a Greek letter or other special character,
    return the appropriate latex."""
    res = []
    for s in re.split(r'([,.:\s]+)', string):
        tex_str = _greek_dictionary.get(s)
        if tex_str:
            res.append(tex_str)
        elif s.lower() in _greek_dictionary:
            res.append(_greek_dictionary[s])
        else:
            res.append(s)
    return "".join(res)


def unicode(expr):
    """Return a unicode representation of the given `expr`"""
    return UnicodePrinter.render(expr)


subscript_mapping = {
    '0': '‚ÇÄ', '1': '‚ÇÅ', '2': '‚ÇÇ', '3': '‚ÇÉ', '4': '‚ÇÑ', '5': '‚ÇÖ', '6': '‚ÇÜ',
    '7': '‚Çá', '8': '‚Çà', '9': '‚Çâ', '(': '‚Çç', ')': '‚Çé', '+': '‚Çä', '-': '‚Çã',
    '=': '‚Çå', 'a': '‚Çê', 'e': '‚Çë', 'o': '‚Çí', 'x': '‚Çì', 'h': '‚Çï', 'k': '‚Çñ',
    'l': '‚Çó', 'm': '‚Çò', 'n': '‚Çô', 'p': '‚Çö', 's': '‚Çõ', 't': '‚Çú',
    'Œ≤': '·µ¶', 'Œ≥': '·µß', 'œÅ': '·µ®', 'œÜ': '·µ©', 'œá': '·µ™'
}


superscript_mapping = {
    '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥', '5': '‚Åµ', '6': '‚Å∂',
    '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ', '+': '‚Å∫', '-': '‚Åª', '=': '‚Åº', '(': '‚ÅΩ',
    ')': '‚Åæ', 'a': '·µÉ', 'b': '·µá', 'c': '·∂ú', 'd': '·µà', 'e': '·µâ', 'f': '·∂†',
    'g': '·µç', 'h': ' ∞', 'i': '‚Å±', 'j': ' ≤', 'k': '·µè', 'l': 'À°', 'm': '·µê',
    'n': '‚Åø', 'o': '·µí', 'p': '·µñ', 'r': ' ≥', 's': 'À¢', 't': '·µó', 'u': '·µò',
    'v': '·µõ', 'w': ' ∑', 'x': 'À£', 'y': ' ∏', 'z': '·∂ª', 'A': '·¥¨', 'B': '·¥Æ',
    'D': '·¥∞', 'E': '·¥±', 'G': '·¥≥', 'H': '·¥¥', 'I': '·¥µ', 'J': '·¥∂', 'K': '·¥∑',
    'L': '·¥∏', 'M': '·¥π', 'N': '·¥∫', 'O': '·¥º', 'P': '·¥æ', 'R': '·¥ø', 'T': '·µÄ',
    'U': '·µÅ', 'V': '‚±Ω', 'W': '·µÇ', 'Œ≤': '·µù', 'Œ≥': '·µû', 'Œ¥': '·µü', 'Œµ': '·µã',
    'Œ∏': '·∂ø', 'Œπ': '·∂•', 'œÜ': '·µ†', 'œá': '·µ°'
}


def unicode_sub_super(string, mapping, max_len=None):
    """Try to render a subscript string in unicode, fall back on ascii if this
    is not possible"""
    string = str(string)
    if max_len is not None:
        if len(string) > max_len:
            raise KeyError("max_len exceeded")
    unicode_letters = []
    for letter in string:
        unicode_letters.append(mapping[letter])
    return ''.join(unicode_letters)
