import hashlib
import uuid
import re
from collections import OrderedDict

import numpy as np


class TrajectoryData(object):
    """Tabular data of expectation values for one or more trajectories

    :attribute ID: A unique ID for the current state of the TrajectoryData.
        Changes when the `extend` method is called
    :type ID: str
    :attribute table: A table (OrderedDict of column names to numpy arrays)
        that contains four column for every known operator (real/imaginary
        part of the expectation value, real/imaginary part of the variance).
        Note that the `table` attribute can easily be converted to a pandas
        DataFrame (``DataFrame(data=traj.table)``)
    :type table: OrderedDict(str) => numpy array
    :attribute dt: Time step between data points
    :type dt: float
    :attribute nt: Number of time steps / data points
    :type nt: int
    :attribute operators: A list of operator names. The column names in the
        `table` attribute derive from these. Assuming "X" is one of the
        operator names, there will be four keys in `table`:
       "Re[<X>]", "Im[<X>]", "Re[var(X)]", "Im[var(X)]"
    :type operators: list of str
    :attribute record: A complete record of how the averaged expectation values
        for all operators were obtained.
    :type record: dict(str) => tuple(int, int, list)

    All attributes should be considered read-only (i.e., after instantiation,
    they must only be updated by the  `extend` method)
    """
    _uuid_namespace = uuid.UUID('c84069eb-cf80-48a6-9584-74b7f2c742c1')
    _prec_dt = 1.0e-6 # how close dt's have to be to be equal

    def __init__(self, ID, dt, seed, n_trajectories, data):
        """Initialize a new TrajectoryData instance

        :param ID: A unique, RFC 4122 compliant identifier (as generated by the
            `new_id` class method)
        :type ID: str
        :param dt: Time step between data points (>0)
        :type dt: float
        :param seed: The random number generator seed on which the data is
            based
        :type seed: int
        :param n_trajectories: The number of trajectories from which the data
            is averaged (It is assumed that the random number generator was
            seeded with the given seed, and then the given number of
            trajectories were calculated *sequentially*)
        :type n_trajectories: int
        :param data: dictionary (preferably OrderedDict) of expectation value
            data. The value of `data[operator_name]` must be a tuple of four
            numpy arrays (real part of expectation value, imaginary part of
            expectation value, real part of standard deviation, imaginary part
            of standard deviation)
        :type data: dict(str) => tuple of arrays

        :raises ValueError: if `ID` is not RFC 4122 compliant, `dt` is an
            invalid or non-positive float, data does not follow the correct
            structure
        """
        self.ID = str(uuid.UUID(ID)) # self.ID = ID, with validation
        self.table = OrderedDict()
        self.dt = float(dt)
        if self.dt <= 0.0:
            raise ValueError("dt must be a value >0")
        self.operators = []
        for op, (re_exp, im_exp, re_var, im_var) in data.items():
            op = str(op)
            if op in self.operators:
                raise ValueError("All operators must have unique names")
            else:
                self.operators.append(op)
            self.nt = len(re_exp) # assumed valid for all (check below)
            self.table['Re[<'+op+'>]']    = np.array(re_exp, dtype=np.float64)
            self.table['Im[<'+op+'>]']    = np.array(im_exp, dtype=np.float64)
            self.table['Re[var('+op+')]'] = np.array(re_var, dtype=np.float64)
            self.table['Im[var('+op+')]'] = np.array(im_var, dtype=np.float64)
        for col in self.table:
            if len(self.table[col]) != self.nt:
                raise ValueError("All columns must be of length nt")
        self.record = {}
        self.record = {self.ID: (seed, n_trajectories, self.operators)}

    @classmethod
    def read(cls, filename):
        """Read in TrajectoryData from the given filename. The file must be in
        the format generated by the `write` method"""
        raise NotImplementedError()

    @classmethod
    def from_qsd_data(cls, operators, seed):
        """Instantiate from one or more QSD output files specified as values of
        the dictionary `operators`

        Each QSD output file must have the following structure:
        * The first line must start with the string "Number_of_Trajectories",
          followed by an integer (separated by whitespace)
        * All following lines must contain five floating point numbers
          (time, real/imaginary part of expectation value, and real/imaginary
          part of variance), separated by whitespace.

        All QSD output files must contain the same number of lines, specify the
        same number of trajectories, and use the same time grid values (first
        column). It is the user's responsibility to ensure that all out output
        files were indeed generated in a single QSD run using the specified
        initial seed for the random number generator.

        :param operators: dictionary (preferrably OrderedDict) of operator
            name to filename. Each filename must contain data in the format
            described above
        :type operators: dict(str) => str
        :param seed: The seed to the random number generator that was used to
            produce the data file
        :type seed: int

        :raises ValueError: if any of the datafiles do not have the correct
            format or are inconsistent
        """
        md5 = '' # accumulated MD5 hash of all read files
        data = OrderedDict();
        n_trajectories = None
        dt = None
        for (operator_name, file_name) in operators.items():
            md5 += hashlib.md5(open(file_name,'rb').read()).hexdigest()
            with open(file_name) as in_fh:
                header = in_fh.readline()
                m = re.match(r'Number_of_Trajectories\s*(\d+)', header)
                if m:
                    file_n_trajectories = int(m.group(1))
                else:
                    raise ValueError(("First line in %s must contain the "
                                      "Number_of_Trajectories")%file_name)
            (tgrid, re_exp, im_exp, re_var, im_var) \
            = np.genfromtxt(file_name, dtype=np.float64, skip_header=1,
                            unpack=True)
            data[operator_name] = (re_exp, im_exp, re_var, im_var)
            file_dt = tgrid[1] - tgrid[0]
            if dt is None:
                dt = file_dt
            else:
                if abs(dt-file_dt) > cls._prec_dt:
                    raise ValueError(("dt in file %s inconsistent with dt "
                                      "in other files")%file_name)
            if n_trajectories is None:
                n_trajectories = file_n_trajectories
            else:
                if n_trajectories != file_n_trajectories:
                    raise ValueError(("number of trajectories in file %s "
                                      "does not match number of trajectories "
                                      "in other files")%file_name)
        ID = cls.new_id(name=md5)
        return cls(ID, dt, seed, n_trajectories, data)

    @classmethod
    def new_id(cls, name=None):
        """Generate a new unique identifier, as a string. The identifier will
        be RFC 4122 compliant. If name is None, the resulting ID will be
        random. Otherwise, name must be a string that the ID will depend on.
        That is, calling `new_id` repeatedly with the same `name` will
        result in identical IDs.
        """
        if name is None:
            return str(uuid.uuid4())
        else:
            return str(uuid.uuid3(cls._uuid_namespace, name))

    @property
    def record_IDs(self):
        """Set of all IDs in the record"""
        return set(self.record.keys())

    @property
    def record_seeds(self):
        """Set of all random number generator seeds in the record"""
        return set([seed for (seed, ntraj, op) in self.record.values()])

    def operator_record(self, operator_name):
        """Returns a list of tuples (seed, n_trajectories) that specify how the
        current expectation values for the given operator where obtained"""
        raise NotImplementedError()

    def write(self, filename):
        """Write data to a text file, for plotting with an external program.
        The TrajectoryData may later be restored by the `read` class method
        from the file"""
        raise NotImplementedError()

    def n_trajectories(self, operator):
        "Return the total number of trajectories for the given operator"
        raise NotImplementedError()

    def extend(self, other):
        """Extend data with another Trajectory data set

        :raises ValueError: if data in self and other are incompatible
        """
        err_msg = "TrajectoryData may only be extended by completely "\
                  "disjunct other TrajectoryData object"
        if not self.record_IDs.isdisjoint(other.record_IDs):
            raise ValueError("%s: Repeated ID"%err_msg)
        if not self.record_seeds.isdisjoint(other.record_seeds):
            raise ValueError("%s: Repeated seed"%err_msg)
        if not abs(self.dt - other.dt) < self._prec_dt:
            raise ValueError("Extending TrajectoryData does not match dt")
        # TODO: average data
        raise NotImplementedError()
        self.record.update(other.record)
        self.ID = self.new_id()


